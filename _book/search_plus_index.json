{"./":{"url":"./","title":"Java阶段性笔记","keywords":"","body":"简介 Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。 Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。 《Java阶段性学习笔记》 随着Java的学习进度持续更新，并且伴随知识累计会进一步修正和完善里面的内容，保持本作品的活力。 笔记内容不保证通俗易懂，我只是把学到的东西用自己的语言、代码、贴图展现出来， 只希望能帮助到有需要的人 Java阶段性学习笔记 由 李炎 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。 本作品采用Gitbook于2020年4月21日创建。 本站由提供CDN加速/云存储服务。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase1/开发环境安装.html":{"url":"javase1/开发环境安装.html","title":"1. 开发环境安装","keywords":"","body":"1. 开发环境安装 下载JDK及安装： 访问Oracle官方下载地址下载所需的JDK版本。 Windows系统的安装包是.exe可执行文件，下载好后双击，按照提示下一步即可，安装路径推荐默认。 Mac平台下载相应的版本即可。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase1/配置环境变量.html":{"url":"javase1/配置环境变量.html","title":"1.1 Java配置环境变量","keywords":"","body":"1.2 配置环境变量 JDK安装完成之后，就需要给系统配置Java环境变量了。 配置环境变量：桌面计算机右键属性-->高级系统设置-->环境变量 在系统变量中新建变量JAVA_HOME(如上图)： 变量名：JAVA_HOME 变量值：JDK的安装路径 JDK的默认安装路径一般在C盘下Program Files -->Java文件夹下，参考下图。 （路径一定要全，复制到jdk文件夹下的bin文件夹） 编辑系统变量中的Path，在path的值中加入一条 %JAVA_HOME%\\bin; 验证是否安装成功 环境变量配置好后，在cmd窗口敲入命令： java -version 终端提示Java版本号，说明环境变量配置成功。 如果没有配置成功，终端会显示【不是内部或外部命令，也不是可运行的程序或批处理文件】。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase1/安装JDK.html":{"url":"javase1/安装JDK.html","title":"1.2 科普什么是JDK？","keywords":"","body":"1.1 安装JDK 扩展： JDK 科普 Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。由于JDK的一部分特性采用商业许可证，而非开源[1]。因此，2006年太阳微系统宣布将发布基于GPL的开源JDK，使JDK成为自由软件。在去掉了少量闭源特性之后，太阳微系统最终促成了GPL的OpenJDK的发布。 作为Java语言的SDK，普通用户并不需要安装JDK来运行Java程序，而只需要安装JRE（Java Runtime Environment）。而程序开发者必须安装JDK来编译、调试程序。 包含组件： JDK包含了一批用于Java开发的组件，其中包括： javac：编译器，将后缀名为.java的源代码编译成后缀名为“.class”的字节码 java：运行工具，运行.class的字节码 jar：打包工具，将相关的类文件打包成一个文件 javadoc：文档生成器，从源码注释中提取文档，注释需符合规范 jdb debugger：调试工具 jps：显示当前java程序运行的进程状态 javap：反编译程序 appletviewer：运行和调试applet程序的工具，不需要使用浏览器 javah：从Java类生成C头文件和C源文件。这些文件提供了连接胶合，使Java和C代码可进行交互。[2] javaws：运行JNLP程序 extcheck：一个检测jar包冲突的工具 apt：注释处理工具[3] jhat：java堆分析工具 jstack：栈跟踪程序 jstat：JVM检测统计工具 jstatd：jstat守护进程 jinfo：获取正在运行或崩溃的java程序配置信息 jmap：获取java进程内存映射信息 idlj：IDL-to-Java编译器。将IDL语言转化为java文件[4] policytool：一个GUI的策略文件创建和管理工具 jrunscript：命令行脚本运行 JDK中还包括完整的JRE（Java Runtime Environment），Java运行环境，也被称为private runtime。包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。 JDK中还包括各种样例程序，用以展示Java API中的各部分。 JRE Java运行环境（Java Runtime Environment，简称JRE）是一个软件，由太阳微系统所研发，JRE可以让电脑系统运行Java应用程序（Java Application）。 JRE的内部有一个Java虚拟机（Java Virtual Machine，JVM）以及一些标准的类别函数库（Class Library）。 来页面的介绍大都来自维基百科。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase1/用STS新建一个Java文件.html":{"url":"javase1/用STS新建一个Java文件.html","title":"1.3 IDE：集成开发环境","keywords":"","body":"1.3 用STS新建一个Java文件 首先来介绍下什么是IDE（集成开发环境）： 集成开发环境（Integrated Development Environment，简称IDE，也称为Integration Design Environment、Integration Debugging Environment）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。有些IDE包含编译器／解释器，如微软的Microsoft Visual Studio，有些则不包含，如Eclipse、SharpDevelop等，这些IDE是通过调用第三方编译器来实现代码的编译工作的。有时IDE还会包含版本控制系统和一些可以设计图形用户界面的工具。许多支持面向对象的现代化IDE还包括了类别浏览器、对象查看器、对象结构图。虽然当前有一些IDE支持多种编程语言（例如Eclipse、NetBeans、Microsoft Visual Studio），但是一般而言，IDE主要还是针对特定的编程语言而量身打造（例如Visual Basic）。 Java常用的开发工具有：eclipse、IDEA、Spring Tool Suite(sts)等。 这里我们使用的是sts，sts是基于eclipse工具并集成了Spring，它本身也是使用Java语言编写的，完全开源、免费。 eclipse本身也是一款开源的开发工具，完全免费。 IDEA是jetbrains公司开发的一款Java开发工具，深受企业级开发者喜爱，但它是付费的。 安装开发工具之前，一定要安装JDK并配置好环境变量！！！ 打开安装好的sts工具，双击工具图标后会出现： 然后会出现对话框，选择工作空间文件夹。工作空间的路径可以默认也可以自定义。 选择好工作空间后，点击Launch，进入工具的工作页面： 新建Java文件流程： 新建项目：在sts工具package explorer空白处，右键鼠标，New-->Java Project，新建java工程 project name：工程名 JRE项选择所需要的JDK版本，这里选择JRE1.8（此处是java开发所需的jdk环境） 创建包：鼠标右键新建的工程目录下src，New-->Package 包名通常是域名的反写，例如com.neu.demo 创建java文件：鼠标右键创建好的包，New-->Class Name：类名 一个类文件要想编译并运行，类文件里要包含main方法（程序运行的入口） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase1/main方法的使用.html":{"url":"javase1/main方法的使用.html","title":"1.4 Java程序的入口：main","keywords":"","body":"1.4 main方法的使用 main方法是java程序运行于Jvm的入口，具备main方法，类文件才能运行； 所有的Java代码严格区分大小写； 所有的代码的字母包括符号必须是英文输入状态下的。 public class Demo{ /* * 方法名：main * 方法修饰符：static * 方法的返回值：void * 方法的作用域：public * 方法的参数：String[]--字符串类型的数组，参数类型; args--参数名称，（可以自定义） * 方法功能：Java程序在jvm中的运行入口，每一个类只能有一个main方法，并不是所有的java类都有main方法 */ public static void main(String[] args){ } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase1/第一个java程序.html":{"url":"javase1/第一个java程序.html","title":"1.5 第一个Java程序","keywords":"","body":"1.5 第一个Java程序 Hello World： //编写我们的第一个Java程序 public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Hello World!\") } } 运行结果： Hello World! 其中： public 访问修饰符（公共的） class 类（定义类的关键字） Demo 类名（类名自定义，一般采用驼峰法命名，单词的首字母大写） static 静态（静态方法） void 无返回值（该方法不返回任何值，后面会有讲到） main 方法名 （main方法是一个Java程序运行的入口，Jvm通过main方法开始运行程序） (String[] args) 方法的参数列表 System.out.println(\"Hello World!\") 在控制台打印Hello World! 让我们一起打开Java的大门吧 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase2/Java注释的格式.html":{"url":"javase2/Java注释的格式.html","title":"2. Java中的注释","keywords":"","body":"2.1 Java注释的格式 在计算机语言中，注释是计算机语言的一个重要组成部分，用于在源代码中解释代码的功用，可以增强程序的可读性，可维护性，或者用于在源代码中处理不需运行的代码段，来调试程序的功能执行。 注释是用于解释代码功能，增加代码可读性，使代码更易于维护， Java源文件在编译过程中，编译器会自动忽略注释的内容。 Jave的注释格式： 单行注释，描述一行可以完成的内容 public class Demo{ //这是main方法 public static void main(String[] args){ //方法体 } } 多行注释，注释内容为多行，多行注释不能嵌套使用 public class Demo{ /* 这是多行注释 可以换行继续写 多行注释中可以嵌套单行注释 //例如这样 */ public static void main(String[] args){ //方法体 } } 文档注释（按项目组要求完成注释） /** 这是文档注释 */ public class Demo{ //这是main方法 public static void main(String[] args){ //方法体 } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase3/Java中的关键字.html":{"url":"javase3/Java中的关键字.html","title":"3. Java中的关键字","keywords":"","body":"3. Java中的关键字 定义 被Java语言赋予了特定含义的单词，这些单词已经拥有固定的功能，只能用这些单词来实现某一功能。 比如：声明一个类，使用class ​ 声明类是公共的，使用public来修饰class Java语言中所有的关键字都是小写的。 保留字 goto和const作为保留字存在，目前并不使用 关键字 用于数据类型的 用于数据类型的关键字有 boolean、byte、char、 double、 false、float、int、long、new、short、true、void、instanceof。 用于语句的 用于语句的关键字有break、case、 catch、 continue、 default 、do、 else、 for、 if、return、switch、try、 while、 finally、 throw、this、 super。 用于修饰的 用于修饰的关键字有 abstract、final、native、private、 protected、public、static、synchronized、 　　transient、 volatile。 用于方法、类、接口、包和异常的 用于方法、类、接口、包和异常的关键字有 class、 extends、 implements、interface、 package、import、throws。 其它的 还有些关键字,如cat、 future、 generic、innerr、 operator、 outer、rest、var等都是Java保留的没有意义的关键字。 　　另外，Java还有3个保留字:true、false、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样,它们也不可以作为标识符使用 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase4/标识符.html":{"url":"javase4/标识符.html","title":"4. 标识符","keywords":"","body":"4. 标识符 Java当中所有能够自己定义名字的地方，都叫标识符。如：类名、变量名、方法名、接口名、枚举名。 标识符的命名规则： 标识符的组成： 字母 数字 下划线 _ 美元符 $ 标识符开头不能为数字 标识符中不能有空格 标识符不能是Java的关键字 标识符的命名规范： 定义名称要有意义，尽量使用英文单词，见名知义。 类名、接口名、枚举名要用大驼峰命名（每个单词首字母大写） public class MyInformationAboutStudy{} 变量名、方法名要用小驼峰命名（第一个单词首字母小写，其余后面每个单词首字母均大写） int myName; public static void myShow(){} public static void changeUI(){} 常量名每个单词字母大写，单词之间用下划线连接 int MY_INT int MY_INT_TEMP1 **包名使用域名的反写形式： www.shiguangping.com => com.shiguangping.包名 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase5/变量.html":{"url":"javase5/变量.html","title":"5. 变量","keywords":"","body":"5. 变量 通俗的说，变量就是可以变的量 变量是存放在内存中的某一块连续的空间内。且该值在固定的数据类型内可以变化。 变量是写在Java程序中，Java程序是运行在JVM虚拟机中，虚拟机又是在电脑的内存里运行，所以变量是存在于内存当中的。 内存是一块连续的空间，空间是由多个二进制位(bit)组成的。 内存中的某一位或者多个位用来存放变量。 示例： public class Demo{ public static void main(String[] arge){ int a = 10;//定义一个整型变量a，把整数常量10赋值给变量a double b = 10.0;//定义一个double类型的变量b } } Java是强类型语言，跟JavaScript不同，定义变量是什么类型就是什么类型。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase5/创建变量.html":{"url":"javase5/创建变量.html","title":"5.1 创建变量","keywords":"","body":"5.1 创建变量 创建变量的两种方式： 先声明一个变量再赋值： int a; a=10; 先声明一个整型变量a，再为其赋值10。 声明变量的同时给变量赋值 int a = 10; 声明一个变量a并赋值 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase5/使用变量.html":{"url":"javase5/使用变量.html","title":"5.2 使用变量","keywords":"","body":"5.2 使用变量 通过变量名找到并访问存放该变量值的内存区域，通过修改和查询实现对该变量的操作。 简单的说就是通过调用变量名完成对变量的赋值和取值： public class Demo{ public static void main(String[] args){ int a = 10; System.out.println(a); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase5/变量的作用域.html":{"url":"javase5/变量的作用域.html","title":"5.3 变量的作用域","keywords":"","body":"5.3 变量的作用域 变量是有作用域范围的，一个变量的作用范围取决于它声明的位置，它的作为范围是在它所在的大括号内以及这个大括号中嵌套的大括号。 举个例子： 字符串a声明在这个类成员属性的位置，也就是最外面的大括号中，那么在这个大括号以及内部的大括号中都可以访问字符串a： public class Demo{ String a = \"我是一个字符串！\"; public static void main(String[] args){ System.out.println(a); } } 下面的字符串a生米拿在myMethod()方法中，所以a只能在该方法中被调用，而在该方法外部无法被使用： public class Demo1{ public static void main(String[] args){ } public static void myMethod(){ String a = \"我是一个字符串！\" //此处的a只能在该方法下使用，因为a的作用域只在所在的{}内。 } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase5/变量的初始值.html":{"url":"javase5/变量的初始值.html","title":"5.4 变量的初始值","keywords":"","body":"5.4 变量的初始值 变量的值可以在声明的时候赋值，也可以在声明之后赋值，1.如果一个局部变量没有被赋初始值，则该变量无法被使用。但是针对于成员变量，可以不赋值使用，2.声明成员变量不赋值的话，系统会默认给初始值。 第一种情况： public class Demo1{ public static void main(String[] args){ int a;//声明局部变量a System.out.println(a) } } 此时编译时会报错，因为变量a没有赋初始值。 Demo.java:4: 错误: 可能尚未初始化变量a System.out.println(a); ^ 1 个错误 第二种情况： public class Demo1{ static int a;//声明成员变量a public static void main(String[] args){ System.out.println(a) } } 编译并运行： liyan@liyandeMacBook-Pro ~/Documents/Java_2019/1903/day02/代码 $ java Demo 0 此时，整型变量a的默认值为0。 上面提到了成员变量、局部变量的概念，这个会在变量的分类中详细解释 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase5/变量的分类.html":{"url":"javase5/变量的分类.html","title":"5.5 变量的分类","keywords":"","body":"5.5 变量的分类 按变量声明的位置划分 成员变量：变量定义在类的内部，方法的外部（在面向对象编程里，也叫成员属性）。 public class Demo1{ static int a;//成员变量a,类的内部,方法的外部 public static void main(String[] args){ System.out.println(a) } } 局部变量：定义在方法的内部。 public class Demo1{ public static void main(String[] args){ int b;//局部变量b System.out.println(b) } } 成员变量和局部变量的区别： 定义位置不同 初始化值的问题： 局部变量使用前需要赋初始值 成员变量有访问权限修饰符，局部变量没有。局部变量的访问权限是跟其所在的方法相同。 局部变量优先的问题： public class Demo{ static int a = 0;//成员变量a public static void myMethod1(){ int a = 20;//局部变量也可声明a：局部优先 System.out.println(\"myMethod1方法:\"+a); } public static void main(String[] args){ System.out.println(\"主方法:\"+a); myMethod1(); } } 编译并运行： 主方法:0 myMethod1方法:20 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase6/常量.html":{"url":"javase6/常量.html","title":"6. 常量","keywords":"","body":"6. 常量 常量的概念： 什么是常量？ Java中，通过final关键字修饰的变量叫做常量，因为被final修饰，表示该变量的最终的，所有该变量需要在声明的时候赋初始值，或者在构造方法中赋初始值，并且赋值之后不能再次被赋值。 声明一个常量 final int A = 10; 声明的常量A值为10，且此后不能再被赋值。 Java语言没有真正意义上定义常量的关键字，但我们可以通过使用final关键字来修饰一个变量，被final修饰的变量，不允许再被赋值，也就成了常量。 常量的命名一般为大写： final String STUDENT_SEX; Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase7/数据类型.html":{"url":"javase7/数据类型.html","title":"7. 数据类型","keywords":"","body":"7. 数据类型 数据类型的分类： Java是强类型的语言，声明变量时必须定义变量的数据类型。 基本数据类型： 整数类型：用来描述数值的类型，根据数据的大小划分为4种 byte：字节类型（会开辟1个字节的内存空间，1byte=8bit） short：短整型（会开辟2个字节的内存空间，2byte=16bit） int：整型（会开辟4个字节的空间，4byte=32bit） long：长整型（会开辟8个字节空间，8byte=64bit） 浮点类型：存储小数的 float：单精度（会开辟4个字节空间，4byte） double：双精度（会开辟8个字节空间，8byte） 字符类型：char（会开辟2个字节空间，2byte，存放1个字符或者1个中文） 布尔类型：boolean（会开辟1个字节空间，存放0或者1，即false/true） int a = 10; double b = 20.1; boolean bool = true; char ch = 'a'; 引用数据类型： （引用类型的特点：有自己的属性和方法，在后面面向对象会提到） 类，接口，数组，枚举 字符串是类，所以字符串也是引用数据类型 String str = \"字符串\"; Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase7/数据类型转换.html":{"url":"javase7/数据类型转换.html","title":"7.1 数据类型转换","keywords":"","body":"7.1 数据类型转换 在实际开发过程中，有时需要开发者将不同数据类型的值进行转换，这个过程称为数据类型转换。 由于每个数据类型所占用的内存空间是不同的，所以在类型转换时也会有区别，类型转换主要分以下两种： 7.1.1自动类型转换（隐式类型转换） 空间占用小的数据往大转是自动类型转换，白话解释就是小的盒子放到大的盒子里面是没有问题的。 Demo： public class Demo06 { public static void main(String[] args) { /* * 观察b到s的转换，s到i的转换，这个过程是隐式转换（自动转换） */ byte b = 1; short s = 2; int i = 3; s = b; i = s; System.out.println(\"b(byte)转换成s（short）的值为：\"+s); System.out.println(\"s(short)转换成i（int）的值为：\"+i); } } b(byte)转换成s（short）的值为：1 s(short)转换成i（int）的值为：1 从小的存储空间到大的存储空间转换，一般都是自动类型转换（隐式类型转换），byte->short->int->long 关于整数的默认类型，以及会产生的一些小问题 在基本数据类型当中，Java会把整数默认为int类型，会把小数默认为double类型，这句话怎么解释呢？ byte a = 100; //java会把100当做int类型，100没有超出byte的内存大小，所以可以成功赋值 short b = 200; //short也是同样道理 int c = 300; byte a = 100; 为什么int类型的整数，可以直接赋值给byte呢？ 原因在于，byte的取值范围是-128~127之间，我们一般向下转型时，会产生精度丢失。但是我们使用明确的数值常量（-128~127）给byte赋值时，是不会产生精度丢失的，因为整数常量100在byte的取值范围内，编译器是认识常量值的，知道100在byte的合法取值范围内。因此，Java允许这样赋值。 但是有些情况会出现问题，比如下面的代码。在编译的时候，是报错的： long num = 99999999999999; // error 把整数99999999999999赋值给long num为什么会报错呢？ 原因：因为99999999999999在 Java编译器中默认是int类型，但是 99999999999999 明显的超出了 int 的取值范围；因此，这里就会报错，我们需要在整数后面加上一个 L ，告诉编译器，这是一个 long 类型数字 ； long num = 99999999999999L; // ok 下面的代码，作为参考理解： byte a = 50; //ok byte b = 60; //ok byte c = a+b; //error byte c = 10+20; //ok byte d = 127+5; //error 127+5超出了byte取值范围 byte c = a+b; 为什么会报错呢？ 上面说int整数常量赋值给byte，在byte取值范围内可以赋值，为什么这里会报错呢？原因在于，a和b都是变量，编译器虽然可以知道a和b的两个变量的值都在byte取值范围内，但是由于它们是变量，变量相加的值，编译器在编译期间是无从得知的，因此也无法判断相加的值会不会超过byte的取值范围，所以会报错。 7.1.2强制类型转换（显式类型转换） 强制类型转换实际就是从大往小转，就是把大箱子装到小的箱子里，这种情况有可能会丢失精度，无法保证数值的准确性。 double a = 10.1; float b = (float)a; //需要把double类型的a强制转换成float Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase7/关于byte类型b+=1和b=b+1的问题.html":{"url":"javase7/关于byte类型b+=1和b=b+1的问题.html","title":"7.2 关于byte b+=1和b=b+1的问题","keywords":"","body":"7.2 关于byte b+=1和b=b+1的问题 这是今天上课时遇到的问题，我上网查了很多资料，加上自己的理解，做一下解释。 首先我们要明确知道一点： Java语言规范明确说明：整数常量如果末尾带L是long类型，不带L则是int类型(An integer literal is of type long if it is suffixed with an ASCII letter L or l (ell); otherwise it is of type int )。 声明：解释或许不专业，但是理解大概意思即可，没必要纠结为什么这样，非要纠结就从了解javac编译器和学习java源代码开始吧。 byte b = 1; //ok byte b = 1; ++b; //ok byte b = 1; b += 1; //ok byte b = 1; b = b + 1; //error 图为eclipse中四段代码的演示 这四段代码，前三段代码都没有问题，最后一段代码编译器会报错:cannot convert from int to byte 为什么b=b+1会报错？ 首先，整数常量1是int类型，b是byte类型，(b+1)的值是int类型（如下图），把int类型的值赋值给byte，不经过强制转换，导致编译报错。（为什么不会强转下面会说道） 这里(b+1)，会先把b自动转换成int类型再进行+1运算。 Java把byte、short类型数据提升到int类型这种情况称为widening conversion，把int转为byte、short类型这种情况称为narrowing conversion。 在赋值时，Java要求赋值符号(＝)右边的类型必须被转为左边的类型。 Java会自动执行转换的情况有5种，其中有widening conversion而没有narrowing conversion，也就是说Java会自动把byte、short类型数据转换成int，而不会自动把int类型数据转换成byte或者short。所以，第四段代码中b=b+1的右边是int，Java不会自动转为byte，于是造成＝左右类型不一致，导致编译时报错。 为什么b=1、++b和b+=1编译运行正常？ 上面说Java不会自动把int类型数据转换成byte或者short，那为什么b=1、++b和b+=1不会报错呢？原因是它们属于特殊情况。 对于byte b = 1;，Java语言规范是这么说的：如果＝的右边是常量表达式，而且类型是byte、short、char或int，那么Java在必要时会自动执行narrowing conversion，只要这个常量表达式的值在＝左边变量的取值范围之内(if the expression is a constant expression of type byte, short, char, or int: A narrowing primitive conversion may be used if the type of the variable is byte, short, or char, and the value of the constant expression is representable in the type of the variable) 。 所以，byte b = 1; 1是常量表达式，类型是int，且在byte的取值范围之内，所以Java会自动执行narrowing conversion，编译运行正常。但如果写成byte b = 128; 128虽然是常量值，但超出byte的取值范围(-128~127)，导致编译报错。 对于++b，Java语言规范说：如有必要，++计算之后的结果会先执行narrowing conversion，再存入变量中（If necessary, the sum is narrowed by a narrowing primitive conversion and/or subjected to boxing conversion (§5.1.7) to the type of the variable before it is stored）。 也就是说b自加1之后的值自动执行了narrowing conversion，然后再赋值给b，保证了编译正常。 同样b+=1也是一样，它等价于b = (byte) (b + 1);，(b+1)的值有一个自动强转的过程，然后再赋值给b，编译运行正常。 理解即可，不必纠结 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase8/进制.html":{"url":"javase8/进制.html","title":"8. 进制","keywords":"","body":"8. 进制 8.1 计算机中的存储单位 计算机存储的数据都是以2进制比特位数据来存储的。 1byte=8bit（8个位数的二进制） 1个数字或者1个字母占用1个字节 1个汉字占用2个字节 为什么Java中char类型只能存1个字母或数字呢？ char类型的值是1个字符（无论是数字、字母还是汉字），1个字符在计算机中占用2个字节 8.2 常用进制 十进制：逢十进一，每个位数上只能是0-9的任意数字； 二进制：逢二进一，每个位数上只能是0或1； 八进制：逢八进一，每个位数上只能是0-7的任意数字； 十六进制，逢十六进一，每个数位上可以使0-9，A-F的任意数字； 8.3 通过Java内置类实现进制转换 通过Integer类实现进制转换 package com.neu.demo; /** * @author liyan * 说明：通过Java完成进制转换 */ public class Demo05 { public static void main(String[] args) { /* * 通过Java自带的内置类完成进制转换 * 类名：Integer * 方法名：toBinaryString() 将数值转换为二进制 * 方法名：toOctalString() 将数值转换为八进制 * 方法名：toHexString() 将数值转换为十六进制 * */ System.out.println(\"十进制55转换为二进制结果为：\"+Integer.toBinaryString(55)); System.out.println(\"十进制55转换为八进制结果为：\"+Integer.toOctalString(55)); System.out.println(\"十进制55转换为十六进制结果为：\"+Integer.toHexString(55)); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase9/运算符.html":{"url":"javase9/运算符.html","title":"9. 运算符","keywords":"","body":"9. 运算符 赋值运算符 =赋值符号 把\"=\"号右侧的值或变量赋给左侧 算术运算符 +号的用途： 代表数值的正负 执行加法运算 连接字符串 自加、自减优先级高于其他算是运算符： 优先级高于其他算是运算符 自加和自减和变量一起使用，实现变量自加1或者自减1； 自加和自减可以放在变量左侧，也可以放在变量右侧，这两种使用方式是有区别的，参考如下。 int a = 1; int b = 1; System.out.println(\"++在变量左侧时，结果为\"+(++a));//++在变量左侧，先执行自加，再执行输出 System.out.println(\"++在变量右侧时，结果为\"+(b++));//++在变量右侧，先执行输出，再自加 System.out.println(\"当前变量b的结果为：\"+b);//自加后b的值 ++在变量左侧时，结果为2 ++在变量右侧时，结果为1 当前变量b的结果为：2 ++在变量左侧，先执行自加，再执行输出 ++在变量右侧，先执行输出，再自加 --自减的使用方法也是同理 思考题： public class Demo03 { public static void main(String[] args) { int a = 12; int b = 45; int c; c = a + b--; System.out.println(\"a的值：\"+a); System.out.println(\"b的值：\"+b); System.out.println(\"c的值：\"+c); } } 运行结果： a的值：12 b的值：44 c的值：57 += ：a+=b,相等于 a=a+b; -= : a-=b,相当于a=a-b; *= /= %= 关系运算符 也称“比较运算符”，完成数据比较。 public class Demo06 { public static void main(String[] args) { /* * 关系运算符也成为比较运算符 */ int a = 10; int b = 12; System.out.println(a>b); //比较运算符显示的值是boolean类型的值 System.out.println(a=b); System.out.println(a!=b); System.out.println(a==b); } } 运行结果： false true true false true false 逻辑运算符 与 && 或 || 非 ！ public class Demo07 { public static void main(String[] args) { System.out.println(\"true&&true: \"+(true&&true)); //与 System.out.println(\"true&&false: \"+(true&&false)); //或 System.out.println(\"true||false: \"+(true||false)); //非 System.out.println(\"!false: \"+!false); } } 运行结果： true&&true: true true&&false: false true||false: true !false: true 扩展： && 逻辑与，也称”短路运算“，当逻辑与左侧的表达式为false时，右侧的表达式就不参与运算了； & 单个与不属于短路运算，单个的与左侧表达式为false时，右侧仍然继续运算。 || 逻辑或，也称”短路或运算“，当逻辑或左侧的表达式为true时，右侧的表达式不参与运算； | 单个或，或左侧表达式为true时，右侧仍继续运算。 开发中逻辑运算推荐使用短路与、短路或。 三元运算符 格式： 表达式1?表达式2:表达式3; 如果表达式1为true，则表达式2的值为三元运算的结果； 如果表达式1为false，则表达式3的值为三元运算的结果。 public class Demo10 { public static void main(String[] args) { int a = 24; int b = 25; int c; c = a>b ? a : b; System.out.println(c); } } 运行结果： 25 利用三元运算符比较三个数的大小： public class Demo10 { public static void main(String[] args) { int a = 24; int b = 25; int d = 56; int c; c = (a>b?a:b)>d?(a>b?a:b):d; System.out.println(c); } } 运行结果： 56 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase10/流程控制.html":{"url":"javase10/流程控制.html","title":"10. 流程控制","keywords":"","body":"10. 流程控制 要掌握条件语句和循环语句。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase10/顺序结构.html":{"url":"javase10/顺序结构.html","title":"10.1 顺序结构","keywords":"","body":"10.1 顺序结构 Java语言是从上向下逐行执行的。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase10/条件语句.html":{"url":"javase10/条件语句.html","title":"10.2 条件语句","keywords":"","body":"10.2 条件语句 在 Java中有两种条件判断语句，它们分别是： if语句 switch语句 if语句： if语句由一个布尔表达式跟一个或多个语句组成。 语法 if语句的语法是： if(a>b){ System.out.println(\"如果a>b为true，则执行该输出\"); } 示例 public class Test { public static void main(String args[]){ int x = 10; if( x 这将产生以下结果： This is if statement if...else语句 任何一个if语句后面可以跟一个可选的else语句，当布尔表达式为false，语句被执行。 语法 if...else的语法是： if(a>b){ System.out.println(\"如果a>b为true，则执行该输出\"); }else{ System.out.println(\"如果a>b为false，则执行该输出\"); } 示例 public class Test { public static void main(String args[]){ int x = 30; if( x 这将产生以下结果： This is else statement if...else if...else语句 if后面可以跟一个可选的else if...else语句，在不同条件下单一的if语句和else if语句是非常有用的。 当使用if，else if，else语句时有几点要牢记。 一个if语句可以有0个或一个else语句 且它必须在else if语句的之后。 一个if语句可以有0个或多个else if语句且它们必须在else语句之前。 一旦else if语句成功，则余下的else if语句或else语句都不会被执行。 switch小括号中只能是byte、short、int、char、枚举类型（enum JDK5以后）、String（JDK7以后）这几种数据类型。 语法 if...else的语法是： if(a>b){ System.out.println(\"如果a>b为true，则执行该输出\"); }else if(a==b){ System.out.println(\"如果a==b为true，则执行该输出\"); }else{ System.out.println(\"如果上述两个布尔表达式都为false，则执行该输出\"); } 示例 public class Test { public static void main(String args[]){ int x = 30; if( x == 10 ){ System.out.print(\"Value of X is 10\"); }else if( x == 20 ){ System.out.print(\"Value of X is 20\"); }else if( x == 30 ){ System.out.print(\"Value of X is 30\"); }else{ System.out.print(\"This is else statement\"); } } } 这将产生以下结果： Value of X is 30 嵌套if...else语句 它始终是合法的嵌套if-else语句，这意味着你可以在另一个if或else if语句中使用一个if或else if语句。 语法 嵌套if...else的语法如下： if(a>b){ if(a==0){ System.out.println(\"如果a>b为true，并且a==0时，执行该语句\") } } 示例 public class Test { public static void main(String args[]){ int x = 30; int y = 10; if( x == 30 ){ if( y == 10 ){ System.out.print(\"X = 30 and Y = 10\"); } } } } 这将产生以下结果： X = 30 and Y = 10 switch语句： switch语句允许一个变量来对一系列值的相等性进行测试。每个值被称为case，并且被启动的变量会为每一个case值检查。 以下规则适用于 switch 语句： 在 switch 语句中使用的变量只能是一个字节，short，int 或 char。 在一个 switch 语句中可以有任何数量的 case 语句。每个 case 后跟着即将被比较的值和一个冒号。 对于 case 的值必须是相同的数据类型作为开关变量，它必须是一个常量或文字。 当被启动了的变量与 case 是相等的，那 case 后的语句将执行，一直到 break 为止。 当达到一个 break 语句，switch 终止，并且控制流跳转到跟着 switch 语句的下一行。 不是每一个 case 需要包含一个 break。如果没有出现 break，控制流将贯穿到后面的 case 直到 break 为止。 switch 语句可以有一个可选默认 case ，它必须出现在 switch 的结束处。在执行一项任务时没有任何 case 是真，那默认 case 可被使用。在默认 case 中不需要 break。 示例 public class Test { public static void main(String args[]){ //char grade = args[0].charAt(0); char grade = 'C'; switch(grade) { case 'A' : System.out.println(\"Excellent!\"); break; case 'B' : case 'C' : System.out.println(\"Well done\"); break; case 'D' : System.out.println(\"You passed\"); case 'F' : System.out.println(\"Better try again\"); break; default : System.out.println(\"Invalid grade\"); } System.out.println(\"Your grade is \" + grade); } } 编译并运行上面使用各种命令行参数的程序。这将产生以下结果： Well done Your grade is a C Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase10/循环语句.html":{"url":"javase10/循环语句.html","title":"10.3 循环语句","keywords":"","body":"10.3 循环语句 可能存在一种情况，当我们需要执行的代码块数次，通常被称为一个循环。 Java有非常灵活的三循环机制。可以使用以下三种循环之一： while 循环 do...while 循环 for 循环 截至Java5，对增强的for循环进行了介绍。这主要是用于数组。 while 循环 while循环是一个控制结构，可以重复的特定任务次数。 语法 while循环的语法是： while(Boolean_expression) { //Statements } 在执行时，如果布尔表达式的结果为真，则循环中的动作将被执行。只要该表达式的结果为真，执行将继续下去。 在这里，while循环的关键点是循环可能不会永远运行。当表达式进行测试，结果为假，循环体将被跳过，在while循环之后的第一个语句将被执行。 示例 public class Test { public static void main(String args[]) { int x = 10; while( x 这将产生以下结果: value of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 do...while 循环 do ... while循环类似于while循环，不同的是一个do ... while循环是保证至少执行一次。 语法 do...while循环的语法是： do { //Statements } while (Boolean_expression); 请注意，布尔表达式出现在循环的结尾，所以在循环中的语句执行前一次布尔测试。 如果布尔表达式为真，控制流跳回，并且在循环中的语句再次执行。这个过程反复进行，直到布尔表达式为假。 示例 public class Test { public static void main(String args[]){ int x = 10; do{ System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); }while( x 这将产生以下结果: value of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 for 循环 for循环是一个循环控制结构，可以有效地编写需要执行的特定次数的循环。 知道一个任务要重复多少次的时候，for循环是有好处的。 语法 for循环的语法是： for(initialization; Boolean_expression; update) { //Statements } 下面是一个for循环的控制流程： 初始化步骤首先被执行，并且仅一次。这个步骤可声明和初始化任何循环控制变量。不需要把一个声明放在这里，只需要一个分号出现。 接下来，布尔表达式求值。如果是 true，则执行循环体。如果是false，则循环体不执行, 并且流程控制的跳转到经过for循环的下一个语句。 之后循环体在for循环执行时，控制流程跳转备份到更新语句。该语句允许更新任何循环控制变量。这个语句可以留空，只要一个分号出现在布尔表达式之后。 布尔表达式现在再次评估计算。如果是true，循环执行，并重复这个过程（循环体，然后更新的步骤，然后布尔表达式）。之后，布尔表达式为 false，则循环终止。 示例 public class Test { public static void main(String args[]) { for(int x = 10; x 这将产生以下结果: value of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 for 循环在 Java 中新特性 截至Java5，对增强的for循环进行了介绍。这主要是用于数组。 语法 增强的for循环的语法是： for(declaration : expression) { //Statements } 声明: 新声明块变量，这是一种与你所正在访问数组中的元素兼容的变量。该变量在for块内可被利用并且它的值作为当前的数组元素将是相同的。 表达: 这个计算结果完成需要循环数组。表达式可以是一个数组变量或返回一个数组的方法调用。 示例 public class Test { public static void main(String args[]){ int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ){ System.out.print( x ); System.out.print(\",\"); } System.out.print(\"\\n\"); String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"}; for( String name : names ) { System.out.print( name ); System.out.print(\",\"); } } } 这将产生以下结果: 10,20,30,40,50, James,Larry,Tom,Lacy, break 关键字 关键字break是用来停止整个循环的。 break关键字必须使用于任何循环中或一个switch语句中。 关键字break将停止最内层循环的执行，并开始执行在块之后的下一行代码。 语法 break语法是任何循环中一个单独的语句： break; 示例 public class Test { public static void main(String args[]) { int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ) { if( x == 30 ) { break; } System.out.print( x ); System.out.print(\"\\n\"); } } } 这将产生以下结果: 10 20 continue 关键字 continue关键字可以在任一环的控制结构使用。它使循环立即跳转到循环的下一次迭代. 在for循环中，continue关键字会导致控制流立即跳转到更新语句。 在一个while循环或do/while循环，控制流立即跳转到布尔表达式。 语法 continue 语法是任何循环中一个单独的语句： continue; 示例 public static void main(String args[]) { int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ) { if( x == 30 ) { continue; } System.out.print( x ); System.out.print(\"\\n\"); } } } 这将产生以下结果： 10 20 40 50 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase10/算n以内的质数.html":{"url":"javase10/算n以内的质数.html","title":"算n以内的质数","keywords":"","body":"算n以内的质数 代码如下： package com.neu.test; import java.util.Scanner; /** * @author liyan * 计算n以内的质数 */ public class Demo7 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"输入最大取值：\"); int num = sc.nextInt(); //编写一个方法，输出大于200的最小的质数。 for(int i=2;i Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase11/数组.html":{"url":"javase11/数组.html","title":"11. 数组","keywords":"","body":"11. 数组 数组声明 语法格式如下： 数组类型[] 数组名; 示例： int[] myIntArray; int myIntArray[]; //[]写在数组名后也可以 数组创建 语法格式一：先声明后创建 数据类型[] 数组名; 数组名 = new 数据类型[数组长度]; 示例 int[] arr; arr = new int[10]; 上面的语句做了两件事： 它创建了一个使用new int[10]的数组； 它将新创建的数组引用分配给变量arr。 语法格式二：声明的同时创建数组 数据类型[] 数组名 = new 数据类型[数组长度]; 声明数组变量arr，建立一个数组，并分配给变量数组引用可以写在一个语句中使用，如下所示： 示例 int[] arr = new int[10]; 数组会在内存中开辟一块连续的内存空间。 局部变量是没有默认值的，但是数组是有默认值的，数组实际上个对象。 数组创建之后的默认值： int类型数组，元素的默认值：0 dounle类型数组，元素默认值：0.0 char类型数组，元素默认值：\\x00 String类型数组，元素默认值：null 数组的初始化 声明数组的同时给数组赋值，叫做数组的初始化。 示例 int[] arr = {1,2,3,4,5,6,7,8,9,0} 数组arr的长度是初始化时的长度，即长度为10。 数组元素的引用 语法格式： 数组名[下标]; 数组下标从0开始，即数组的第一个元素的下标是0。 示例 int arr = {1,2,3,4,5,6}; int a = arr[0]; //把输入的第一个元素赋值给a int i= arr.length； //把数组的长度赋值给i，此时的i应该是6 把数组arr的第一个元素赋值给变量a。 数组长度的属性，length，用对象名.属性名的方式调用:arr.length 注意问题： 数组是引用数据类型 创建数组时，会开辟连续的内存空间 数组长度使用length属性获取 数组元素下标从0开始 注意数组下标越界，数组的最后一个元素是arr[a.length-1] Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase11/一维数组的应用.html":{"url":"javase11/一维数组的应用.html","title":"11.1 一维数组的应用","keywords":"","body":"11.1 一维数组的应用 package com.imooc.array; /** * * @author liyan * 一维数组的应用 */ public class ArrayDemo { public static void main(String[] args) { //声明一个int类型数组 int[] intArray; //声明一个String类型数组 String[] strArray; //数组只声明不创建，不会在内存开辟空间 //创建数组时，会在内存中开辟一块连续的空间 intArray = new int[10]; strArray = new String[5]; //声明数组的同时创建数组 float[] floatArray = new float[4]; //初始化数组 //数组的长度就是初始化时元素的个数 char[] ch = {'a','b','c','d'}; System.out.println(\"ch数组的长度为\"+ch.length); System.out.println(\"intArray数组的第2个元素为：\"+intArray[1]); System.out.println(\"strArray数组的第5个元素为：\"+strArray[4]);//所有对象数组的默认值是null System.out.println(\"floatArray数组的最后一个数组的元素为：\"+floatArray[floatArray.length-1]); //循环为int类型数组赋值 for(int i = 0;i 案例一 求数组元素的累加和： package com.imooc.array; import java.util.Scanner; public class ArrayDemo1 { public static void main(String[] args) { // 求整型数组的累加和 // 定义整型数组 int[] a = new int[5]; // 从键盘接收数据，为数组元素赋值 Scanner sc = new Scanner(System.in); for (int i = 0; i 案例二 求数组元素的最大值： package com.imooc.array; public class ArrayDemo2 { public static void main(String[] args) { // 求数组元素的最大值 int[] a = { 110, 88, 77, 32, 41, 229, 2 }; for (int i = 0; i a[i + 1]) { a[i] = a[i] + a[i + 1]; a[i + 1] = a[i] - a[i + 1]; a[i] = a[i] - a[i + 1]; } } System.out.println(\"数组元素a的最大值为：\" + a[a.length - 1]); } } package com.imooc.array; public class ArrayDemo2 { public static void main(String[] args) { // 求数组元素的最大值 int[] a = { 110, 88, 77, 32, 41, 229, 2 }; int max = a[0]; for (int i = 1; i Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase11/增强型for循环.html":{"url":"javase11/增强型for循环.html","title":"11.2 增强型for循环","keywords":"","body":"11.2 增强型for循环 又叫foreach循环 int arr = {2,4,6,8,10}; for(int i:arr){ System.out.println(i); } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase11/冒泡排序.html":{"url":"javase11/冒泡排序.html","title":"11.3 冒泡排序","keywords":"","body":"11.3 冒泡排序 对一组整数按照从小到大的顺序进行排序。 package com.imooc.array; public class ArrayDemo2 { public static void main(String[] args) { // 冒泡排序 int[] a = { 34, 53, 12, 32, 56, 17 }; System.out.print(\"排序前的数组元素为：\"); for (int i : a) { System.out.print(i+\" \"); } for (int j = 1; j a[i + 1]) { a[i] = a[i] + a[i + 1]; a[i + 1] = a[i] - a[i + 1]; a[i] = a[i] - a[i + 1]; } } } System.out.print(\"\\n排序后的数组元素为：\"); for (int i : a) { System.out.print(i + \" \"); } } } 运行结果如下： 排序前的数组元素为：34 53 12 32 56 17 排序后的数组元素为：12 17 32 34 53 56 下面是跟着imooc老师写的： package com.imooc.array; public class SortDemo { public static void main(String[] args) { // 冒泡排序 int[] a = { 34, 53, 12, 32, 56, 17 }; System.out.print(\"排序前的数组元素为：\"); for (int i : a) { System.out.print(i + \" \"); } int temp; for (int i = 0; i a[j + 1]) { temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } } System.out.print(\"\\n排序后的数组元素为：\"); for (int i : a) { System.out.print(i + \" \"); } } } 运行结果如下： 排序前的数组元素为：34 53 12 32 56 17 排序后的数组元素为：12 17 32 34 53 5 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase11/二维数组.html":{"url":"javase11/二维数组.html","title":"11.4 二维数组","keywords":"","body":"11.4 二维数组 二维数组的声明和创建 三种声明的形式： //声明int类型二维数组 int[][] intArray; //声明float类型二维数组 float floatArray[][]; //声明double类型二维数组 double[] doubleArray[]; 创建一个3行3列的int类型数组： int[][] intArray; intArray = new int[3][3];//new int[行数][列数] 声明的同时创建数组： char[][] ch = new int[3][2];//声明并创建一个3行2列的char类型数组 创建的同时只指定行数：(可以只指定行数，但是不能只指定列数) int[][] intArray = new int[3][]; int[][] intArray = new int[][3]; //error 二维数组的每一行相当于一个一维数组，通过intArray[行下标]创建每行有多少列（即每行有多少个元素） int[][] intArray = new int[3][]; intArray[0] = new int[3]; //第1行有3列 intArray[1] = new int[4]; //第2行有4列 intArray[2] = new int[5]; //第3行有5列 每行的元素个数可以不同。 二维数组的初始化 int[][] intArray = {{1,2},{3,4},{5,6}}; //声明的同时初始化 该数组即3行2列。 int[][] intArray = new int[3][]; intArray[0] = new int[] {1,2,3};//也可以每行分别初始化 intArray[1] = new int[] {4,5,6,7,8}; intArray[2] = new int[] {9,10}; int[][] intArray = new int[3][3]; int[0][0] = 1; //也可以挨个元素赋值 int[0][1] = 2; 二维数组的每行都相当于一个单独的一维数组，所以每行的元素个数可以不同 二维数组的引用 int[][] intArray = {{1,2},{3,4},{5,6}}; System.out.println(intArray[1][0]); //打印输出第2行第1个元素 运行结果： 3 循环打印数组元素： int[][] num = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9, }, { 10, 11, 12 ,13} }; for (int i = 0; i 运行结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase12/java方法.html":{"url":"javase12/java方法.html","title":"12. Java 方法","keywords":"","body":"12. Java 方法 一个 Java 方法是为了执行某个操作的一些语句的组合,为了实现特定的某种功能。举个例子来说，当你调用 System.out.println 方法时，系统实际上会执行很多语句才能在控制台上输出信息。 现在你将学习怎么创建你自己的方法，他们可以有返回值也可以没有返回值，可以有参数，也可以没有参数，重载方法要使用相同的方法名称，并在程序设计中利用抽象的方法。 创建方法 我们用下面的例子来解释方法的语法： public static int funcName(int a, int b) { // body } 在这里 public static：修饰符 int：返回值类型 funcName：方法名称（函数名称） a，b：形式参数 int a,int b：参数列表（小括号里的内容叫参数列表） 方法也包含过程或函数。 过程：他们不返回值 函数：他们返回值 方法的定义包含方法头和方法体。如下所示： modifier returnType nameOfMethod (Parameter List) { // method body } 以上的语法包括 modifier：他定义了方法的访问类型，它是可选的。 returnType：方法是可能返回一个值的（无返回值的方法这里是void，有返回值的填写返回值的数据类型）。 nameOfMethod：这是方法的名称。 Parameter List：参数列表，它是参数的次序，类型，以及参数个数的集合。这些都是可选的，当然方法也可以没有参数。 方法体：方法体定义了这个方法是用来做什么的。 示例 该方法接受两个参数n1和n2返回两者之间的最小值。 /** the snippet returns the minimum between two numbers */ public static int minFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1; return min; } 方法调用 要想使用一个方法，该方法必须要被调用。方法调用有两种方式，一种是有返回值的，一种是没有返回值的。 public class Demo{ public static void main(String[] args){ print();//静态方法中可直接调用其他静态方法 Demo d = new Demo(); d.add(2,3);//调用非静态方法需要先实例化类的对象，在通过对象名.方法名的形式调用；调用含参方法，调用时需要传入和方法列表数据类型相同的参数。 } public static void print(){ System.out.println(\"这是print方法\"); } public int add(int a,int b){ return a+b; } } 示例 下面的例子表明了怎么定义方法和怎么调用它： public class Demo{ public static void main(String[] args) { int a = 11; int b = 6; int c = minFunction(a, b); System.out.println(\"Minimum Value = \" + c); } /** 返回两个数的最小值 */ public static int minFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1; return min; } } 将会产生如下的结果 Minimum value = 6 关键字 void 关键字 void 允许我们创建一个没有返回值的方法。这里我们在下一个例子中创建一个 void 方法 methodRankPoints。这个方法是没有返回值类型的。 如下所示： public class Demo { public static void main(String[] args) { methodRankPoints(255.7); } public static void methodRankPoints(double points) { if (points >= 202.5) { System.out.println(\"Rank:A1\"); } else if (points >= 122.4) { System.out.println(\"Rank:A2\"); } else { System.out.println(\"Rank:A3\"); } } } 这将产生如下的结果： Rank:A1 通过值来传递参数 在调用函数时参数是必须被传递的。并且他们的次序必须和他们创建时的参数次序是一样的。参数可以通过值或引用来传递。 通过值传递参数意味着调用方法的参数，通过参数值来传递给参数。 示例 下面的程序给出了一个例子来显示通过值来传递参数。在调用方法后参数值是不会发生变化的。 public class Demo { public static void main(String[] args) { int a = 30; int b = 45; // 调用交换方法swapFunction(a,b) swapFunction(a, b); public static void swapFunction(int a, int b) { System.out.println(\"交换之前, a = \" + a + \" b = \" + b); // 交换a和b的值 int c = a; a = b; b = c; System.out.println(\"交换之后, a = \" + a + \" b = \" + b); } } 这将产生如下的结果： 交换之前, a = 30 b = 45 交换之后, a = 45 b = 30 方法的重载 当一个方法有两个或者更多的方法，他们的方法名一样但是参数不同时，就叫做方法的重载。（参数不同指参数个数不同或者参数类型不同，都可以方法重载） 让我们来考虑之前的找最小整型数的例子。如果我们要求寻找浮点型中最小的数时，我们就需要利用方法的重载来去创建函数名相同，但参数不一样的两个或更多的方法。 下面的例子给予解释： public class Demo{ public static void main(String[] args) { int a = 11; int b = 6; double c = 7.3; double d = 9.4; int result1 = minFunction(a, b); // 相同的方法名，不同的参数类型 double result2 = minFunction(c, d); System.out.println(\"Minimum Value = \" + result1); System.out.println(\"Minimum Value = \" + result2); } // 找int类型最小值 public static int minFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1; return min; } // 找double类型最小值 public static double minFunction(double n1, double n2) { double min; if (n1 > n2) min = n2; else min = n1; return min; } } 这将产生如下结果： Minimum Value = 6 Minimum Value = 7.3 重载方法使程序易读。在这里,两种方法名称相同但参数不同。产生整型和浮点类型的最小数作为程序运行结果。 使用命令行参数 有时你想要在程序运行之前传递参数。这可以通过给 main 函数传递命令行参数来实现。 在命令行中，当要执行程序文件时，一个命令行参数是紧接着文件名字后面的出现的。要接受命令行参数在 Java 程序中是十分容易的。它们传递到 main 函数字符数组内。 示例 下面的例子展示了将所有命令行参数输出的程序： public class CommandLine { public static void main(String args[]){ for(int i=0; i 通过以下方法来执行该程序： java CommandLine this is a command line 200 -100 这将产生如下的结果： args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]: 200 args[6]: -100 构造函数 这是一个简单的使用构造函数的例子: // 一个简单的构造函数 class MyClass { int x; //方法名与类型相同 MyClass() { x = 10; } } 你可以通过以下方法来调用构造函数来实例化一个对象： public class ConsDemo { public static void main(String args[]) { MyClass t1 = new MyClass(); MyClass t2 = new MyClass(); System.out.println(t1.x + \" \" + t2.x); } } 通常，你将需要用构造函数来接受一个或多个参数。参数的传递和以上介绍的普通方法的参数传递是一样的，就是在构造函数的名字后面列出参数列表。 示例 这是一个简单的使用构造函数的例子: // A simple constructor. class MyClass { int x; // Following is the constructor MyClass(int i ) { x = i; } } 你可以通过以下方法来调用构造函数来实例化一个对象： public class ConsDemo { public static void main(String args[]) { MyClass t1 = new MyClass( 10 ); MyClass t2 = new MyClass( 20 ); System.out.println(t1.x + \" \" + t2.x); } } 这将产生如下的结果： 10 20 可变长参数 JDK1.5 能够允许你传递可变长的同一类型的参数。用如下方法进行声明： typeName... parameterName 方法声明时，你要在省略号前明确参数类型，并且只能有一个可变长参数，并且可变长参数必须是所有参数的最后一个。 示例 public class VarargsDemo { public static void main(String args[]) { // Call method with variable args printMax(34, 3, 3, 2, 56.5); printMax(new double[]{1, 2, 3}); } public static void printMax( double... numbers) { if (numbers.length == 0) { System.out.println(\"No argument passed\"); return; } double result = numbers[0]; for (int i = 1; i result) result = numbers[i]; System.out.println(\"The max value is \" + result); } } 这将产生如下的结果： The max value is 56.5 The max value is 3.0 finalize() 方法 你可以定义一个方法，仅在被垃圾收集器销毁之前才会被调用。这个方法叫做 finalize() 方法，它也可以用来确保一个对象被干净清除了。 举个例子，你也许用 finalize() 来确保被一个对象打开的文件已经关闭了。 为了给类添加一个终结器，你只需定义 finalize() 方法。Java要回收该类的一个对象时，会调用该方法。 在 finalize() 方法中，你将指定一些必须在对象销毁之前要做的行为。 finalize()方法一般是如下形似： protected void finalize( ) { // finalization code here } 这里，关键字 protected 是为了保证在类外的代码不能访问 finalize() 方法。 这意味着你不能知道 finalize() 什么时候执行。举个例子，如果你的程序在垃圾收集器发生之前就结束了，finalize() 方法将不会被执行。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java面向对象.html":{"url":"javase13/java面向对象.html","title":"13. Java 面向对象","keywords":"","body":"13. Java 面向对象 面向对象编程的四个特点：封装、继承、多态、抽象 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java构造方法.html":{"url":"javase13/java构造方法.html","title":"13.1 Java 构造方法","keywords":"","body":"13.1 Java 构造方法 构造方法又叫做构造器，英文名是：constructor，特点是方法名与类名相同且不具备返回值。 构造方法可以无参数列表，也可以有参数列表。 定义格式： public 方法名(){ } 示例： package com.neu.demo; public class Demo01 { // 构造方法与类同名 public Demo01() { System.out.println(\"我是不带参数的构造方法！\"); } // main方法 public static void main(String[] args) { Demo01 d01 = new Demo01(); } } 运行结果： 我是不带参数的构造方法！ 构造方法简单概述： 构造方法在实例化时被调用，即实例化类对象时，通过new关键字调用构造方法来创建对象实例。 如果一个类中没有定义构造方法，那么在实例化该类对象时，Java会默认调用该类不带参数的构造方法。 构造方法也是方法，所以它也具有重载形式，根据参数列表的不同，一个类中可以定义多个构造方法。 如果一个类中只定义了带参数的构造方法，那么在实例化该类对象时，只能new它的带参构造，而不能new它的不带参数的构造方法。 如果构造方式使用private访问修饰符修饰，那么在其他类中不能通过new该类的构造方法创建对象实例。（后面会提到单例模式，涉及了这种形式） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java封装.html":{"url":"javase13/java封装.html","title":"13.2 Java 封装","keywords":"","body":"13.1 Java 封装 封装的概念： 封装是面向对象编程的基本思想之一，其思想是： 将类的某些信息隐藏在类内部，不允许外部程序直接访问； 通过该类提供的方法来实现对隐藏信息的操作和访问； 隐藏对象的信息； 留出访问的接口。 实现步骤： 修改属性的可见性，访问修饰符：private 创建getter/setter方法，设为public用于属性的读写 可以根据需求，在getter/setter方法中加入属性的逻辑控制，对属性值的合法性进行判断或一些其他的操作。 示例： 定义一个宠物猫类Cat，里面包含了宠物猫类的属性以及方法 package com.imooc.animal; /** * 宠物猫类 * @author liyan * */ public class Cat { // 成员属性：昵称、年龄、体重、品种 String name; // 昵称，默认值为null int mouth; // 年龄，默认值为0 double weight; // 体重，默认值为0.0 String species; // 品种 public Cat() { // 构造方法 } // 成员方法：跑动、吃东西 // 跑动的方法 public void run() { eat(); System.out.println(\"小猫快跑\"); } // 吃东西的方法 public void eat() { System.out.println(\"吃东西\"); } } 再定义一个宠物猫的测试类CatTest，用于测试： package com.imooc.animal; //单一指责原则 public class CatTest { public static void main(String[] args) { //对象实例化 Cat oneCat = new Cat(); //测试 oneCat.name = \"凡凡\"; oneCat.mouth = 3; oneCat.weight = 1200; oneCat.species = \"中华田园猫\"; System.out.println(\"昵称：\"+oneCat.name); System.out.println(\"年龄：\"+oneCat.mouth); System.out.println(\"体重：\"+oneCat.weight); System.out.println(\"品种：\"+oneCat.species); } } 运行结果： 昵称：凡凡 年龄：3 体重：1200.0 品种：中华田园猫 测试类成通过实例化Cat类对象，通过对象调用属性名的方式为其赋值，再打印输出对象的昵称、年龄、体重、品种。 这里就会存在一个逻辑隐患，如果我们把猫的年龄赋值成\"-3\",程序依然会正常运行，但是确不符合实际逻辑。 所以，我们可以通过封装的方法，把传入的数据做合法性校验这一功能封装成一个方法。 封装流程如下： step1：修改Cat类属性的可见性，添加访问修饰符private，限定这些属性只能在类内被使用。 （private是私有的，被修饰的属性只能在该类里面使用，不能被其它类调用。） // 封装step1：修改属性的可见性---private，限定属性只能在类内使用 private String name; // 昵称，默认值为null private int mouth; // 年龄，默认值为0 private double weight; // 体重，默认值为0.0 private String species; // 品种 step2：创建get/set方法 step3：可以在set()方法中添加属性的限定,校验传入的值的合法性，合法则为属性赋值；通过 调用get()方法获取属性的值，此时就完成了属性封装。 // 封装setp2：创建get/set方法 public void setMouth(int mouth) { // 封装step3：在set()中添加属性的限定,校验传入的值的合法性，合法则为属性赋值 if (mouth 完整代码如下： 宠物猫类Cat package com.imooc.animal; /** * 宠物猫类 * * @author liyan * */ public class Cat { // 成员属性：昵称、年龄、体重、品种 // 封装step1：修改属性的可见性---private，限定属性只能在类内使用 private String name; // 昵称，默认值为null private int mouth; // 年龄，默认值为0 private double weight; // 体重，默认值为0.0 private String species; // 品种 // 构造方法 public Cat() { } // 封装setp2：创建get/set方法 public void setName(String name) { this.name = name; } public String getName() { return name; } // 封装step3：在set中添加属性的限定 public void setMouth(int mouth) { if (mouth 为所有的私有属性设置get/set方法。 测试类CatTest package com.imooc.animal; //单一指责原则 public class CatTest { public static void main(String[] args) { //对象实例化 Cat oneCat = new Cat(); //测试 oneCat.setName(\"凡凡\"); oneCat.setMouth(3); oneCat.setWeight(1200); oneCat.setSpecies(\"中华田园猫\"); System.out.println(\"昵称：\"+oneCat.getName()); System.out.println(\"年龄：\"+oneCat.getMouth()); System.out.println(\"体重：\"+oneCat.getWeight()); System.out.println(\"品种：\"+oneCat.getSpecies()); } } 运行结果： 昵称：凡凡 年龄：3 体重：1200.0 品种：中华田园猫 如果给setName传入-3，则会打印提示数据不合法的信息。 oneCat.setMouth(-3); 运行结果： 设定的年龄需大于0！ 封装的意义还需要在后期写代码的时候慢慢体会~~~ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/static关键字.html":{"url":"javase13/static关键字.html","title":"13.3 static关键字","keywords":"","body":"13.3 static关键字 static修饰成员变量： static修饰成员变量（也叫成员属性），则该属性变为类属性（类成员）： 类对象共享 类加载时产生，销毁时释放，生命周期长 示例： public class Cat { // 成员属性：昵称、年龄、体重、品种 // 封装step1：修改属性的可见性---private，限定属性只能在类内使用 private String name; // 昵称，默认值为null private int mouth; // 年龄，默认值为0 private double weight; // 体重，默认值为0.0 private String species; // 品种 //此时price没有static修饰符 public int price;// 价格 /********此处省略下面代码********/ } package com.imooc.animal; public class Test { public static void main(String[] args) { Cat oneCat = new Cat(); oneCat.setName(\"花花\"); oneCat.price = 2000; Cat twoCat = new Cat(); twoCat.setName(\"凡凡\"); twoCat.price = 150; System.out.println(oneCat.getName() + \"的售价为：\" + oneCat.price); System.out.println(twoCat.getName() + \"的售价为：\" + twoCat.price); } } 两个对象分别赋值后对price分别打印： 花花的售价为：2000 凡凡的售价为：150 使用static修饰price： // static:静态 静态成员、类成员 public static int price;// 价格 打印输出结果为： 花花的售价为：150 凡凡的售价为：150 类属性，共享同一个内存空间。 类属性通过对象名.属性名的方式调用时，IDE工具会有警告，（用静态的方式去调用） 这也是类属性的另一种体现，所以Java推荐通过类名.属性名的方式调用，静态的调用方式。 此时，工具的警告消失。 所以，静态成员属性的调用方式有： 类名.属性名 对象名.属性名 this.属性名 注意：static不能修饰方法内的局部变量，也不能用来修饰class。 static修饰方法： static修饰方法，则该方式变为静态方法， 同类属性一样，静态方法可以使用对象名.方法名()的方式调用，也可以使用类名.方法名()的方式调用。 静态方法的调用方式有： 对象名.方法名() 类名.方法名() 同一个类的其他方法可以通过 方法名() 直接调用 //静态方法中不能直接调用同一个类中的非静态成员，只能直接调用同一个类中的静态成员 public static void run() { Cat temp = new Cat(); temp.eat(); this.name = \"小胖\"; //error name = \"小胖\"; //error price = 1500; //ok 因为price是静态成员 System.out.println(\"小猫快跑\"); } 这里要注意：在静态方法中不能直接调用同一个类中的非静态成员（非静态的属性或方法），只能直接调用同一个类中的静态成员（静态属性或静态方法），或者通过对象名.属性名、对象名.方法名()的形式调用；静态方法中也不能使用this。 代码块 普通代码块：（写在方法里） public void run(String name) { {// 普通代码块 System.out.println(\"我是普通代码块1\"); } System.out.println(name + \"快跑\"); { System.out.println(\"我是普通代码块2\"); } } 按顺序从上到下执行： 我是普通代码块1 花花快跑 我是普通代码块2 构造代码块：（写在类里） 创建对象是调用，优先于构造方法执行 {// 构造代码块 System.out.println(\"我是构造代码块1\"); } // 构造方法 public Cat() { System.out.println(\"我是无参构造方法，我是宠物猫~\"); } 和与构造方法的相对位置无关： 我是构造代码块1 我是无参构造方法，我是宠物猫~ 即便写在构造方法下面，也会优先调用。 {// 构造代码块1 System.out.println(\"我是构造代码块1\"); } // 构造方法 public Cat() { System.out.println(\"我是无参构造方法，我是宠物猫~\"); } {// 构造代码块2 System.out.println(\"我是构造代码块2\"); } 运行结果： 我是构造代码块1 我是构造代码块2 我是无参构造方法，我是宠物猫~ 多个构造代码块也会从上向下顺序执行。 静态代码块 当构造代码块被static修饰，则会升级为静态代码块 类加载时被调用，优先于构造代码块 {// 构造代码块1 System.out.println(\"我是构造代码块1\"); } // 构造方法 public Cat() { System.out.println(\"我是无参构造方法，我是宠物猫~\"); } static {// 构造代码块2 --> 静态代码块 System.out.println(\"我是构造代码块2，变成静态代码块\"); } 运行结果： 我是构造代码块2，变成静态代码块 我是构造代码块1 我是无参构造方法，我是宠物猫~ 多个静态代码块也会从上向下顺序执行。 静态代码块只有在类加载时执行一次 构造代码块实例化一次执行一次 构造方法也是实例化一次执行一次 在静态代码块中不能直接调用同一个类中的非静态成员（非静态的属性或方法），只能直接调用同一个类中的静态成员（静态属性或静态方法），或者通过对象名.属性名、对象名.方法名()的形式调用；静态方法中也不能使用this。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java继承.html":{"url":"javase13/java继承.html","title":"13.4 Java 继承","keywords":"","body":"13.2 Java 继承 概念： 继承是面向对象思想的基本概念之一，通过继承的使用，可以很好地提高代码的复用性。 继承的关键字：extends 继承特点： 通过extends关键字，可以继承其他类的属性和方法，我们把被继承的类成为父类，继承其他类的类成为子类。 Java中的继承属于单继承，即只能同时继承一个类，但是一个类可以有多个子类 public class Cat extends Animal{} 所有的Java类都有一个统一的父类，即Object，所有的Java类都继承自Object类或其子类。 示例： 创建两个类，来解释一下继承的基本用法： 定义一个Animal类： public class Animal{ String name;//昵称 String sex;//性别 String age;//年龄 public void eat(){ System.out.println(\"吃东西\"); } } 定义一个Cat类： public class Cat extends Animal {//通过extends关键字继承Animal类 @Override public void eat() { System.out.println(name + \"吃东西\"); } public static void main(String[] args) { Cat cat = new Cat(); cat.name = \"花花\"; cat.sex = \"小母猫\"; cat.age = 1; System.out.println(\"昵称：\" + cat.name + \"，性别：\" + cat.sex + \"，年龄：\" + cat.age); cat.eat(); } } 运行结果： 昵称：花花，性别：小母猫，年龄：1 花花吃东西 继承的概述： 上面定义了两个类，Animal类和Cat类， Animal类中定义了三个成员属性，和一个eat方法， Cat类中，通过extends关键继承Animal类，继承的特点是可以继承父类的属性和方法。 所以，在Cat类中我们不再需要定义name、age、sex等属性以及eat()方法。 通过实例化Cat对象，可以正常调用继承自父类Animal的三个属性和重写eat()方法。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/final关键字.html":{"url":"javase13/final关键字.html","title":"13.6 Java final关键字","keywords":"","body":"13.6 Java final关键字 final关键字修饰变量时，该变量不能再被赋值。 final关键字修饰方法，该方法不能被子类重写。 final关键字修饰类，该类不能被继承。 final关键字的知识点 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值。 本地变量必须在声明时赋值。 因为没有初始化的过程 在匿名类中所有变量都必须是final变量。 final方法不能被重写, final类不能被继承 接口中声明的所有变量本身是final的。类似于匿名类 final和abstract这两个关键字是反相关的，final类就不可能是abstract的。 final方法在编译阶段绑定，称为静态绑定(static binding)。 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。 final方法的好处: 提高了性能，JVM在常量池中会缓存final变量 final变量在多线程中并发安全，无需额外的同步开销 final方法是静态编译的，提高了调用速度 final类创建的对象是只可读的，在多线程可以安全共享 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java单例模式.html":{"url":"javase13/java单例模式.html","title":"13.7 Java 单例模式","keywords":"","body":"13.4 Java 单例模式 目的：使得类的一个对象成为该类系统中的唯一示例。 定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供。 要点： 某个类只能有一个实例 必须自行创建实例 必须自行向整个系统提供这个实例 实现： 只提供私有(private)的构造方法 含有一个该类的静态私有对象（私有化的静态的实例对象） 提供一个静态的公有方法用于创建、获取静态私有对象 代码实现方案： ​ 饿汉式：对象创建过程中实例化 ​ 懒汉式：静态公有方法中实例化 示例（饿汉式）： package com.imooc.singleton; /** * 单例模式：饿汉式 空间换时间 * @author liyan * */ public class SingletonOne { // 1. 创建静态构造方法 private SingletonOne() { } // 2. 创建该类型的私有静态实例（饿汉式：创建静态私有对象时直接实例化） private static SingletonOne instance = new SingletonOne(); // 3. 创建公有静态方法，返回静态实例对象 public static SingletonOne getInstance() { return instance; } } 在Test类中验证一下： package com.imooc.test; import com.imooc.singleton.SingletonOne; public class Test { public static void main(String[] args) { SingletonOne one = SingletonOne.getInstance(); SingletonOne two = SingletonOne.getInstance(); System.out.println(one); System.out.println(two); } } 输出的结果： com.imooc.singleton.SingletonOne@7852e922 com.imooc.singleton.SingletonOne@7852e922 结论：one和two指向相同的引用。 示例（懒汉式）： package com.imooc.singleton; /** * 单例模式：懒汉式 时间换空间 * @author liyan * */ public class SingletonTwo { // 1. 私有化构造方法 private SingletonTwo() { } // 2. 创建该类的私有化静态对象 private static SingletonTwo instance = null; // 3. 创建该类公共的静态方法提供实例化对象 public static SingletonTwo getInstance() { if (instance == null) { instance = new SingletonTwo(); } return instance; } } 在Test类中验证一下： package com.imooc.test; import com.imooc.singleton.SingletonTwo; public class Test { public static void main(String[] args) { SingletonTwo one = SingletonTwo.getInstance(); SingletonTwo two = SingletonTwo.getInstance(); System.out.println(one); System.out.println(two); } } 输出结果： com.imooc.singleton.SingletonTwo@4e25154f com.imooc.singleton.SingletonTwo@4e25154f 总结： 饿汉式：空间换时间，类加载时就创建并实例化对象，线程安全； 懒汉式：时间换空间，第一次调用get方法时才实例化对象，有线程风险。 单例模式优点： 在内存中只有一个对象，节省内存空间； 避免频繁地创建销毁对象，提高性能； 避免对共享资源的多重占用。 单例模式缺点： 扩展比较困难； 如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。 单例模式使用场景： 创建对象时占用资源过多，但同时又需要用到该类对象 对系统内资源要求统一读写，如读写配置信息 对多个实例存在可能引起程序逻辑错误，如号码生成器 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java多态.html":{"url":"javase13/java多态.html","title":"13.8 Java 多态","keywords":"","body":"13.5 Java 多态 多态，意味着允许不同类的对象对同一消息做出不同的响应。 编译时多态（设计时多态）：方法重载； 运行时多态：程序运行时动态决定调用哪个方法，Java中的多态一般指运行时多态。 必要条件： 满足继承关系 父类引用指向子类实例 示例： 动物类Animal package com.imooc.animal; public class Animal { // 属性：昵称、年龄 private String name; private int mouth; public Animal() { } public Animal(String name, int mouth) { setName(name); setMouth(mouth); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMouth() { return mouth; } public void setMouth(int mouth) { this.mouth = mouth; } // 方法：吃东西 public void eat() { System.out.println(\"动物都有吃东西的能力\"); } } Cat类：继承Animal package com.imooc.animal; public class Cat extends Animal { // 属性：体重weight private double weight; public Cat() { } public Cat(String name, int mouth, double weight) { super(name, mouth); this.weight = weight; } public double getWeight() { return weight; } public void setWeight(double weight) { this.weight = weight; } // 方法：跑动 public void run() { System.out.println(\"小猫快乐地奔跑\"); } // 重写父类方法：eat() @Override public void eat() { System.out.println(\"猫吃鱼~~~\"); } } Dog类：继承Animal package com.imooc.animal; public class Dog extends Animal { // 属性：性别sex private String sex; public Dog() { } public Dog(String name, int mouth, String sex) { super(name, mouth); this.sex = sex; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } // 方法：睡觉 public void sleep() { System.out.println(\"小狗爱睡觉\"); } // 重写父类方法：eat() @Override public void eat() { System.out.println(\"狗吃肉~~~\"); } } Test类： package com.imooc.test; import com.imooc.animal.Animal; import com.imooc.animal.Cat; import com.imooc.animal.Dog; public class Test { public static void main(String[] args) { Animal one = new Animal();// 1 // 向上转型：是把一个子类实例转型成为一个父类对象（隐式转型、自动转型）-->也就是父类引用指向子类实例 Animal two = new Cat();// 2 Animal three = new Dog();// 3 one.eat(); two.eat(); three.eat(); // 向下转型：把父类对象强制转换成子类对象（强制类型转换）-->子类引用指向父类对象 Cat temp = (Cat) two; temp.eat(); temp.run(); temp.setMouth(1); System.out.println(\"猫的年龄：\" + temp.getMouth()); } } 向上转型：是把一个子类实例转型成为一个父类对象（隐式转型、自动转型）-->也就是父类引用指向子类实例. 父类对象指向子类实例，可调用父类方法、子类重写父类的方法、和父类派生的方法，无法调用子类自己的方法的。 向下转型：把父类对象强制转换成子类对象（强制类型转换）-->子类引用指向父类对象 Cat temp = (Cat) two; 这里的对象two是Animal类型指向的Cat实例，我们可以强制转换成Cat，相当于把对象two还原成了Cat类的对象，强转后的temp对象可以使用父类方法、子类重写父类的方法、和父类派生下来的方法。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/instanceof关键字.html":{"url":"javase13/instanceof关键字.html","title":"13.9 instanceof关键字","keywords":"","body":"13.8 instanceof关键字 对象 ---instanceof--->类 判断左边对象是否属于右边类的实例。 示例： (\\代码上文请参照Java 多态)* package com.imooc.test; import com.imooc.animal.Animal; import com.imooc.animal.Cat; import com.imooc.animal.Dog; public class Test { public static void main(String[] args) { Animal one = new Animal();// 1 // 向上转型：是把一个子类实例转型成为一个父类对象（隐式转型、自动转型）-->也就是父类引用指向子类实例 Animal two = new Cat();// 2 Animal three = new Dog();// 3 one.eat(); two.eat(); three.eat(); System.out.println(\"==============================\"); // 向下转型：把父类对象强制转换成子类对象（强制类型转换）-->子类引用指向父类对象 // instanceof运算符：返回值：布尔类型 if (two instanceof Cat) { Cat temp = (Cat) two; temp.eat(); temp.run(); temp.setMouth(1); System.out.println(\"猫的年龄：\" + temp.getMouth()); System.out.println(\"two可以转换为Cat类型\"); } if (two instanceof Dog) { Dog temp = (Dog) two; temp.eat(); temp.sleep(); temp.setMouth(1); System.out.println(\"狗的年龄：\" + temp.getMouth()); System.out.println(\"two可以转换为Dog类型\"); } } } 运行结果： 动物都有吃东西的能力 猫吃鱼~~~ 狗爱吃肉~~~ ============================== 猫吃鱼~~~ 小猫快乐地奔跑 猫的年龄：1 two可以转换为Cat类型 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java抽象类.html":{"url":"javase13/java抽象类.html","title":"13.10 Java 抽象类","keywords":"","body":"13.9 Java 抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 abstract 关键字修饰的类叫抽象类； abstract 关键字修饰的方法叫抽象方法。 一个抽象类可以没有抽象方法，但是有抽象方法的类一定是抽象类。 示例： 抽象类的定义： public abstract class Demo01 { } 抽象方法： public abstract void test_Abstract(String a);//参数列表可有可无 子类必须重写父类的抽象方法，或者把自己也变成抽象类。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java接口.html":{"url":"javase13/java接口.html","title":"13.11 Java 接口","keywords":"","body":"13.10 Java 接口 接口的特点： 接口的概念和类差不多，但是接口中的方法都是抽象方法，即没有方法体。 接口中一般不定义属性，如果在接口中定义属性，则该属性必须是公共的、静态的、最终的 接口中的方法都是抽象方法，所以实现该接口的类必须重写接口中所有的抽象方法。 示例： public interface Demo01 { public static final int a = 2; int b = 0;// 不加修饰符时，默认为public static fianl } 接口中的方法都是抽象方法，实现接口的类必须实现这些抽象方法。 public interface Demo01 { public static final int a = 2; public void test();//抽象方法 } Demo01接口: package com.neu.interface_demo; /** * @author liyan * Demo01接口 */ public interface Demo01 { public static final int a = 2; int b = 0;// 抽象方法的成员属性默认是final public void test();// 抽象方法 } Demo01_Implements类 implements Demo01接口: package com.neu.interface_demo; /** * @author liyan * Demo01_Implements类 implements Demo01接口 */ public class Demo01_Implements implements Demo01 { @Override public void test() { System.out.println(\"重写接口中的方法\"); } public static void main(String[] args) { // 接口对象指向实现类的实例，向上转型 Demo01 d01 = new Demo01_Implements(); System.out.println(\"接口中属性a的值：\" + d01.a); d01.test(); // 实例化Demo01_Implements对象 Demo01_Implements d02 = new Demo01_Implements(); System.out.println(\"接口中属性b的值：\" + d02.b); } } 默认方法&静态方法（JDK1.8以后） 默认方法和静态方法带方法体，实现接口的类可以不去实现它。 示例： public interface IDemo{ void method1(); void method2(); default void method3(){ System.out.println(\"我是默认方法\"); } static void method4(){ System.out.println(\"我是静态方法\"); } } 默认方法和静态方法可以带方法体。 在实现类重写接口中的默认方法时，调用接口中的默认方法： public class Demo implements IDemo{ @override public void method3(){ IDemo.super.method();//要以接口名.super.方法名()的形式调用接口的默认方法 } } 在实现类中无法重写接口中的静态方法，可以通过接口名.方法名的方式调用。 接口的继承 接口之间也是可以继承的，并且接口可以多继承。 示例： public interface ISon extends IFather1,IFather2{ } 一个类如果要实现ISon，则它需要实现ISon继承的所有抽象方法。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java内部类.html":{"url":"javase13/java内部类.html","title":"13.12 Java 内部类","keywords":"","body":"13.12 Java 内部类 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/static关键字和final关键字小结.html":{"url":"javase13/static关键字和final关键字小结.html","title":"13.13 static关键字和final关键字小结","keywords":"","body":"2. static关键字和final关键字小结 这里主要说明一下static关键字和final关键字修饰方法在继承时的特点： 父类： package demo; /** * 父类，定义了三个方法：普通的，static修饰的，final修饰的 */ public class Demo { int a; int b; //普通的方法 public void method(){ System.out.println(\"我是父类的方法\"); } //静态修饰的方法 public static void method_Static(){ System.out.println(\"我是父类的static修饰的方法\"); } //final修饰的方法 public final void method_Final(){ System.out.println(\"我是父类的final修饰的方法\"); } } 子类： package demo; public class DemoSub extends Demo { //static修饰的方法可以被继承，无法被重写（静态方法无法通过'对象名.方法名'的形式调用，只能通过'类名.方法名'调用） //final修饰的方法可以被继承，无法被重写（子类对象可以调用父类方法） //重写父类的普通方法 @Override public void method() { super.method(); } public static void main(String[] args) { DemoSub ds = new DemoSub(); ds.method();//子类对象调用父类的普通方法 ds.method_Final();//子类对象调用父类的final方法 DemoSub.method_Static();//子类类名.方法名 } } 结论： static修饰的方法可以被继承，无法被重写，子类对象无法调用父类的静态方法，只能通过父类类名.方法名的方式调用方法。 final修饰的方法可以被继承，无法被重写（子类对象可以调用父类的final修饰的方法） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase13/java中的访问修饰符.html":{"url":"javase13/java中的访问修饰符.html","title":"13.14 Java中的访问修饰符","keywords":"","body":"13.14 Java中的访问修饰符 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase14/java异常.html":{"url":"javase14/java异常.html","title":"14. Java 异常","keywords":"","body":"Java 异常 什么是异常？ 异常就是一种程序上的错误； 错误一般有编译时错误，和运行时错误。 异常分类： Throwable是异常处理的根类，它又分两个直接子类Error和Exception。 Error是程序无法处理的错误，表示运行应用程序中较严重的问题。 VirtualMachineError 虚拟机错误 OutOfMemoryError 内存溢出 ThreadDeath 线程锁死 ... ...(这些错误是不可查的，它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况) Exception是程序本身可以处理的异常。异常处理通常指针对这种类型的处理。 Checked Exception 检查异常（编译器要求必须处理这些异常） 除了RuntimeException以及它的子类，其余的异常都算Checked Exception IOException IO异常 SQLException SQL异常 Unchecked Exception 非检查异常（编译器不要求强制处理的异常） RuntimeException 运行时异常（以及它的子类） 例如： NullPointerException 空指针异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArithmeticException 算术异常 ClassCastException 类型转换异常 异常处理 在Java应用程序中，异常处理机制为： 抛出异常 捕获异常 异常处理关键字：try,catch,finally,throw,throws 捕获异常： try -> 执行可能产生异常的代码 catch -> 捕获异常 finally -> 无论是否发生异常代码总能执行 声明异常： throws -> 声明可能抛出的异常 抛出异常： throw ->手动抛出异常 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase14/try-catch-finally.html":{"url":"javase14/try-catch-finally.html","title":"14.1 try-catch-finally","keywords":"","body":"14.1 try-catch-finally 捕获异常： try -> 执行可能产生异常的代码 catch -> 捕获异常 finally -> 无论是否发生异常代码总能执行 注意：try块后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 示例： package com.imooc.test; import java.util.Scanner; public class TryDemo1 { public static void main(String[] args) { // 定义两个整数，接收用户键盘输入，输出两数之商 System.out.println(\">>>运算开始\"); try { System.out.print(\"输入第一个整数：\"); int a = new Scanner(System.in).nextInt(); System.out.print(\"输入第二个整数：\"); int b = new Scanner(System.in).nextInt(); System.out.println(\"a和b的商是：\" + (a / b)); } catch (Exception e) { System.out.println(\"程序出现异常，捕获到：\" + e); }finally{ System.out.println(\">>>运算结束\"); } } } 运行： >>>运算开始 输入第一个整数：12 输入第二个整数：0 程序出现异常，捕获到：java.lang.ArithmeticException: / by zero >>>运算结束 try块中放入可能会出现异常的代码，如果try中的代码在运行时出现异常，则会有catch块捕获，catch中声明了一个Exception 对象e，由e来捕获这个异常。 finally块，无论catch块是否捕获到异常，finally中的代码都会执行。 使用多重catch块结构处理异常 根据异常的类型不同使用多重catch块，但是不能有两个相同异常的catch块。 package com.imooc.test; import java.util.InputMismatchException; import java.util.Scanner; public class TryDemo1 { public static void main(String[] args) { // 定义两个整数，接收用户键盘输入，输出两数之商 System.out.println(\">>>运算开始\"); try { System.out.print(\"输入第一个整数：\"); int a = new Scanner(System.in).nextInt(); System.out.print(\"输入第二个整数：\"); int b = new Scanner(System.in).nextInt(); System.out.println(\"a和b的商是：\" + (a / b)); } //捕获运算异常 catch (ArithmeticException e) { System.out.println(\"出错啦！除数不能为0\"); } //捕获输入格式错误异常 catch (InputMismatchException e) { System.out.println(\"出错啦！输入必须是整数\"); } //最后可以通过父类Exception捕获其它异常 catch(Exception e){ System.out.println(\"出错啦，捕获到：\" + e); } finally { System.out.println(\">>>运算结束\"); } } } 运行： >>>运算开始 输入第一个整数：21 输入第二个整数：0 出错啦！除数不能为0 >>>运算结束 >>>运算开始 输入第一个整数：a 出错啦！输入必须是整数 >>>运算结束 如何在捕获异常后不让程序继续运行finally块中的语句？ 可以在catch块中加入System.exit(1)语句，终止当前Java虚拟机，则程序不会继续往下执行。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase14/throws抛出异常.html":{"url":"javase14/throws抛出异常.html","title":"14.2 throws 抛出异常","keywords":"","body":"14.2 throws 抛出异常 可以通过throws声明将要抛出何种类型的异常，通过throw将产生的异常抛出。 如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。 throws语句用在方法定义时声明该方法要抛出的异常类型。 public void method() throws Exception1,Exception2,...Exception n{ //可能产生异常的代码 } 当方法抛出异常列表中的异常时，方法将不会对这些类型及其子类类型的异常作处理，而是抛向调用该方法的方法，由他去处理。 示例： package com.imooc.test; import java.util.InputMismatchException; import java.util.Scanner; public class TryDemo3 { public static void main(String[] args) { // 当通过throws抛出异常时，针对可能出现的多种异常情况，解决方案： // 方案一：由方法调用者捕获test()方法可能抛出的异常，使用try-catch捕获可能出现的异常 try { int result = test1(); System.out.println(\"结果为：\" + result); } catch (ArithmeticException e) { System.out.println(\"除数不能为0\"); } catch (InputMismatchException e) { System.out.println(\"输入格式不正确\"); } catch (Exception e) {// 可以在最后加上捕获Exception类的异常，捕获漏网之鱼；如果调用的方法直接throws // Exception类异常，则必须有捕获Exception类异常的catch System.out.println(\"程序运行时遇到错误\"); } } // 方法：计算输入的两个数的商，抛出可能出现的异常（算术异常、输入格式异常） public static int test() throws ArithmeticException, InputMismatchException { System.out.println(\">>>运算开始\"); System.out.print(\"请输入第一个整数：\"); int a = new Scanner(System.in).nextInt(); System.out.print(\"请输入第二个整数\"); int b = new Scanner(System.in).nextInt(); return a / b; } // 如果不确定可能会遇到什么异常，可以直接抛出父类Exception类的异常 // 如果方法直接抛出Exception类异常，则调用该方法时必须有捕获Exception类异常的catch public static int test1() throws Exception { System.out.println(\">>>运算开始\"); System.out.print(\"请输入第一个整数：\"); int a = new Scanner(System.in).nextInt(); System.out.print(\"请输入第二个整数\"); int b = new Scanner(System.in).nextInt(); return a / b; } } 在可能抛出异常的方法使用throws关键字抛出可能出现的异常，或者直接抛出父类Exception类异常： public static int test() throws ArithmeticException, InputMismatchException { //可能抛出异常的代码 } public static int test1() throws Exception { //可能抛出异常的代码 } 在调用该方法时再去捕获处理这些异常。 当我们直接调用test()方法时，编译器不会提示我们去try-catch该方法可能抛出异常；但当我们调用test1()时，编译器会编译报错，提醒我们去try-catch该方法可能抛出的异常，这是为什么呢？ 原因是：test()中抛出的ArithmeticException, InputMismatchException属于UncheckedException异常，编译器不会要求我们必须处理这种异常；而test1()直接抛出Exception，Exception类属于父类，包含CheckedException，编译器会要求我们必须处理这些异常。 我们可以通过给方法添加文档注释的方法，提醒调用者，该方法可能会抛出异常： 当调用该方法时，会弹出提示框： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase14/throw抛出异常.html":{"url":"javase14/throw抛出异常.html","title":"14.3 throw 抛出异常","keywords":"","body":"14.3 throw 抛出异常 throw用来抛出一个异常 例如：throw new IOException(); throw抛出的只能够是可抛出类Throwable或者子类的实例对象。（Throwable是Error和Exception的父类） 示例： package com.imooc.test; import java.util.Scanner; public class TryDemo4 { public static void main(String[] args) { } // 描述酒店的入住规则：限定年龄，18岁以下，80岁以上的住客必须由亲友陪同 public static void testAge() { System.out.print(\"请输入年龄：\"); int age = new Scanner(System.in).nextInt(); if (age 80) {// 小贴士：这里使用的是短路||，当前面条件为true时，后面则不再判断 //这里手动抛出一个异常，此时编译器会报错要求我们处理这个异常 throw new Exception(\"18岁以下，80岁以上的住客必须由亲友陪同\"); } else { System.out.println(\"欢迎入住本酒店\"); } } } if语句中，手动抛出throw异常时，编译器会报错，提示有未处理的异常，我们可以通过两个方案解决： 方案一（直接把throw语句放到try-catch中，自己处理）： 一般我们会把可能出现异常的代码都放到try块中： 方案二（通过在方法声明处throws该异常，由方法调用者去处理该异常）： package com.imooc.test; import java.util.Scanner; public class TryDemo4 { public static void main(String[] args) { // 调用方案二：由方法调用者通过try-catch捕获处理该异常，也可以选择继续将异常抛出，但是由于这里是main方法，向上抛会抛给虚拟机 try { testAge1(); } catch (Exception e) {//如果下面方法抛出的是Throwable类型异常，则此处必须有捕获Throwable的catch e.printStackTrace(); } } // 描述酒店的入住规则：限定年龄，18岁以下，80岁以上的住客必须由亲友陪同 // throw抛出异常对象的处理方案： // 方案一：通过try-catch包含throw语句来捕获处理异常 public static void testAge() { try { System.out.print(\"请输入年龄：\"); int age = new Scanner(System.in).nextInt(); if (age 80) {// 小贴士：这里使用的是短路||，当前面条件为true时，后面则不再判断 throw new Exception(\"18岁以下，80岁以上的住客必须由亲友陪同\"); } else { System.out.println(\"欢迎入住本酒店\"); } } catch (Exception e) { e.printStackTrace(); } } // 方案二：通过throws在方法声明处抛出异常，由该方法的调用者去处理该异常 public static void testAge1() throws Exception {//也可以抛出Throwable System.out.print(\"请输入年龄：\"); int age = new Scanner(System.in).nextInt(); if (age 80) {// 小贴士：这里使用的是短路||，当前面条件为true时，后面则不再判断 throw new Exception(\"18岁以下，80岁以上的住客必须由亲友陪同\"); } else { System.out.println(\"欢迎入住本酒店\"); } } } 总结下throws和throw的区别： throws：是在方法声明处抛出该方法可能出现的异常（异常可能出现、可能不出现），谁调用谁处理，或者调用者继续向上抛。 throw：是手动（主动）抛出一个特定异常的对象，可以直接通过try-catch捕获处理，也可以通过在方法声明处throws该异常，再有调用者处理，或者调用者继续向上抛。 （当通过throw抛出异常对象时，不建议抛出UncheckedException，因为编译器不会强制处理该异常） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase14/自定义异常.html":{"url":"javase14/自定义异常.html","title":"14.4 自定义异常","keywords":"","body":"14.4 自定义异常 使用Java内置的异常类可以描述在编程时出现的大部分异常情况。 也可以通过自定义异常描述特定业务产生的异常类型。 所谓自定义异常，就是定义一个类，去继承Throwable类或者它的子类。 示例： 如上面的示例代码，如果酒店年龄超出这种异常被频繁使用，我们可以通过定义HotelAgeException类来继承Exception类。 /** * @author liyan * class HotelAgeException extends Exception */ public class HotelAgeException extends Exception { // 通过无参构造器调用父类的含参构造，传入异常描述 public HotelAgeException() { super(\"18岁以下，80岁以上的住客必须由亲友陪同入住\"); } } import java.util.Scanner; public class TryDemo4 { public static void main(String[] args) { try { testAge1(); } //捕获酒店年龄异常 catch (HotelAgeException e) { System.out.println(e.getMessage());// 打印异常描述信息 System.out.println(\"酒店前台工作人员不允许办理入住登记\"); } catch (Exception e) {// 捕获其它类型异常 e.printStackTrace(); } } //方法：判断入住者年龄，抛出年龄异常 public static void testAge1() throws HotelAgeException { System.out.print(\"请输入年龄：\"); int age = new Scanner(System.in).nextInt(); if (age 80) { throw new HotelAgeException();//抛出定义的HotelAgeException类型异常 } else { System.out.println(\"欢迎入住本酒店\"); } } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase14/异常链.html":{"url":"javase14/异常链.html","title":"14.5 异常链","keywords":"","body":"14.5 异常链 有时候我们会捕获一个异常后再抛出另一个异常 顾名思义就是：将异常发生的原因一个传一个地串起来，即把底层的异常信息传给上层，这样逐层抛出。 示例： package com.imooc.test; public class TryDemo5 { public static void main(String[] args) { try { TestThree(); } catch (Exception e) { e.printStackTrace(); } } // 方法：testOne() public static void testOne() throws HotelAgeException { throw new HotelAgeException(); } // 方法：testTwo() public static void testTwo() throws Exception { try { testOne(); } catch (HotelAgeException e) { throw new Exception(\"我是新产生的异常1\", e);// 通过构造方法Exception(String message,Throwable cause)构造一个新的异常信息 } } // 方法：testThree() public static void TestThree() throws Exception { try { testTwo(); } catch (Exception e) { // 也可以通过实例化一个新的Exception对象e1 Exception e1 = new Exception(\"我是新产生的异常2\"); // 再通过e1调用父类Throwable的方法initCause(Throwable cause)返回一个新的Exception对象 e1.initCause(e); // 再抛出这个Exception类型对象e1 throw e1; } } } 示例流程解读： main()方法调用testThree()方法，testThree()调用testTwo()方法，testTwo()调用testOne()方法，然后testOne()方法抛出HotelAgeException异常； 由testTwo()捕获，它再将自己抛出的新异常和上一层捕获来的异常打包后继续抛出； testThree()捕获到上一层testTwo()抛出的异常后又实例化一个新的Exception异常对象e1，e1调用initCause()方法把上一层捕获来的异常一起打包，再抛出，最后由主方法中的catch捕获。 主方法中捕获到的异常包含三个test方法抛出的所有异常信息。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase15/java包装类.html":{"url":"javase15/java包装类.html","title":"15. Java 包装类","keywords":"","body":"14.2 Java 包装类 基本数据类型没有属性和方法，而包装类拥有属性和方法，可以实现一些特定的功能。 每一个基本数据类型都有对应的包装类。 装箱：把基本数据类型转换成包装类 拆箱：把包装类转换成基本数据类型 装箱和拆箱又分为自动和手动两种。 自动装箱 int a = 2; Integer t = a;//自动装箱：直接把int类型数据赋值给Integer对象 自动装箱：直接把int类型数据赋值给Integer对象。 手动装箱 int a = 2; Integer t = new Integer(a);//手动装箱：通过new Integer(int Value)完成手动装箱 手动装箱：通过new Integer(int Value)完成手动装箱。 自动拆箱 Integer t = 12;//这里也是一个自动装箱的过程 int a = t;//自动拆箱：直接把包装类对象赋值给整型变量 自动拆箱：直接把包装类对象赋值给整型变量。 手动拆箱 Integer t = 12; int a = t.inValue();//手动拆箱：通过调用intValue()方法，把返回的结果赋值给整型变量 手动拆箱：通过调用intValue()方法，把返回的结果赋值给整型变量。 Integer t = new Integer(12); double d = t.doubleValue();//也可以把Integer转换成double类型数据，也是手动拆箱 基本数据类型和字符串之间转换 /*基本数据类型转换成字符串*/ int a = 12; String str = Integer.toString(a); 通过Integer类的toString()方法，把基本数据类型转换为字符串类型。 /*字符串转换为基本数据类型*/ //包装类的parseInt()方法 String str = \"123\"; int a = Integer.parseInt(str); 通过Integer类的parseInt()方法把字符串转换为基本数据类型。 //包装类的valueOf()方法 String str = \"123\"; int a = Integer.ValueOf(str);//通过ValueOf()方法把字符串转换成包装类对象，又通过自动拆箱把值赋给int类型变量 通过ValueOf()方法把字符串转换成包装类对象，又通过自动拆箱把值赋给int类型变量。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase16/java字符串.html":{"url":"javase16/java字符串.html","title":"16. Java 字符串","keywords":"","body":"14.3 Java 字符串 String是一个类，是引用数据类型，它在Java.lang包下。 如何创建String对象 String str1 = \"imooc\"; String str2 = new String();//不传参，则创建空null的字符串对象 String str3 = new String(\"imooc\")//创建对象str3，值是\"imooc\" String对象常用方法： length() // 定义字符串\"JAVA 编程 基础\" String str = \"JAVA 编程 基础\"; // 打印字符串长度 对象名.length() System.out.println(\"字符串长度：\" + str.length()); 运行结果： 字符串长度：10 int indexOf(int ch) 查找ch字符在该字符串中第一次出现的位置，返回值是int类型 // 定义字符串 \"JAVA编程基础，我喜欢Java编程\" String str = new String(\"JAVA编程基础，我喜欢Java编程\"); // 查找字符'A'在字符串中第一次出现的位置 System.out.println(\"字符'A'在字符串中第一次出现的位置：\" + str.indexOf('A')); 运行结果： 字符'A'在字符串中第一次出现的位置：1 int indexOf(String str) // 定义字符串 \"JAVA编程基础，我喜欢Java编程\" String str = new String(\"JAVA编程基础，我喜欢Java编程\"); // 查找子串\"编程\"在字符串中第一次出现的位置 System.out.println(\"子串\\\"编程\\\"在字符串中第一次出现的位置：\" + str.indexOf(\"编程\")); 运行结果： 子串\"编程\"在字符串中第一次出现的位置：4 char charAt(int index) // 定义字符串\"JAVA 编程 基础\" String str = \"JAVA 编程 基础\"; // charAt() 传入字符串的位置索引，返回字符 System.out.println(str.charAt(6)); 运行结果： 程 String subString(int beginIndex) 返回一个字符串，从beginIndex下标开始到字符串结束的子串 // 定义字符串\"JAVA 编程 基础\" String str = \"JAVA 编程 基础\"; // 求子串的方法，取出\"编程 基础\" System.out.println(str.substring(5)); 运行结果： 编程 基础 String subString(int beginIndex,int endIndex) // 定义字符串\"JAVA 编程 基础\" String str = \"JAVA 编程 基础\"; // 求子串的方法，取出\"编程\" System.out.println(str.substring(5, 7)); 运行结果： 编程 byte[] getByte(String charsetName) 把字符串转换为byte[] public class StringDemo3 { public static void main(String[] args) { // 字符串和byte数组相互转换 String str = new String(\"JAVA 编程 基础\"); byte[] arrs = str.getBytes(); for (byte b : arrs) { System.out.print(b + \" \"); } System.out.println(); // 将byte数组转换成字符串 String str1 = new String(arrs); System.out.println(str1); } } 运行结果： 74 65 86 65 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128 JAVA 编程 基础 注意： 这里要注意编码集的问题，如果采用utf8编码，那在使用getByte()时，得到的byte[]也是转换成utf8编码的数据，就像上面的示例，74 65 86 65，这里74->'J' ,65->'A'，-25 -68 -106代表'编'字，这是采用utf8编码。 那么再将该byte[]转换成字符串时也要使用utf8编码，不能String转byte[]时使用GBK，再转回来的时候使用utf8，这样是没法转换的。 ==和equals的区别 public class StringDemo5 { public static void main(String[] args) { String str1 = \"imooc\"; String str2 = \"imooc\"; String str3 = new String(\"imooc\"); System.out.println(\"str1和str2的内容相同吗？\" + str1.equals(str2)); System.out.println(\"str1和str3的内容相同吗？\" + str1.equals(str3)); System.out.println(\"str1和str2的地址相同吗？\" + (str1 == str2)); System.out.println(\"str1和str3的地址相同吗？\" + (str1 == str3)); } } 运行结果： str1和str2的内容相同吗？true str1和str3的内容相同吗？true str1和str2的地址相同吗？true str1和str3的地址相同吗？false 内存空间示例： 总结：equals()和==的区别 equals() Object类中的equals()，是比较两个对象内存地址是否相同 String类中equals()，重写了父类方法，是比较两个对象字符序列是否相同 == 基本数据类型：比较两个数据或者变量的值是否相同 引用数据类型：比较两个对象的内存地址是否相同 String 的不可变性 String具有不可变性，这个概念有点儿抽象。 具体的意义可以Google一下。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase16/StringBuilder.html":{"url":"javase16/StringBuilder.html","title":"16.1 StringBuilder","keywords":"","body":"14.4 StringBuilder String和StringBuilder的区别： String具有不可变性，而StringBuilder不具备 当频繁操作字符串是，使用StringBuild。 StringBuilder和StringBuffer的区别： 二者方法基本相似 StringBuffer线程相对安全，性能低 StringBuilder线程相对不安全，性能高 示例： public class StringBuilderDemo1 { public static void main(String[] args) { // 定义字符串\"你好\" StringBuilder str = new StringBuilder(\"你好\"); // 在\"你好\"后面添加内容，将字符串编程\"你好，imooc\" // str.append('，'); // str.append(\"，imooc\"); System.out.println(\"str=\" + str.append('，').append(\"imooc\")); // 将字符串变成\"你好，iMOOC\" // 两种方式： // 1、使用delete()删除小写的imooc再插入大写的MOOC // System.out.println(\"替换后：\" + str.delete(4, 8).insert(4, \"MOOC\")); // 2、使用replace()替换 System.out.println(\"替换后：\" + str.replace(4, 8, \"MOOC\")); // 在字符串\"你好，iMOOC\"中取出\"你好\"并输出 System.out.println(str.substring(0, 2)); } } 常用方法： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase17/java集合.html":{"url":"javase17/java集合.html","title":"17. Java 集合","keywords":"","body":"14.4 Java 集合 集合属于java.util包下，需要import才能使用。 集合框架的体系结构： Interface Collection 包含以下三种subInterface： List 序列，有序 实现类：ArrayList 相当于长度可变的数组 Queue 队列，有序 实现类：LinkedList 同时也实现了List接口，链表 Set 集，无序，不允许重复 实现类：HashSet 哈希集 Interface Map 键值对(Key:Value) 实现类：HashMap 哈希表 (Key,Value)数据 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase17/List集合.html":{"url":"javase17/List集合.html","title":"17.1 List集合","keywords":"","body":"17.1 List集合 List是元素有序并且可以重复的集合，称为序列。 List是一个接口。 List可以精确的控制每个元素的插入位置，或删除某个位置的元素 List的两个主要实现类是ArrayList和LinkedList。 ArrayList ArrayList底层是由数组实现的； 长度动态增长，以满足应用程序的需求； 在列表尾部插入或删除数组非常有效，如果在中间插入数据，会进行大量的数组复制，影响性能； 更适合查找和更新元素 ArrayList中的元素可以为null 常用方法： /*List常用方法*/ ArrayList arr = new ArrayList(); arr.add(\"Hello World\"); //增：将制定元素增加到列表末尾 arr.set(0,\"你好\"); //改：用指定元素替换此列表中指定位置的元素 arr.get(0); //查：返回此列表中指定位置的元素 arr.remove(0); //删：删除列表中指定位置的元素 arr.size(); //返回列表长度 arr.isEmpty(); //如果列表没有元素，返回true 示例： package com.imooc.set; //需要导包java.util import java.util.ArrayList; import java.util.List; public class ListDemo1 { public static void main(String[] args) { // 用ArrayList存储编程语言的名称，并输出 List list = new ArrayList();// 小贴士：向上转型，接口对象指向实现类的实例 // 调用add()方法添加元素 list.add(\"Java\"); list.add(\"C\"); list.add(\"C++\"); list.add(\"Go\"); list.add(\"Swift\"); // 打印输出元素个数 System.out.println(\"列表中元素的个数为：\" + list.size());//调用size() } } 运行结果： 列表中元素的个数为：5 遍历打印列表元素： package com.imooc.set; import java.util.ArrayList; import java.util.List; public class ListDemo1 { public static void main(String[] args) { // 用ArrayList存储编程语言的名称，并输出 List list = new ArrayList();// 小贴士：向上转型，接口对象指向实现类的实例 // 调用add()方法添加元素 list.add(\"Java\"); list.add(\"C\"); list.add(\"C++\"); list.add(\"Go\"); list.add(\"Swift\"); // 打印输出元素个数 System.out.println(\"列表中元素的个数为：\" + list.size()); // 遍历输出列表的元素 for (Object object : list) { System.out.print(object + \" \"); } System.out.println(\"\\n=========================\"); for (int i = 0; i 运行结果： 列表中元素的个数为：5 Java C C++ Go Swift ========================= Java C C++ Go Swift ========================= 移除\"C++\"后的列表元素为：Java C Go Swift 小练习：公告的管理 定义一个公告类Notice： package com.imooc.set; import java.util.Date; public class Notice { // 公告类属性 private int id;// 编号 private String title;// 标题 private String creator;// 创建人 private Date createTime;// 创建时间 // 构造方法 public Notice() { } //带参构造，创建公告对象时完成对成员属性赋值 public Notice(int id, String title, String creator, Date createTime) { setId(id); setTitle(title); setCreator(creator); setCreateTime(createTime); } // get/set方法,对成员属性赋值取值 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getCreator() { return creator; } public void setCreator(String creator) { this.creator = creator; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } 在测试类供完成公告的添加、删除、修改和显示： package com.imooc.set; import java.util.ArrayList; import java.util.Date; import java.util.List; public class NoticeTest { public static void main(String[] args) { // 创建Notice对象，生成三条公告 Notice notice1 = new Notice(1, \"欢迎来到慕课网！\", \"管理员\", new Date()); Notice notice2 = new Notice(2, \"请同学们按时提交作业！\", \"老师\", new Date()); Notice notice3 = new Notice(3, \"考勤通知！\", \"老师\", new Date()); // 添加公告 List noticeList = new ArrayList(); noticeList.add(notice1); noticeList.add(notice2); noticeList.add(notice3); // 遍历列表，打印公告 System.out.println(\"公告的内容为：\"); for (int i = 0; i 运行结果： 公告的内容为： 1:欢迎来到慕课网！ 2:请同学们按时提交作业！ 3:考勤通知！ ======================================= 添加公告后的内容为： 1:欢迎来到慕课网！ 2:在线编辑器可以使用啦！ 3:请同学们按时提交作业！ 4:考勤通知！ ======================================= 删除公告后的内容为： 1:欢迎来到慕课网！ 2:在线编辑器可以使用啦！ 3:考勤通知！ ======================================= 修改后的公告内容为： 1:欢迎来到慕课网！ 2:Java在线编辑器可以使用啦！ 3:考勤通知！ ======================================= Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase17/Set集合.html":{"url":"javase17/Set集合.html","title":"17.2 Set集合","keywords":"","body":"17.2 Set集合 Set是元素无序并且不可以重复的集合，被称为集。 HashSet是Set的一个重要实现类，被称为哈希集。 HashSet中的元素无序并且不可以重复 HashSet中只允许有一个null元素（因为HashSet不允许有重复的元素） 具有良好的存取和查找性能 HashSet的底层是HashMap Iterator 迭代器 Iterator接口可以以统一的方式对各种集合元素进行遍历。 hasNext()方法检测集合中是否还有下一个元素 next()方法返回集合中的下一个元素 Set常用方法： /*Set中常用的方法*/ add(E e); //如果指定元素不存在，则添加指定元素 remove(Object o); //如果存在，则从集合中删除指定元素 size(); //返回集合的元素数 isEmpty(); //判断集合是否为空 Set集合示例： package com.imooc.set; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class WordDemo { public static void main(String[] args) { // HsahSet 哈希集：无序不可重复，底层是HashMap // 需求：将英文单词添加到HashSet当中 // 创建Set对象指向HashSet实例 Set set = new HashSet(); // 向集合添加元素 set.add(\"blue\"); set.add(\"red\"); set.add(\"black\"); set.add(\"yellow\"); set.add(\"white\"); // 遍历迭代器并输出 System.out.println(\"集合中的元素为：\"); Iterator it = set.iterator();// 通过调用iterator()方法把元素放到迭代器中 while (it.hasNext()) { System.out.print(it.next() + \" \"); } System.out.println(\"\\n==================================\"); // 在集合中插入一个新的单词 set.add(\"green\"); set.add(\"green\");// 插入重复元素编译器不会报错，但重复元素不会被插入到集合中 // 遍历迭代器并输出 System.out.println(\"插入重复元素后的集合元素为：\"); Iterator it1 = set.iterator();// 通过调用iterator()方法把元素放到迭代器中 while (it1.hasNext()) { System.out.print(it1.next() + \" \"); } System.out.println(\"\\n==================================\"); } } 运行结果： 集合中的元素为： red blue white black yellow ================================== 插入重复元素后的集合元素为： red green blue white black yellow ================================== 案例：宠物猫信息管理 需求 添加和显示宠物猫信息 查找某只宠物猫的信息并输出 修改宠物猫的信息 删除宠物猫信息 属性 名字 name 年龄 month 品种 species 方法 构造方法 获取和设置属性值的方法 其他方法 Cat类： package com.imooc.set; public class Cat { // 成员属性 private String name;// 名字 private int mouth;// 年龄 private String specie;// 品种 // 构造器 public Cat() { } // 构造器，为属性赋值 public Cat(String name, int mouth, String specie) { this.name = name; this.mouth = mouth; this.specie = specie; } // get/set方法，完成属性的赋值取值 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMouth() { return mouth; } public void setMouth(int mouth) { this.mouth = mouth; } public String getSpecie() { return specie; } public void setSpecie(String specie) { this.specie = specie; } @Override public String toString() { return \"Cat [name=\" + name + \", mouth=\" + mouth + \", specie=\" + specie + \"]\"; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + mouth; result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((specie == null) ? 0 : specie.hashCode()); return result; } @Override public boolean equals(Object obj) { // 对象相等则返回true if (this == obj) { return true; } // 判断obj是否是Cat类对象 if (obj.getClass() == Cat.class) {// 也可通过instanceof判断传入的obj是否为Cat对象 // 如果obj是Cat类对象，则强制转换成cat对象 Cat cat = (Cat) obj; // 再比较cat和当前类的属性是否都相等，都相等则返回true return cat.getName().equals(name) && (cat.getMouth() == mouth && (cat.getSpecie().equals(specie))); } // 对象或属性都不满足，则返回false return false; } } 测试类： package com.imooc.set; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class CatTest { public static void main(String[] args) { // 创建Cat对象 Cat huahua = new Cat(\"花花\", 12, \"英国短毛猫\"); Cat fanfan = new Cat(\"凡凡\", 3, \"中华田园猫\"); // 将宠物猫对象放入HashSet中 Set set = new HashSet(); set.add(huahua); set.add(fanfan); // 显示宠物猫信息 Iterator it = set.iterator(); while (it.hasNext()) { System.out.println(it.next()); } System.out.println(\"=========================\"); // 再添加一个与花花属性一样的猫 System.out.println(\"添加重复数据后的宠物信息：\"); Cat cat_1 = new Cat(\"花花\", 12, \"英国短毛猫\"); set.add(cat_1); /* * 此时新创建的cat_1是可以被添加到集合中的，原因是对象之间相比较使用的是Object类的equals()方法，所以这里需要在Cat类中重写equals()方法和hashCode()方法 * 之前在集合中添加重复字符串失败，是因为String中的equals()被重写了。 */ it = set.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase17/Map集合.html":{"url":"javase17/Map集合.html","title":"17.3 Map集合","keywords":"","body":"17.3 Map集合 Map中的数据是以键值对(key-value)的形式存储的 key-value是以Entry类型的对象实例存在 可以通过key快速地查找value 一个映射不能包含重复的键(key是唯一的) 每个键最多只能映射到一个值 HashMap 基于哈希表的Map接口的实现 允许使用null值和null键 key值不允许重复 HashMap中的Entry对象是无序排列的 案例1： 完成一个类似字典的功能 将单词已经单词的注释存储到HashMap中 显示HashMap中的内容 查找某个单词的注释并显示 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase18/java泛型.html":{"url":"javase18/java泛型.html","title":"18. Java 泛型","keywords":"","body":"14.6 Java 泛型 首先看一下下面这段代码，这是一个int类型的栈结构，只能存储Int类型数据，通过这端代码来引入泛型的概念： package com.ly.why; /** * 栈 * @author liyan */ public class StackInt { private int maxSize; private int[] items; private int top; /** * 构造器：设置栈大小 * @param maxSize */ public StackInt(int maxSize) { this.maxSize = maxSize; this.items = new int[maxSize]; this.top = -1; } /** * 通过top指针判断数组是否存满 * @return */ public boolean isFull() { return this.top == this.maxSize-1; } /** * 通过top指针判断数组是否为空 * @return */ public boolean isNull() { return this.top 代码有点儿长，这是一个栈，里面实例化了一个数组，用来存储数据的容器，栈结构的特点是后进先出,最后一个存入的数据会第一个被取出来。 这个自定义的StackInt容器在实例化时内部会实例化一个int类型数组，所以在存入数据时，只能存入int类型数据，而不能存其它类型的数据。这种直接写死的容器很不方便，我如果想存入String类型的数据难道需要改代码或者再定义一个String类型的栈吗？ 解决方式其一，可以在实例化数组时，实例化一个Object类型的数据，因为Object类是一切Java类的父类（超类），如果栈内部定义一个Object类型的数组，那就可以存入任意类型的数据，取出数据只需正确地将Object类型强制转换成原有类型即可。但是这种方法其实很不理想，因为如果使用Object类型，就会出现很多问题，例如Object类在转换数据时会出现很多拆箱装箱，并且还会存在类型安全等问题。 解决方式其二：泛型，泛型其实之前就算没有真正了解过，但是肯定用过，比如这么写： Map initParams = new HashMap(); 泛型其实就是一种数据类型的约定，约定好我要存入什么类型的数据。 那么如何把上面代码示例自定义的栈容器引入泛型呢？使之可以存入任意类型： package com.ly.why; import java.lang.reflect.Array; /** * 栈 * * @author liyan * 泛型是一种类型的约定 */ public class StackT { private int maxSize; private T[] items; private int top; /** * 构造器：设置栈大小 * * @param maxSize */ public StackT(int maxSize, Class clazz) { this.maxSize = maxSize; /** * 泛型擦除问题：涉及编译时和运行时 * new是发生在运行时的，T在运行时就已经被擦除了，JVM不知道T什么，所以无法直接new T */ // this.items = new T[maxSize]; this.items = this.createArray(clazz); this.top = -1; } public boolean isFull() { return this.top == this.maxSize - 1; } public boolean isNull() { return this.top clazz) { T[] array = (T[]) Array.newInstance(clazz, this.maxSize); return array; } /** * 泛型方法 * @param clazz * @param * @return * @throws IllegalAccessException * @throws InstantiationException */ public T test(Class clazz) throws IllegalAccessException, InstantiationException { return clazz.newInstance(); } } 其实，泛型也可以理解为是一种将数据类型参数化的形式，一种参数传递，把数据类型当做一种参数传递给类或者方法。 使用泛型的好处： 与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。 当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。 泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 StackT这种类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。 泛型的定义和使用： 泛型按照使用情况一般分为三种： 泛型类 泛型方法 泛型接口 泛型类： public class StackT { private T[] item; } 被称作类型参数，指代一切类型，可以理解成像方法的形参一样，将数据类型作为一种参数传递过来。T是一种习惯性写法，可以用任意字符代替。 但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如： T 代表一般的任何类。 E 代表 Element 的意思，或者 Exception 异常的意思。 K 代表 Key 的意思。 V 代表 Value 的意思，通常与 K 一起配合使用。 S 代表 Subtype 的意思，文章后面部分会讲解示意。 如果一个类被 的形式定义，那么它就被称为是泛型类。 那么对于泛型类怎么样使用呢？ public class StackT { private T[] item; } StackT s = new StackT(); // 那么item属性即： String[] item; 泛型类还可以接收多个泛型参数： public class MultiType { E value1; T value2; 泛型方法： 泛型方法与泛型类类似，但是的位置有所不同，不是定义在方法名后面的： public void method(T t){ System.out.println(t); } 类型参数定义在访问修饰符后面，泛型方法的返回值这样写： public T method(T t){ return null; } 泛型接口： 泛型接口和泛型类差不多 public interface Iterable { } 泛型通配符： 无界通配符 上边界通配符，只能传入Number及其子类的，父类不可以 下边界通配符，只能传入Integer及其父类的，子类的不可以 public static void mothod(StackT stackT) { System.out.println(stackT.pop()); } 这段代码中，方法参数对于传入的带泛型类型的数据参数做了范围限制。 泛型擦除 泛型也就是这种形式，只是发生在编译期间，在编译期间知道是什么类型，当编译完成，就会根据传入的数据类型替换成真实的数据类型，到JVM解释运行时，处理的都是真实的数据类型，而不是。这个该如何理解呢？ public class MainTest { public static void main(String[] args) { Demo demo = new Demo(\"Hello World\"); String s = demo.get(); } } class Demo { private T t; public Demo(T t) { this.t = t; } public T get() { return t; } } 我的理解： Demo demo = new Demo(\"Hello World\"); 在new Demo()之前，也就是编译期，我们可以知道Demo中的信息，知道是指String类型。当编译完成之后，通俗地理解，实际Demo中所有的T已经被替换成了真实数据类型String而不再是。 当new Demo()时，也就是运行时期，Demo当中的成员变量方法都是String类型，而不是T类型。也就是说，当Java在运行时期，泛型已经被擦除，JVM不会知道T是什么，也不认识T。 当初学Java时，对一些Java的基础概念，尤其是偏抽象的概念不是那么好理解，因为我们不知道这些概念应该在哪些场景下使用，在写自己的代码时，也不知道该如何写泛型。 但是当我们看到别人的代码中使用泛型时，知道这里应用的是泛型，学会这些概念首先对看懂别人的代码是很有帮助的，看了别人的代码，学习别人的编码思路，漫漫地就能写出自己的代码了。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase19/java多线程.html":{"url":"javase19/java多线程.html","title":"19. Java 多线程","keywords":"","body":"14.6 Java 多线程 线程的概念： 进程是指可执行程序并存放在计算机存储器的一个指令序列，它是一个动态执行的过程。 线程是比进程还要小的运行单位，一个进程包含多个线程。 线程相当于一个子程序。 CPU使用时间片轮转的工作方式，可以让多个程序轮流占用CPU，达到同时运行的效果 线程的创建： 创建一个Thread类，或者一个Thread子类的对象 创建一个实现Runnable接口的类的对象 Thread类 Thread是一个线程类，位于java.lang包下 //构造方法： Thread(); //创建一个线程对象 Thread(String name); //创建一个具有指定名称的线程对象 Thread(Runnable target); //创建一个基于Runnable接口实现类的线程对象 Thread(Runnable target,String name) ; //创建一个基于Runnable接口实现类，并且具有指定名称的线程对象 //常用方法： public void run(); //线程相关的代码写在该方法中，一般需要重写 public void start(); //启动线程的方法 public static void sleep(long m); //线程休眠m毫秒的方法 public void join(); //优先执行调用join()方法的线程 Runnable接口 只有一个方法 run(); Runnable是Java中用以实现线程的接口 任何实现线程功能的类都必须实现该接口 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase19/创建线程.html":{"url":"javase19/创建线程.html","title":"19.1 创建线程","keywords":"","body":"19.1 创建线程 继承Thread类创建线程： 通过继承Thread类的方式创建线程，重写run()方法来创建线程。 package com.imooc.thread; class MyThread extends Thread { @Override public void run() { System.out.println(getName() + \",该线程正在执行~\"); } } public class ThreadTest { public static void main(String[] args) { System.out.println(\"主线程1\"); MyThread mt = new MyThread(); mt.start();//启动线程 System.out.println(\"主线程2\"); } } 自定义的MyThread类通过继承Thread类来创建线程 继承Thread类后需要重写run()方法，把要执行的代码写在run()方法中 通过MyThread对象调用start()方法来启动一个线程 上面代码运行结果： 主线程1 主线程2 Thread-0,该线程正在执行~ 上面代码实际上在运行两个线程，main()方法是一个单独的线程，MyThread对象启动的是一个单独的线程 这两个线程执行的顺序不是固定的，这个取决于哪个线程先获得CPU的使用权 一个线程对象只能调用一次start()方法，如果想要启动多个想成，则需要创建多个对象调用start()方法 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase20/java输入输出流.html":{"url":"javase20/java输入输出流.html","title":"20. Java 输入输出流","keywords":"","body":"14.6 Java 输入输出流 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase20/IO流总结.html":{"url":"javase20/IO流总结.html","title":"20.1 IO流总结","keywords":"","body":"20.1 IO流总结 1. 字符流 abstract Reader 用于读取字符流的抽象类，子类必须实现的方法只有read(char[] cbuf,int off,int len)和close() 子类： class BufferedReader 继承自Reader 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。可以指定缓冲区大小，或者使用默认大小。大多数情况下，默认值就已经足够大了。 构造方法：(没有无参构造器) BufferedReader(Reader in) 创建一个使用默认大小的输入缓冲区的缓冲字符输入流 BufferedReader(Reader in,int size) 创建一个使用输入缓冲区的缓冲字符输入流并指定大小 常用方法： read() 读取单个字符 read(char[] cbuf,int off,int len) 读取字符进数组 readLine() 读取一行文本 close() 关闭流释放资源 class LineNumberReader 继承自BufferedReader 跟踪行号的缓冲字符输入流 构造方法和BufferedReader一样，都是传入一个输入流，并可以指定缓冲字符输入流的大小 常用方法： 除了父类的方法之外，额外有两个方法 getLineNumber() 得到当前行号 setLineNumber(int lineNumber) 设置当前行号 class InputStreamReader 继承自Reader 它是字节流和字符流之间的桥梁，它读取字节并使用指定的charset（编码）解析成字符，通俗的说就是把字节流读取成字符流按照指定的编码方法。 构造方法： InputStreamReader(InputStream in) 创建一个InputStreamReader使用平台默认的编码方式读取字节流 InputStreamReader(InputSteam in, Charset cs) 给定编码方法读取字节输入流 InputStreamReader(InputSteam in, Charset cs) 使用指定的字符集解码器 InputStreamReader(InputSteam in, String charsetName) 使用指定的字符集 常用方法： read() 读取单个字符 read(char[] cbuf,int off,int len) 读取字符进数组 getEncoding() 返回字符编码名称 close() 关闭流并释放资源 class FileReader 继承自InputStreamReader 用来读取字符文件的类，该类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在FileInputStream上构造一个InputStreamReader 2. 字节流 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase21/lambda表达式.html":{"url":"javase21/lambda表达式.html","title":"21. Lambda表达式","keywords":"","body":"21. Lambda表达式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase22/网络编程.html":{"url":"javase22/网络编程.html","title":"22. 网络编程","keywords":"","body":"22. 网络编程 7层网络模型-OSI： 基础层：物理层(Physical)、数据链路层(DataLink)、网络层(NetWork) 传输层(Transport)：TCP-UDP协议层、Socket 高级层：会话层(Session)、表示层(Presentation)、应用层(Application) 网络模型对应关系： Socket与TCP、UDP Socket套接字： 简单说就是IP地址与端口的结合协议 (RFC793) 一种地址与端口的结合描述协议 TCP/IP协议的相关API的总称，是网络API的集合实现 涵盖了：Stream Socket/Datagram Socket Socket的作用域组成： 在网络传输中用于唯一标识两个端点之间的连接 端点：包括（IP+Port） 4个要素：客户端地址、客户端端口、服务器地址、服务器端口 Socket传输原理： Socket 之 TCP： TCP是面向连接的端到端的通信协议 通过三次握手建立连接，通信完成时要拆除连接 由于TCP是面向连接的，所以只能用于端到端的通信 Socket 之 UDP： UDP是面向无连接的通信协议 UDP数据包括目的端口号和源端口号信息 由于通讯不需要连接，所以可以实现广播发送，并不局限于端到端 TCP传输图解： TCP发送数据时会有应答，它只有两种状态，发送成功和发送失败，不会出现只发送一半的情况。 UDP传输图解： UDP发送数据时它只管发送，不管发送是否成功。 Client-Server Application： TCP/IP协议中，两个进程之间通信的主要模式为：CS模型 主要目的：协同网络中的计算机资源、服务模式、进程间数据共享 常见的：FTP、SMTP、HTTP Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase22/客户端实现.html":{"url":"javase22/客户端实现.html","title":"Socket TCP: 客户端实现","keywords":"","body":"Socket TCP: 客户端实现 客户端代码： import java.io.*; import java.net.Inet4Address; import java.net.InetSocketAddress; import java.net.Socket; public class Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(); //读取流超时时间 socket.setSoTimeout(3000); //连接本地，端口号：2000，超时时间3000ms socket.connect(new InetSocketAddress(Inet4Address.getLocalHost(),2000),3000); System.out.println(\"已发起服务器连接，并进入后续流程~\"); System.out.println(\"客户端信息：\" + socket.getLocalAddress() + \" Port:\" + socket.getLocalPort()); System.out.println(\"服务器信息：\" + socket.getInetAddress() + \" Port:\" + socket.getPort()); try { //发送接收数据 todo(socket); } catch (Exception e) { System.out.println(\"异常关闭！\"); } //释放资源 socket.close(); System.out.println(\"客户端已退出~\"); } /** * 发送数据 * * @param client * @throws IOException */ private static void todo(Socket client) throws IOException { //构建键盘输入流 InputStream in = System.in; //输入流转换成BufferedReader BufferedReader input = new BufferedReader(new InputStreamReader(in)); //得到Socket输出流，并转换为打印流 OutputStream outputStream = client.getOutputStream(); PrintStream socketPrintStream = new PrintStream(outputStream); //得到Socket输入流，并转换为BufferedReader InputStream inputStream = client.getInputStream(); BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(inputStream)); boolean flag = true; do { //键盘读取一行 String str = input.readLine(); //发送数据 socketPrintStream.println(str); //从服务器读取一行 String echo = socketBufferedReader.readLine(); if (\"bye\".equalsIgnoreCase(echo)) { flag = false; } else { System.out.println(echo); } } while (flag); //释放资源 socketPrintStream.close(); socketBufferedReader.close(); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase22/服务端实现.html":{"url":"javase22/服务端实现.html","title":"Socket TCP: 服务端实现","keywords":"","body":"Socket TCP: 服务端实现 服务端代码： import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) throws IOException { //监听2000端口 ServerSocket serverSocket = new ServerSocket(2000); System.out.println(\"服务器准备就绪~\"); System.out.println(\"服务器信息：\" + serverSocket.getInetAddress() + \" Port:\" + serverSocket.getLocalPort()); //等待客户端连接，有连接则创建Socket对象 for (; ; ) { //得到客户端连接 Socket client = serverSocket.accept(); //客户端构建异步线程 ClientHandler clientHandler = new ClientHandler(client); //启动线程 clientHandler.start(); } } private static class ClientHandler extends Thread { private Socket socket; private boolean flag = true; ClientHandler(Socket socket) { this.socket = socket; } @Override public void run() { super.run(); System.out.println(\"新客户端连接：\" + socket.getInetAddress() + \" Port:\" + socket.getPort()); try { //得到打印流，用于数据输出；服务器会送数据使用 PrintStream socketOutput = new PrintStream(socket.getOutputStream()); //得到输入流，用于接收数据 BufferedReader socketInput = new BufferedReader(new InputStreamReader(socket.getInputStream())); do { //客户端拿到一条数据 String str = socketInput.readLine(); if (\"bye\".equalsIgnoreCase(str)) { flag = false; socketOutput.println(\"bye\"); } else { //打印收到的数据，并回送数据长度 System.out.println(socket.getPort() + \":\" + str); socketOutput.println(\"回送：\" + str.length()); } } while (flag); socketInput.close(); socketOutput.close(); } catch (Exception e) { System.out.println(\"连接异常断开\"); } finally { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } System.out.println(\"客户端已退出：\" + socket.getInetAddress() + \" Port:\" + socket.getPort()); } } } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase22/报文协议Mac地址.html":{"url":"javase22/报文协议Mac地址.html","title":"报文、协议、Mac地址","keywords":"","body":"报文、协议、Mac地址 报文段： 报文指TCP/IP协议网络传输过程中，起着路由导航作用 用以查询各个网络路由网段、IP地址、交换协议等IP数据包 报文段充当整个TCP/IP协议数据包的导航路由功能 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase22/IP、端口及远程服务器.html":{"url":"javase22/IP、端口及远程服务器.html","title":"IP、端口及远程服务器","keywords":"","body":"IP、端口及远程服务器 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase22/UDP是什么.html":{"url":"javase22/UDP是什么.html","title":"UDP是什么？","keywords":"","body":"UDP是什么？ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/注解和反射.html":{"url":"javase23/注解和反射.html","title":"23. 注解和反射","keywords":"","body":"23. 注解和反射 什么是注解 Annotation 是从JDK5.0开始引入的新技术 Annotation的作用： 不是程序本身，可以对程序做出解释（这一点和注释comment很像） 可以被其他程序（比如：编译器等）读取 Annotation的格式： 注解是以@注解名在代码中存在的，还可以添加一些参数值，例如@SuppressWarnings(value=\"unchecked\") Annotation在哪里使用： 可以附加在package、class、field、method等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/内置注解.html":{"url":"javase23/内置注解.html","title":"23.1 内置注解","keywords":"","body":"23.1 内置注解 @Override：定义在java.lang.Override中，此注解只适用于修饰方法，表示该方法声明是重写父类中的一个方法 @Deprecated：定义在java.lang.Deprecated中，此注解用于修饰方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险，或者存在更好的选择 @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息 与前亮哥注解不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性使用即可： @SuppressWarnings(\"all\") @SuppressWarnings(\"unchecked\") @SuppressWarnings(value={\"unchecked\",\"deprecation\"}) 等等 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/元注解.html":{"url":"javase23/元注解.html","title":"23.2 元注解","keywords":"","body":"23.2 元注解 元注解的作用就是用来注解其它的注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其它annotation类型作说明 这些类型和他们所支持的类在java.lang.annotation包中可以找到（@Target/@Retention/@Documented/@Inherited） @Target：用于描述注解的使用范围（即该注解可以作用在什么地方） @Retention：表示需要在什么级别保存该注解信息，用于描述注解的生命周期(SOURCE @Document：说明该注解将包含在javadoc中 @Inheriter：说明子类可以继承父类中的该注解 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/自定义注解.html":{"url":"javase23/自定义注解.html","title":"23.3 自定义注解","keywords":"","body":"23.3 自定义注解 了解了元注解之后，就可以自定义注解了 import java.lang.annotation.Target; import static java.lang.annotation.ElementType.METHOD; import static java.lang.annotation.ElementType.TYPE; @Target(value={Type,METHOD}) public @interface MyAnnotation{ String name() default \"\"; int id() default 0; } 这个就是一个自定义注解，MyAnnotation就是注解名，@Target是该自定义注解可以作用的地方，类、方法上 String name()是注解的属性（参数），后面默认值为\"\"，如果不指定默认值，则使用该注解的时候，必须指定属性的值。 如果直接内只需要定义一个属性，那么该属性名建议使用value，在使用该注解的时候，括号内可以不写属性名value，直接赋值即可 @Target(value={Type,METHOD}) @interface MyAnnotation{ String value(); } @MyAnnotation(\"Hello\")//可以省略属性名value public class Demo(){ } 注解除了是给我们自己看之外，还有一个作用就是给编译器看，让编译器知道这个注解是什么意思，否则定义了注解就和注释没有什么区别了。 所以，要学习反射的机制，通过反射来读取注解，让注解变得有意义。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/反射概述.html":{"url":"javase23/反射概述.html","title":"23.4 反射概述","keywords":"","body":"23.4 反射概述 Java是一门静态语言，有了反射机制之后，Java成为了一门”准动态“的语言。 Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期间借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 Class c = Class.forName(\"java.lang.String\") 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象地称之为：反射。 正常方式：引入需要的”包类“名称->通过new实例化->取得实例化对象 反射方式：实例化对象->getClass()方法->得到完整的”包类“名称 反射的优点和缺点： 优点： 可以实现动态创建对象和编译，体现出很大的灵活性 缺点： 对性能有影响，使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/获得反射对象.html":{"url":"javase23/获得反射对象.html","title":"23.5 获得反射对象","keywords":"","body":"23.5 获得反射对象 反射主要的API： java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 获得Class对象： package com.neu.reflect; public class Test02 extends Object{ public static void main(String[] args) throws ClassNotFoundException { //获取User类的Class对象 Class c1 = Class.forName(\"com.neu.reflect.User\"); Class c2 = Class.forName(\"com.neu.reflect.User\"); /** * 一个类在内存中只有一个Class对象 * 一个类被加载后，累的整个结构都会被封装在Class对象中 */ System.out.println(c1.hashCode()); System.out.println(c2.hashCode()); } } //定义一个实体类User class User{ private String name; private int id; private int age; public User() { } public User(String name, int id, int age) { this.name = name; this.id = id; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", id=\" + id + \", age=\" + age + '}'; } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/Class类.html":{"url":"javase23/Class类.html","title":"23.6 Class类","keywords":"","body":"23.6 得到Class类的几种方式 Class类 包java.lang.Class 对象照镜子后可以得到的信息：某个类的属性、方法、构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息。 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载导JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class所生成 通过Class可以完整地得到一个类中的所有被加载地结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应地Class对象 Class类常用方法： static ClassforName(String name) name为全限定类名（包名加类名），返回指定类的Class对象 Object newInstance()：调用缺省构造函数，返回Class对象地一个实例 Class c1 = Class.forName(\"com.neu.reflect.User\"); User user = (User) c1.newInstance();//获得User对象 getName()：返回此Class对象所表示地实体（类、接口、数组类或void）的名称 Class getSuperClass()：返回当前Class对象的父类的Class对象 Class[] getInterfaces()：获取当前Class对象的接口 ClassLoader getClassLoader()：返回该类的类加载器 Constructor[] getContructors()：返回一个包含某些Constructor对象的数组 Method getMethod(String name,Class.. T)：返回一个Method对象，此对象的形参类型为paramType Field[] getDeclaredFields()：返回Field对象的一个数组 获取Class类对象 Class.forName(\"java.util.String\") Object.class new Object().getClass Class c1 = Class.forName(\"com.neu.reflect.User\"); Class c2 = User.class; Class c3 = new User().getClass(); c1==c2==c3 这是三种获取Class对象的方式 还有一种特殊的，基本类型的包装类有一个TYPE方法也可以获取Class对象： Class type = Integer.TYPE; 只有包装类才有 哪些类型有Class对象 class：外部类，成员（成员内部类、静态内部类），局部内部类，匿名内部类 interface：接口 []：数组：数组的类型和维度相同就是同一个Class enum：枚举 annotation：注解@interface primitive type：基本数据类型 void Class c1 = Object.class; //类 Class c2 = Comparable.class; //接口 Class c3 = String[].class; //数组 Class c4 = ElementType.class; //枚举 Class c5 = int.class; //基本数据类型 Class c6 = void.class; //void Class c7 = Class.class; //Class本身也是一个类 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/类加载内存分析.html":{"url":"javase23/类加载内存分析.html","title":"23.7 类加载内存分析","keywords":"","body":"23.7 类加载内存分析 类加载的过程： 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化： 加载：将class文件字节码内容加载到内存中，并将这些静态数据转化为方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机保证一个类的()方法在多线程环境中被正确加锁和同步。 什么时候会发生类初始化： 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会先初始化其父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javase23/类加载器.html":{"url":"javase23/类加载器.html","title":"23.8 类加载器","keywords":"","body":"23.8 类加载器 类加载器的作用 类加载器的作用：将class文件字节码内容加载进内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段事件。不过JVM垃圾回收机制可以回收这些Class对象。 JVM规范定义了如下类型的类加载器： 引导类加载器（根加载器）用来加载rt.jar 通过Java获取这几种类加载器： public class Test07 { public static void main(String[] args) { //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取系统类加载器的父类加载器--扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); //获取扩展类加载器的父类加载器 ClassLoader parent1 = parent.getParent(); System.out.println(parent1); } } 输出结果： sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$ExtClassLoader@511d50c0 null ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();获取了系统类加载器，又叫Application ClassLoader ClassLoader parent = systemClassLoader.getParent();通过系统类加载器对象获取扩展类加载器 ClassLoader parent1 = parent.getParent();通过扩展类加载器获取引导类加载器，返回null，该类加载器由C++编写，无法直接获取 了解一下【双亲委派机制】： 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。下面举一个大家都知道的例子说明为什么要使用双亲委派模型。 黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。 而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。 或许你会想，我在自定义的类加载器里面强制加载自定义的java.lang.String类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。 作者：sunkang 链接：https://juejin.im/post/5b3cc84ee51d4519873f08da 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql1/数据库概念.html":{"url":"mysql1/数据库概念.html","title":"1. 数据库相关概念","keywords":"","body":"1. 数据库相关概念 SQL的语言分类 DQL(Data Query Language):数据查询语言 # select DML(Data Manipulate Language):数据操作语言 # insert update delete DDL(Data Define language):数据定义语言 # create drop alter TCL(Transaction Control Language):事务控制语言 # commit rollback Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql1/mysql数据库的安装.html":{"url":"mysql1/mysql数据库的安装.html","title":"MySQL数据库介绍与安装","keywords":"","body":"MySQL数据库安装 访问ORACLE官方下载地址： 根据系统，下载相应的安装包，下面以Mac平台为例： 下载.dmg格式的安装包，下载好之后双击，点开里面的.kpg安装文件： 根据提示一直继续下一步，中间会要求设置root密码。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/MySql数据库使用.html":{"url":"mysql2/MySql数据库使用.html","title":"2. MySql 数据库使用","keywords":"","body":"2. MySql 数据库使用 终端常用的命令： 主键约束： 建表时直接添加： create table user (id int primary key,name varchar(20)); 通过alter语句添加： alter table user add primary key (id); Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/终端操作数据库.html":{"url":"mysql2/终端操作数据库.html","title":"终端操作数据库","keywords":"","body":"终端操作数据库 安装mysql命令行工具 Mac用户在终端使用brew安装： brew install mysql 如何登陆数据库服务器？（我使用的是MySQL Shell命令行工具） mysql [-h地址] -u用户名 -p密码 如何查询数据库服务器中所有的数据库？ show databases; 如何选中某一个数据库进行操作？ use demo; 如何退出MySQL服务器？ 三种方式： exit(); \\q quit Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/如何创建和删除数据库.html":{"url":"mysql2/如何创建和删除数据库.html","title":"如何创建和删除数据库","keywords":"","body":"如何创建数据库数据表 创建数据库: -- create database命令创建数据库 create database test; -- 可以在创建数据库是设置编码集 create database test character set utf8; # 编码集名称要规范 -- 显示创建的数据库的编码集： mysql> show create database test; +----------+---------------------------------------------------------------+ | Database | Create Database | +----------+---------------------------------------------------------------+ | test | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8 */ | +----------+---------------------------------------------------------------+ -- 修改数据库的编码集 mysql> alter database test character set gb2312; mysql> show create database test; +----------+-----------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------+ | test | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET gb2312 */ | +----------+-----------------------------------------------------------------+ -- 查看数据库编码集： mysql> show character set; +----------+---------------------------------+---------------------+--------+ | Charset | Description | Default collation | Maxlen | +----------+---------------------------------+---------------------+--------+ | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | | dec8 | DEC West European | dec8_swedish_ci | 1 | | cp850 | DOS West European | cp850_general_ci | 1 | | hp8 | HP West European | hp8_english_ci | 1 | | koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 | | latin1 | cp1252 West European | latin1_swedish_ci | 1 | | latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 | | swe7 | 7bit Swedish | swe7_swedish_ci | 1 | | ascii | US ASCII | ascii_general_ci | 1 | | ujis | EUC-JP Japanese | ujis_japanese_ci | 3 | | sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 | | hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 | | tis620 | TIS620 Thai | tis620_thai_ci | 1 | | euckr | EUC-KR Korean | euckr_korean_ci | 2 | | koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 | | gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 | | greek | ISO 8859-7 Greek | greek_general_ci | 1 | | cp1250 | Windows Central European | cp1250_general_ci | 1 | | gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | | latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 | | armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 | | utf8 | UTF-8 Unicode | utf8_general_ci | 3 | | ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 | | cp866 | DOS Russian | cp866_general_ci | 1 | | keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 | | macce | Mac Central European | macce_general_ci | 1 | | macroman | Mac West European | macroman_general_ci | 1 | | cp852 | DOS Central European | cp852_general_ci | 1 | | latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 | | utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 | | cp1251 | Windows Cyrillic | cp1251_general_ci | 1 | | utf16 | UTF-16 Unicode | utf16_general_ci | 4 | | utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 | | cp1256 | Windows Arabic | cp1256_general_ci | 1 | | cp1257 | Windows Baltic | cp1257_general_ci | 1 | | utf32 | UTF-32 Unicode | utf32_general_ci | 4 | | binary | Binary pseudo charset | binary | 1 | | geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 | | cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 | | eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 | | gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 | +----------+---------------------------------+---------------------+--------+ 在数据库服务器中创建一个名为\"test\"的数据库。 -- 创建数据库 mysql> create database test; Query OK, 1 row affected (0.01 sec) -- 显示所有数据库 mysql> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sms | | sys | | test | +--------------------+ 6 rows in set (0.00 sec) 删除数据库： -- 查看所有的数据库 mysql> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sms | | sys | | test | +--------------------+ 6 rows in set (0.01 sec) -- drop database db_name 删除指定数据库 mysql> drop database test; Query OK, 9 rows affected (0.09 sec) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/如何创建和删除数据表.html":{"url":"mysql2/如何创建和删除数据表.html","title":"如何创建和删除数据表","keywords":"","body":"如何创建和删除数据表 选择数据库： -- 查看所有数据库 mysql> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sms | | sys | | test | +--------------------+ 6 rows in set (0.00 sec) -- use命令：选择指定数据库进行操作 mysql> use test; Database changed -- select database()命令：查看正在使用的数据库 mysql> select database(); +------------+ | database() | +------------+ | test | +------------+ 查看数据库中有哪些表： -- show tables 命令：查看当前数据库中所有数据表 mysql> show tables; Empty set (0.01 sec) 创建数据表： -- create table 命令：创建数据表及表内字段 create table pet(name varchar(20), owner varchar(20), species varchar(20), sex char(1), birth date); -- describe 命令：查看表结构 -- 可以简写：desc pet; mysql> describe pet; +---------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+-------------+------+-----+---------+-------+ | name | varchar(20) | YES | | NULL | | | owner | varchar(20) | YES | | NULL | | | species | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | birth | date | YES | | NULL | | +---------+-------------+------+-----+---------+-------+ 查看表结构： describe 表名; desc 表名; 删除数据表： -- drop table 命令：删除数据表 drop table pet; Query OK, 0 rows affected (0.02 sec) mysql> show tables; Empty set (0.00 sec) 重命名表 alter table user1 rename to user2; Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/ALTER命令.html":{"url":"mysql2/ALTER命令.html","title":"ALTER命令-菜鸟教程","keywords":"","body":"ALTER命令-菜鸟教程 当需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 先创建一张名为 testalter_tbl的表： mysql> create database RUNOOB; Query OK, 1 row affected Time: 0.006s mysql> use RUNOOB; You are now connected to database \"RUNOOB\" as user \"root\" Time: 0.001s -- 创建名为 testalter_tbl的表 mysql> create table testalter_tbl( -> i int, -> c char(1) -> ); Query OK, 0 rows affected -- 查看表结构 mysql> desc testalter_tbl; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | i | int(11) | YES | | | | | c | char(1) | YES | | | | +-------+---------+------+-----+---------+-------+ 删除、添加、修改表字段 -- 删除以上创建表的i字段 mysql> alter table testalter_tbl drop i; mysql> desc testalter_tbl; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | c | char(1) | YES | | | | +-------+---------+------+-----+---------+-------+ -- 使用add从句添加字段 mysql> alter table testalter_tbl add i int; mysql> desc testalter_tbl; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | c | char(1) | YES | | NULL | | | i | int(11) | YES | | NULL | | +-------+---------+------+-----+---------+-------+ 2 rows in set (0.01 sec) -- 如果需要制定新增字段的位置，可以使用FIRST关键字（设定位于第一列），AFTER字段名（设定位于某个某一字段之后） -- 先删除i mysql> alter table testalter_tbl drop i; -- 使用FIRST字段添加i mysql> alter table testalter_tbl add i int first; mysql> desc testalter_tbl; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | i | int(11) | YES | | NULL | | | c | char(1) | YES | | NULL | | +-------+---------+------+-----+---------+-------+ -- 删除i，使用AFTER在c字段后面添加i mysql> alter table testalter_tbl drop i; mysql> alter table testalter_tbl add i int after c; mysql> desc testalter_tbl; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | c | char(1) | YES | | NULL | | | i | int(11) | YES | | NULL | | +-------+---------+------+-----+---------+-------+ -- FIRST和AFTER关键字可用于ADD与MODIFY子句，所以如果想重置数据表字段的位置就需要先使用DROP删除字段然后使用ADD来添加字段并设置位置。 修改字段类型及名称 -- 如果需要修改字段类型及名称，可以在ALTER命令中使用MODIFY或CHANGE子句。 -- 把字段c类型从char(1)改成char(10): mysql> alter table testalter_tbl modify c char(10); mysql> desc testalter_tbl; +-------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+-------+ | c | char(10) | YES | | NULL | | | i | int(11) | YES | | NULL | | +-------+----------+------+-----+---------+-------+ -- 使用CHANGE子句，语法有很大不同。在CHANGE关键字后，紧跟着要修改的字段名，然后指定新字段的名称及类型： -- 使用CHANGE子句把字段改成j类型为BIGINT： mysql> alter table testalter_tbl change i j bigint; mysql> desc testalter_tbl; +-------+------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | c | char(10) | YES | | NULL | | | j | bigint(20) | YES | | NULL | | +-------+------------+------+-----+---------+-------+ -- 再把j改回int mysql> alter table testalter_tbl change j j int; mysql> desc testalter_tbl; +-------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+-------+ | c | char(10) | YES | | NULL | | | j | int(11) | YES | | NULL | | +-------+----------+------+-----+---------+-------+ ALTER TABLE对Null值和默认值的影响 -- 当修改字段是，可以指定是否包含值或者是否设置默认值 -- 指定字段j为NOT NULL且默认值为100： mysql> alter table testalter_tbl modify j bigint not null default 100; mysql> desc testalter_tbl; +-------+------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | c | char(10) | YES | | NULL | | | j | bigint(20) | NO | | 100 | | +-------+------------+------+-----+---------+-------+ -- 如果不设置控制，MySQL会自动设置该字段为NULL -- 修改字段默认值： -- 将字段j默认值修改成1000： mysql> alter table testalter_tbl alter j set default 1000; mysql> desc testalter_tbl; +-------+------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | c | char(10) | YES | | NULL | | | j | bigint(20) | NO | | 1000 | | +-------+------------+------+-----+---------+-------+ -- 使用drop语句删除字段默认值 mysql> alter table testalter_tbl alter i drop default; mysql> desc testalter_tbl; +-------+------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | c | char(10) | YES | | NULL | | | j | bigint(20) | NO | | NULL | | +-------+------------+------+-----+---------+-------+ 修改表名 -- 可以在ALTER TABLE语句中使用RENAME子句修改表名： mysql> alter table testalter_tbl rename alter_tbl; mysql> show tables; +------------------+ | Tables_in_runoob | +------------------+ | alter_tbl | +------------------+ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/MySQL数据类型与类型选择.html":{"url":"mysql2/MySQL数据类型与类型选择.html","title":"MySQL数据类型与类型选择","keywords":"","body":"MySQL数据类型与类型选择 MySQL支持多种类型，大致可以分为三类：数值、日期/时间、字符串（字符）类型。 数值： MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 byte (-128，127) (0，255) 小整数值 SMALLINT 2 bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期/时间： 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 '-838:59:59'/'838:59:59' HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串： 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 数据类型如何选择？ 日期：按照日期格式选择，常用date、time 数值：按照数值大小选择，常用int、float、double 字符串，常用char、varchar、text等 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/数据记录增删改查操作.html":{"url":"mysql2/数据记录增删改查操作.html","title":"数据记录增删改查操作","keywords":"","body":"数据记录增删改查操作 INSERT 添加记录： insert into 表名 values('值','值'...); DELETE 删除记录： delete from 表名 where 字段名 = '值'; UPDATE 修改记录： update 表名 set 字段名 = '要修改的值' where 参照字段名 = '值'; SELECT 查询记录： select * from 表名; select * from 表名 where 字段名=1; #查询表中某一行数据 select 字段名,字段名 from 表名; #查询表的某一列或多列 select distinct 字段某 from 表名; #去重查某一列 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/数据记录查询操作.html":{"url":"mysql2/数据记录查询操作.html","title":"数据记录查询操作","keywords":"","body":"数据记录查询操作 -- 1.字段去重查询 select distinct 字段 from 表名 -- 2.添加where条件 select * from 表名 where 条件() 内连接查询 inner join -- 语法格式： select * from 表1 inner join 表2 on 条件; -- 示例： mysql> select * from tab_goods inner join tab_price on tab_goods.id=tab_price.id; +----+--------------+--------+----+--------+ | id | name | number | id | price | +----+--------------+--------+----+--------+ | 1 | 洗衣机 | 1000 | 1 | 100.00 | | 2 | 电视 | 2000 | 2 | 200.00 | | 3 | PS5 | 2000 | 3 | 300.00 | | 4 | 家庭影院 | 500 | 4 | 500.00 | +----+--------------+--------+----+--------+ 外连接查询 Outer join -- 左外连接（根据左侧表查询） select * from 左侧表名(主表) left outer join 右侧表名(从表) on 条件; select * from 左侧表名(主表) left join 右侧表名(从表) on 条件; -- 示例： mysql> select * from tab_goods left outer join tab_price on tab_goods.id=tab_price.id; +----+--------------+--------+------+--------+ | id | name | number | id | price | +----+--------------+--------+------+--------+ | 1 | 洗衣机 | 1000 | 1 | 100.00 | | 2 | 电视 | 2000 | 2 | 200.00 | | 3 | PS5 | 2000 | 3 | 300.00 | | 4 | 家庭影院 | 500 | 4 | 500.00 | | 5 | switch | 100 | NULL | NULL | +----+--------------+--------+------+--------+ -- 右外连接 select * from 左侧表名(从表) right outer join 右侧表名(主表) on 条件; select * from 左侧表名(从表) right join 右侧表名(主表) on 条件; -- 示例： mysql> select * from tab_goods right outer join tab_price on tab_goods.id=tab_price.id; +------+--------------+--------+----+--------+ | id | name | number | id | price | +------+--------------+--------+----+--------+ | 1 | 洗衣机 | 1000 | 1 | 100.00 | | 2 | 电视 | 2000 | 2 | 200.00 | | 3 | PS5 | 2000 | 3 | 300.00 | | 4 | 家庭影院 | 500 | 4 | 500.00 | +------+--------------+--------+----+--------+ -- 全外连接 select * from 表名 full outer join 表名 on 条件; #这种写法mysql不支持 #mysql需要使用union连接左右表示全连接(union去重，union all保留重复项) select * from tab_goods left join tab_price on tab_goods.id=tab_price.id union select * from tab_goods right outer join tab_price on tab_goods.id=tab_price.id; -- 示例： +------+--------------+--------+------+--------+ | id | name | number | id | price | +------+--------------+--------+------+--------+ | 1 | 洗衣机 | 1000 | 1 | 100.00 | | 2 | 电视 | 2000 | 2 | 200.00 | | 3 | PS5 | 2000 | 3 | 300.00 | | 4 | 家庭影院 | 500 | 4 | 500.00 | | 5 | switch | 100 | 5 | 350.00 | | 7 | iPhone14 | 100 | NULL | NULL | | NULL | NULL | NULL | 6 | 450.00 | +------+--------------+--------+------+--------+ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-主键约束-primary_key.html":{"url":"mysql2/约束-主键约束-primary_key.html","title":"约束-主键约束-primary_key","keywords":"","body":"约束-主键约束-primary_key 主键约束修饰的字段，不能重复且不能为null。 相当于唯一约束（unique）+ 非空约束（not null）。 一张表最多只能有一个主键约束。 添加主键约束： -- 1.创建表时为id字段添加主键约束 mysql> create table user1(id int primary key, name varchar(20)); Query OK, 0 rows affected (0.02 sec) mysql> desc user1; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 2 rows in set (0.00 sec) -- 2.通过ALTER语句添加： alter table user1 modify id int primary key; #方式1 alter table user1 change id id int primary key; #方式2 alter table user1 add primary key(id); #方式3 alter table user1 add constraint primary key(id); #方式4 删除主键约束： -- 删除主键约束的方式 -- 通过ALTER语句删除： alter table user1 drop primary key; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | NO | | | | | name | varchar(20) | YES | | | | +-------+-------------+------+-----+---------+-------+ 删除主键约束前，如果有自增约束需要先删除自增约束,如果不删除自增就无法删除主键约束。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-主键约束-联合主键.html":{"url":"mysql2/约束-主键约束-联合主键.html","title":"约束-主键约束-联合主键","keywords":"","body":"约束-主键约束-联合主键 创建一个表user2，定义id、name、password三个字段，同时把id和name设置成主键： create table user2(id int,name varchar(20), password varchar(20), primary key(id,name)); 说明：联合主键，两个主键字段加起来不重复，就可以（即有一个不重复就可以正常写入数据）。 注意，联合主键任意字段都不能为null，除非主键加了自增约束 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-自增约束-auto_increment.html":{"url":"mysql2/约束-自增约束-auto_increment.html","title":"约束-自增约束-auto_increment","keywords":"","body":"约束-自增约束-auto_increment 添加自增约束： -- 1.创建表时添加： create table user3(id int primary key auto_increment, name varchar(20)); -- 2.通过ALTER语句添加： alter table user3 modify id int auto_increment; alter table user3 change id id int auto_increment; 一张表只能有一个自增约束列，并且该列定义了约束（可以是primary key，可以是unique，也可以是foreign_key，但是不能是非空或检查约束） 自增长一般配合主键使用，并且只能在数字类型中使用 删除自增约束： -- 通过ALTER语句删除： alter table user3 modify id int; #方式1 alter table user3 change id id int; #方式2 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-唯一约束-unique.html":{"url":"mysql2/约束-唯一约束-unique.html","title":"约束-唯一约束-unique","keywords":"","body":"约束-唯一约束-unique 约束字段的值不可以重复。 添加唯一约束： -- 1.可以在创建表时直接添加 -- 2.通过ALTER语句： alter table user5 add unique (name); #方式1 alter table user5 add unique key (name); #方式2 alter table user5 modify name varchar(20) unique; #方式3 alter table user5 change name name varchar(20) unique; #方式4 alter table user5 add constraint unique (name); #方式5 alter table user5 add constraint unique key(name); #方式6 注意：联合唯一约束，即多个字段设置了唯一约束，多个字段的值相加不能相同；有一个字段不同即可插入。 删除唯一约束 -- 删除唯一约束 alter table user drop index name; Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-非空约束-not_null.html":{"url":"mysql2/约束-非空约束-not_null.html","title":"约束-非空约束-not_null","keywords":"","body":"约束-非空约束-not_null 修饰的字段不能为空 NULL 添加非空约束 -- 建表时直接添加 create table user9 (id int,name varchar(20) not null); -- 通过ALTER语句添加： alter table user9 modify name varchar(20) not null; alter table user9 change name name varchar(20) not null; 删除非空约束 -- 通过ALTER语句删除： alter table user9 modify name varchar(20); alter table user change name name varchar(20); Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-默认约束-default.html":{"url":"mysql2/约束-默认约束-default.html","title":"约束-默认约束-default","keywords":"","body":"约束-默认约束-default 当我们插入字段值的时候，如果没有传值，就会使用默认值。 添加默认约束： -- 在创建表时添加 -- 通过ALTER语句添加： alter table user1 modify id int default 10; #方式1 alter table user1 change id id int default 10; #方式2 删除默认约束： -- 通过ALTER语句删除： alter table user1 modify id int; alter table user1 change id id int; 示例： -- 创建表user10 mysql> create table user10( id int, name varchar(20), age int default 10); Query OK, 0 rows affected (0.10 sec) -- age设置了默认值 mysql> desc user10; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | age | int(11) | YES | | 10 | | +-------+-------------+------+-----+---------+-------+ -- 只插入id和name mysql> insert into user10(id,name) values(1,'张三'); Query OK, 1 row affected (0.02 sec) -- age默认为10 mysql> select * from user10; +------+--------+------+ | id | name | age | +------+--------+------+ | 1 | 张三 | 10 | +------+--------+------+ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/约束-外键约束-foreign_key.html":{"url":"mysql2/约束-外键约束-foreign_key.html","title":"约束-外键约束-foreign_key","keywords":"","body":"约束-外键约束-foreign_key 涉及两个表：父表和子表 添加外键约束： -- 创建表时添加 mysql> create table students( -> id int primary key, -> name varchar(20), -> class_id int, -> constraint FK_students_classes foreign key (class_id) references classes(id)#创建表时添加外键约束 -> ); -- 外键中的级联关系有以下几种情况： #ON DELETE CASCADE 删除主表中的数据时，从表中的数据随之删除 #ON UPDATE CASCADE 更新主表中的数据时，从表中的数据随之更新 #ON DELETE SET NULL 删除主表中的数据时，从表中的数据置为空 #默认 删除主表中的数据前需先删除从表中的数据，否则主表数据不会被删除 mysql> create table students( -> id int primary key, -> name varchar(20), -> class_id int, -> constraint FK_students_classes foreign key(class_id) references classes(id) ON DELETE CASCADE#创建表时添加外键约束 -> ); -- 通过alter语句添加 alter table user1 add constraint 外键（如FK_从表名_主表名） foreign key 从表名(字段) references 主表(字段); 示例： 创建两张表，一张班级表，一张学生表 -- 创建classes表 create table classes( id int primary key, -> name varchar(20)); mysql> desc classes; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ -- 创建students表 mysql> create table students( -> id int primary key, -> name varchar(20), -> class_id int, -> foreign key (class_id) references classes(id)#创建表时添加外键约束 -> ); mysql> desc students2; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(20) | YES | | NULL | | | class_id | int(11) | YES | MUL | NULL | | +----------+-------------+------+-----+---------+-------+ -- 添加班级 mysql> insert into classes values (1,'一班'); mysql> insert into classes values (2,'二班'); mysql> insert into classes values (3,'三班'); mysql> insert into classes values (4,'四班'); mysql> select * from classes; +----+--------+ | id | name | +----+--------+ | 1 | 一班 | | 2 | 二班 | | 3 | 三班 | | 4 | 四班 | +----+--------+ -- 添加学生1 mysql> insert into students values(10001,'张三',1); -- 添加学生，class_id=5 mysql> insert into students values(10002,'张三',5); -- 报错 ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`test`.`students`, CONSTRAINT `fk_students_classes` FOREIGN KEY (`class_id`) REFERENCES `classes` (`id`)) 删除外键约束： alter table user1 drop foreign key 外键（FK_从表_主表）; Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/数据表设计-第一范式1NF.html":{"url":"mysql2/数据表设计-第一范式1NF.html","title":"数据表设计-第一范式1NF","keywords":"","body":"数据表设计-第一范式1NF -- 第一范式 1NF （拆字段） #数据表中的所有字段都是不可分割的原子值 create table student( id int primary key, name varchar(20), addreee varchar(30) ); insert into student values(1,'张三','辽宁省大连市高新园区XXX号'); insert into student values(2,'李四','辽宁省沈阳市沈北新区XXX号'); insert into student values(3,'社会王','河北省北京市朝阳区XXX号'); +----+-----------+--------------------------------------+ | id | name | addreee | +----+-----------+--------------------------------------+ | 1 | 张三 | 辽宁省大连市高新园区XXX号 | | 2 | 李四 | 辽宁省沈阳市沈北新区XXX号 | | 3 | 社会王 | 河北省北京市朝阳区XXX号 | +----+-----------+--------------------------------------+ -- 字段值还可以继续拆分的，就不满足第一范式 create table student2( id int primary key, name varchar(20), privence varchar(30), city varchar(30), details varchar(30) ); insert into student2 values(1,'张三','辽宁省','大连市','高新园区XXX号'); insert into student2 values(2,'李四','辽宁省','沈阳市','沈北新区XXX号'); insert into student2 values(3,'社会王','河北省','北京市','朝阳区XXX号'); +----+-----------+-----------+-----------+--------------------+ | id | name | privence | city | details | +----+-----------+-----------+-----------+--------------------+ | 1 | 张三 | 辽宁省 | 大连市 | 高新园区XXX号 | | 2 | 李四 | 辽宁省 | 沈阳市 | 沈北新区XXX号 | | 3 | 社会王 | 河北省 | 北京市 | 朝阳区XXX号 | +----+-----------+-----------+-----------+--------------------+ -- 范式：设计得越详细，对于某些实际操作可能会更好，但是不一定都是好处 -- 数据表设计以实际开发需求为主，如果整个项目完全不需要去拆分字段，那就不需要参照范式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/数据表设计-第一范式2NF.html":{"url":"mysql2/数据表设计-第一范式2NF.html","title":"数据表设计-第一范式2NF","keywords":"","body":"数据表设计-第一范式2NF -- 第二范式 2NF （拆表） -- 必须是满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖主键。 -- 如果要出现不完全依赖，只可能发生在联合主键情况下。 -- 订单表 create table myorder( product_id int, customer_id int, product_name varchar(20), customer_name varchar(20). primary key(product_id,customer_id) ); -- 问题？ -- 除主键外的其他列，只依赖于主键的部分字段。（不满足第二范式） -- 拆表 create table myorder( order_id int primary key, pruduct_id int, customer_id int ); create table product( id int primary key, name varchar(20) ); create table customer( id int primary key, name varchar(20) ); -- 拆分成三个表之后，满足第二范式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/数据表设计-第一范式3NF.html":{"url":"mysql2/数据表设计-第一范式3NF.html","title":"数据表设计-第一范式3NF","keywords":"","body":"数据表设计-第一范式3NF -- 第二范式 3NF -- 必须满足第二范式，除开主键列外的其他列之间不能有传递依赖。 create table myorder( order_id int primary key, pruduct_id int, customer_id int, customer_phone varchar(15) #假设customer_phone有对order_id的依赖，满足第二范式要求。但它也依赖于customer_id，所以不满足第三范式。 ); create table customer( id int primary key, name varchar(20), phone varchar(15)# 应该把customer_phone放到customer表中 ); Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/内连接、左连接、右连接.html":{"url":"mysql2/内连接、左连接、右连接.html","title":"内连接、左连接、右连接","keywords":"","body":"内连接、左连接、右连接 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/创建视图.html":{"url":"mysql2/创建视图.html","title":"创建视图view","keywords":"","body":"创建视图view Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql2/脏读、幻读、不可重复读.html":{"url":"mysql2/脏读、幻读、不可重复读.html","title":"脏读、幻读、不可重复读","keywords":"","body":"脏读、幻读、不可重复读 数据库事务的特征 数据库事物特征，即ACID： Atomicity 原子性 事务是一个原子性质的操作单元，事务里面对数据库的操作要么执行，要么不执行 Consistent 一致性 在事务开始之前和完成之后，数据必须保持一致状态，必须保证数据库的完整性。也就是说，数据必须符合数据库的规则。 Isolation 隔离性 数据库允许多个事务同时对数据进行操作，隔离性保证了各个事务相互独立，事务处理时的中间状态对其它事务是不可见的，以此防止出现数据不一致的状态。 可通过事务隔离级别设置： 未提交读(Read uncommitted) 已提交读(read committed) 可重复读(repeatable read) 串行化(Serializable) Durable 持久性 一个事务处理结束后，其对数据库的修改是永久性的，即使系统故障也不会丢失。 MySql数据库隔离级别 首先 MySQL 里有四个隔离级别：Read uncommttied（可以读取未提交数据）、Read committed（可以读取已提交数据）、Repeatable read（可重复读）、Serializable（可串行化）。 在 InnoDB 中，默认为 Repeatable 级别，InnoDB 中使用一种被称为 next-key locking 的策略来避免幻读（phantom）现象的产生。 使用 select @@tx_isolation; 可以查看 MySQL 默认的事务隔离级别。 不同的事务隔离级别会导致不同的问题： 脏读、幻读、不可重复读的概念 脏读： 所谓脏读是指一个事务中访问到了另外一个事务未提交的数据，如下图： 如果会话 2 更新 age 为 10，但是在 commit 之前，会话 1 希望得到 age，那么会获得的值就是更新前的值。或者如果会话 2 更新了值但是执行了 rollback，而会话 1 拿到的仍是 10。这就是脏读。 幻读： 一个事务读取2次，得到的记录条数不一致： 上图很明显的表示了这个情况，由于在会话 1 之间插入了一个新的值，所以得到的两次数据就不一样了。 不可重复读： 一个事务读取同一条记录2次，得到的结果不一致： 由于在读取中间变更了数据，所以会话 1 事务查询期间的得到的结果就不一样了。 解决方案 解决方案也就是上文提到的四种隔离级别，他们可以最大程度避免以上三种情况的发生： 未授权读取 也称为读未提交（Read Uncommitted）：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 授权读取 也称为读提交（Read Committed）：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。 可重复读取（Repeatable Read） 可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 序列化（Serializable） 序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql3/JDBC.html":{"url":"mysql3/JDBC.html","title":"3. JDBC","keywords":"","body":"21. JDBC 概念：JDBC (Java Database Connectivity) Java数据库连接 JDBC本质：其实是（Sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商来实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包的实现类。 快速入门： 步骤： 导入驱动jar包 注册驱动 class.forName(\"com.mysql.cj.jdbc.Driver\"); 获取数据库连接对象 Connection connection, Connection是接口 定义sql 获取执行sql语句的对象Statement 执行sql，接收返回的结果 处理结果 释放资源 代码示例： /** * JDBC快速入门 */ public class JdbcDemo1 { private static final String DB_URL = \"jdbc:mysql://localhost:3306/itcast\"; private static final String DB_USER = \"root\"; private static final String DB_PASS = \"Liyan1234\"; public static void main(String[] args) throws ClassNotFoundException { //1. 导入驱动jar包 try { //2.注册驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //3.获取连接对象 Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS); //4.定义sql语句 String sql = \"update account set balance = 1000 where name='张三'\"; //5.获取Statement对象 Statement stmt = conn.createStatement(); //6.执行sql语句 int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //释放资源 stmt.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } 逐个解析： 1.DriverManager类 registerDriver()方法：注册驱动： class.forName(\"com.mysql.cj.jdbc.Driver\");加载jdbc中的Driver实现类，该实现类中有一个静态代码块，加载驱动实际上是调用了DriverManager里的注册驱动registerDriver()方法： static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\"); } } getConnection()方法：获取Connection对象 获取连接对象是调用DriverManager类中的静态方法getConnection()返回了一个Connection对象： Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS); DB_URL:指定连接路径 路径格式：jdbc:mysql://ip地址:端口号/数据库名称 如果连接本地本地数据库，可简写成：jdbc:mysql:///数据库名称 2.获取数据库Connection对象 Interface Connection createStatement()方法：获取执行sql语句的Statement对象 Statement stmt = conn.createStatement(); Connection接口对象调用了实现类ConnectionImpl中的createStatement()方法，返回一个Statement对象 prepareStatement(String sql)方法：用来生成PreparedStatement对象 管理事务： 开启事务：setAutoCommit(boolean autoCommit)：该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() 3.获取执行sql语句Statement对象 Interface Statement 用于执行静态SQL语句并返回其生成的结果的对象。 execute(String sql) 执行任意sql语句 executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL（create、alter、drop）语句 返回值int类型：影响的行数，可以通过这个印象的行数来判断DML语句是否执行成功。如果返回值>0则执行成功。 executeQuery(String sql) ：执行DQL（select）语句，返回ResultSet对象。 4.ResultSet：结果集对象 executeQuery()方法执行sql查询，会返回一个结果集对象 next()方法：游标向下移动一行，如果返回true，则有下一行；如果返回flase，则表示没有更多行。 getString(\"字段名\") ：得到该行指定列的数据（String） 5.PreparedStatement对象 是Statement的子接口，可防止SQL注入问题 PreparedStatement pstmt = conn.prepareStatement(String sql); 通过Connection接口中的prepareStatement(String sql)方法创建对象，需要传入sql语句 SQL语句的写法：String sql = \"select * from user where username=? and password=?\"; setString(int index,String string);为SQL语句中的问号赋值，index为第几个问号，从1开始。 pstmt.executeQuery(); 这里不需要传入SQL语句 代码演示：用户名密码校验 /** * 登陆判断用户名密码 * @param username * @param password * @return bool */ public boolean login(String username, String password) { if (username == null || password == null) { return false; } PreparedStatement pstmt = null; Connection conn = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); String sql = \"select * from user where username=? and password=?\"; pstmt = conn.prepareStatement(sql); pstmt.setString(1,username); pstmt.setString(2,password); rs = pstmt.executeQuery(); return rs.next(); } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closs(rs, pstmt, conn); } return false; } JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作： 开始事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit); 参数为false即开始事务 提交事务：commit() 回滚事务：rollback() Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql3/数据库连接池.html":{"url":"mysql3/数据库连接池.html","title":"数据库连接池","keywords":"","body":"数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 访问效率高 实现： 接口：DataSource javax.sql包 获取连接：getConnection()； 归还连接：close()如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接，而是归还连接。 由数据库厂商实现该接口 c3p0：数据库连接池实现技术 druid：数据库连接池实现技术，由alibaba提供 c3p0 连接池技术： 导入jar包 定义配置文件(自动加载) 名称：c3p0.properties/c3p0-config.xml 路径：放到src路径下即可 创建核心对象：数据库连接池对象 ComboPooledDataSource DataSource ds = new ComboPooledDataSource(); 获取连接：getConnection() Connection conn = ds.getConnection(); 示例： public class C3P0Demo { public static void main(String[] args) { try { //1.创建数据库连接池对象 DataSource dataSource = new ComboPooledDataSource(); //2.获取连接对象 Connection conn = dataSource.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } } } 配置文件：c3p0-config.xml： com.mysql.cj.jdbc.Driver jdbc:mysql://localhost:3306/itcast root 123456 5 10 3000 com.mysql.cj.jdbc.Driver jdbc:mysql://localhost:3306/itcast root 123456 5 8 1000 Druid 连接池技术： 导入jar包 定义配置文件(手动加载) 获取数据库连接池对象：通过工厂来获取：DruidDataSourceFactory createDataSource(Properties properties);传入的参数是properties DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); 获取连接：getConnection() Connection conn = dataSource.getConnection(); 示例： public class DruidDemo { public static void main(String[] args) { //创建Properties对象 Properties properties = new Properties(); //通过类加载器获取配置文件流 InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\"); try { //把文件流导入到properties properties.load(is); //createDataSource(Properties properties);传入的参数是properties DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); //获取Connection对象 Connection conn = dataSource.getConnection(); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } 配置文件druid.properties: driverClassName=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/itcast username=root password=123456 initialSize=5 #初始化大小 maxActive=10 #最大激活数 maxWait=3000 #最大等待时间(ms) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql3/SpringJDBC.html":{"url":"mysql3/SpringJDBC.html","title":"SpringJDBC工具类","keywords":"","body":"Spring JDBC Sprint框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发。 步骤： 导入JDBCTemplate jar包 创建JdbcTemplate对象，依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(dataSource); 调用JdbcTemplate的方法来完成CRUD的操作。 update() 方法：执行DML语句（数据操作语言），增删改 queryForMap() 方法：执行DQL语言（数据查询语言），将查询结果集封装为map集合 //queryForMap(sql); 会将列名作为key，字段的值作为value封装到map里。所以，该方法只能查询一行数据，将一行数据每个字段值作为键值对存放到map中 Map map = template.queryForMap(sql, 1); queryForList() 方法：将查询结果集封装为List集合 //queryForList(sql)将每一条记录封装为Map集合，再把一个个map对象放到List里 List> maps = template.queryForList(sql); query() 方法：将查询结果封装为JavaBean对象 //query(sql, new BeanPropertyRowMapper(Account.class)); 方法里面除了传入sql语句，还要实例化BeanPropertyRowMapper(类型.class) List list = template.query(sql, new BeanPropertyRowMapper(Account.class)); queryForObject() 方法：将查询结果封装为对象 //queryForObject(sql, Long.class);一般用于聚合函数的查询 Long total = template.queryForObject(sql, Long.class); 代码示例： public class JdbcTemplateDemo1 { public static void main(String[] args) { //创建JdbcTemplate对象(这里调用了写好的工具类生成DataSource对象) JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); //调用方法 String sql = \"update account set balance = ? where name = ?\"; int count = template.update(sql,5000,\"社会王\"); System.out.println(count);//count是返回影戏的行数 } } 使用JdbcTemplate后，不需要创建Statement对象，也不需要释放资源了，大大简化了工作量。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mysql3/DBUtils.html":{"url":"mysql3/DBUtils.html","title":"DBUtils工具类","keywords":"","body":"DBUtils工具类 第一步：引入依赖，Maven坐标： commons-dbutils commons-dbutils 1.7 第二步：获取QueryRunner对象： QueryRunner queryRunner = new QueryRunner(DataSource dataSource); 第三步： 常用方法： 查询：返回实体类 User user = queryRunner.query(sql, new BeanHandler(User.class), id); 查询单条数据时，可以将查询结果封装成实体类对象 query方法的参数分别是： sql语句 new BeanHandler(User.class) sql中要赋值的参数 查询：返回实体类列表 List userList = queryRunner.query(sql, new BeanListHandler(User.class)); 查询多条数据时，可以将查询的每条结果封装成实体类对象再放到List中 更新 int i = queryRunner.update(sql, user.getId(), user.getUsername()); 执行DML（增、删、改）时，使用update()方法 方法参数是sql语句，如果sql中需要传参，接着写就行 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web1/html.html":{"url":"web1/html.html","title":"1. HTML基础","keywords":"","body":"1. HTML基础 概念： Hyper Text Markup Language 超文本标记语言 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。 标记语言是由一个个标记（标签）组成的 标记语言不是编程语言 HTML标签： html文档后缀为： .html .htm 标签分为： 围堵标签：有开始标签，有结束标签 自闭和标签：开始标签和结束标签在一起，如br hr 标签可以嵌套 在开始标签内可以定义属性，属性是由键值对构成，值要用引号引起来，单引和双引都可以 html不缺分大小写，但是建议使用小写 HTML 元素： HTML元素值的是从开始标签（start tag）到结束标签（end tag）的所有代码。 开始标签常被称为开放标签（opening tag），结束标签常称为闭合标签（closing tag）。 HTML 元素语法： HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 嵌套的HTML元素 大多数HTML元素可以嵌套（可以包含其他HTML元素） HTML文档由嵌套的HTML元素组成 This is my first paragraph. HTML属性： HTML标签可以拥有属性。属性提供了有关HTML元素的更多的信息。 属性总是以名称/值对的形式出现，例如：name = \"value\"。 属性总是在HTML元素的开始标签中规定。 示例： This is a link HTML链接由a标签定义，链接的地址在href属性中 HTML文档结构： Document HTML4.01文档声明方式： HTML5文档声明方式： 注意：在HTML5中写HTML4.01的代码是兼容的（向后兼容），在HTML4.01中写HTML5的代码，会出问题。 HTML中的常用标签： 标题标签：h1-h6 段落标签：p 强调：strong，表示强调，有加粗效果，比较常用；em：也表示强调，内容会变成斜体 换行：br（自闭合标签） 补充：空白折叠：HTML文档中如果出现多个连续的空格或者有换行，浏览器会把这些空格或换行折叠成一个空格显示。 水平分割线：hr（自闭合标签） 无序列表：ul（unordered list），里面嵌套li标签，代表每一条 有序标签：ol（ordered list），里面嵌套li标签 定义列表：dl（definition list），其中的子标签dt（definition title）定义标题，dd（definition description）定义列表描述 表格标签：table标签： 子标签：行：tr，列：td，标题：th 在table标签内，tr标签外使用caption标签为表格添加标题 横向合并（合并列）：在th或者td标签中使用colspan属性，colspan=\"2\"，合并两列 纵向合并（合并行）：在td标签中使用rowspan属性，rowspan=\"2\"，合并两行 链接标签：a（anchor）锚点，常用属性: href：锚点链接 title：标题，鼠标放到超链接上显示的标题 target：超链接打开方式，target=\"_blank\" 在新标签中打开链接 通过a标签指向邮箱地址href=\"mailto:xxx@qq.com\" 图像标签：img（自闭合标签）： src属性：指向图片路径 width属性：图片宽度 height属性：图片高度 alt属性：当图片资源加载失败时，显示该属性指定的文本 title属性：鼠标悬浮式，显示title文本 表单标签：form: action属性：表单提交的目的地 method属性：提交方式，常用为get、post，默认的提交方式是get 文本输入框：input标签（自闭合标签）： type属性：文本输入框类型，如text、password、submit text：文本输入框 password：密码输入框 submit：表单提交按钮 reset：表单重置按钮 radio：单选框，如果需要多个单选框组合实现单选，那么这几个单选框要设置相同的name属性 checkbox：复选框，如果需要多个复选框组合使用，那么这几个复选框要设置相同的name属性 value属性：文本框的值，文本输入框type为按钮时，value值为按钮显示的文本 placeholder属性：文本框中用于提示的文本 checked属性：单选框、复选框默认为选中状态，checked=\"checked\" lable标签，通过lable中的for属性关联文本输入框中的id属性，可以实现关联。点击 label 元素内的文本，则会将鼠标切换到关联控件本身 下拉菜单：select标签，里面要使用option标签设置每个选择项 文本域输入框：textarea标签 rows属性：文本域默认显示的行数（高度） cols属性：文本域默认显示的列数（宽度） div标签：（division），块标签（一个标签占用一行）本身没有任何样式，常与css搭配使用 span标签：内联标签，本身没有任何样式，常与css搭配使用 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/css.html":{"url":"web2/css.html","title":"2. CSS基础","keywords":"","body":"2. CSS基础 CSS概念： 英文全称：Cascading Style Sheets 层叠样式表 它用来控制网页样式，并允许将样式代码与网页内容分离的一种标记性语言 CSS规则由两部分构成：选择器，声明 CSS样式需要写到style标签内，style标签需要写到head标签内。 CSS注释格式： p{ font-size:30px; } /*注释内容*/ CSS引入方式： 行内样式（内联样式） 在开始标签内添加style样式属性 内容 css样式和页面同时加载 内部样式表（嵌入样式） 把CSS样式写到style标签内 样式... css样式和页面同时加载 外部样式表 把CSS样式代码写在独立的一个文件中 扩展名：CSS文件名.css 引入外部文件： 页面加载时，同时加载CSS样式 导入式 在标签最开始处通过@import \"XX.css\" 或者@import url(\"XX.cxx\");的方式导入 在读取完html文件后加载 引入方式优先级，就近原则，离元素更近，优先级高 CSS选择器： 一、标签选择器： 标签选择器，通过’标签名‘选择标签 p{ color:red; } 类(class)选择器，通过’.+class值‘的形式选择标签 .class值{ color:red; } id选择器，通过’#+id值‘的形式选择标签 #id值{ color:red; } 二、高级选择器： 后代选择器 子元素选择器 组合选择器 交集选择器 伪类选择器 伪元素选择器 CSS继承和层叠： CSS继承： ​ 从父元素那里继承部分样式属性（不是所有的属性都可以继承，例如border等属性是不可以继承的） 继承好处： 父元素设置样式，子元素可以继承部分属性 减少CSS代码 CSS层叠： 可以定义多个样式 不冲突时，多个样式可以层叠为一个 冲突时，按不同样式规则优先级来应用样式 CSS优先级规则： 同一样式表中： 权值相同：就近原则（离被设置元素越近优先级越高） 权值不同：根据权值来判断CSS样式，那种CSS样式权值高，就使用哪种样式 选择器权值： 标签选择器：权值为1 类选择器和伪类：权值为10 ID选择器：权值为100 通配符选择器：权值为0 行内样式：权值为1000 权值规则： 统计不同选择器的个数 每类选择器的个数乘以相应权值 把所有的值相加得出选择器的权值 CSS样式命名规则 采用英文字母、数字、以及\"-\"和\"_\"命名 以小写字母开头，不能以数字和\"-\"和\"_\"开头 命名形式，单字，连字符，下划线和驼峰 使用有意义的命名 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/高级选择器.html":{"url":"web2/高级选择器.html","title":"2.1 高级选择器","keywords":"","body":"2.1 高级选择器 HTML当前的结构： p标签1 p标签2 p标签3 p标签4 p标签5 p标签6 p标签7 后代选择器： 选择某个元素的后代的指定元素： /*后代选择器*/ body p{ background: red; } 子元素择器： 选择某个元素后一代指定的元素： 区别于后代选择器，后代选择器是后代（包括子代的子代...）所有指定元素都被选择，而子元素选择器只会选择一代 /*子选择器*/ body>p{ background: red; } 相邻兄弟选择器： 选择某个元素相邻（相邻下面的，不选择相邻上面的）的指定元素。 /*相邻兄弟选择器*/ .example1 + p { background: red; } p标签1 p标签2 p标签3 通用选择器： 选择向下同级（兄弟）的所有指定元素 /*通用兄弟选择器*/ .example1 ~ p { background: green; } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/结构伪类选择器.html":{"url":"web2/结构伪类选择器.html","title":"2.2 结构伪类选择器","keywords":"","body":"2.2 结构伪类选择器 html结构： p1 p2 p3 li1 li2 li3 伪类选择器： 选择元素的第一个子元素： /*ul的第一个子元素*/ ul > li:first-child { background: green; } 选择元素的最后一个子元素： /*ul的最后一个子元素*/ ul > li:last-child { background: green; } nth-child：首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序 /*定位第一个p标签*/ p:nth-child(2) { background: aqua; } :first-of-type：表示一组兄弟元素中其类型的第一个元素 /*选择在父元素中第一个出现的，而不管其在兄弟内的位置如何*/ span:nth-of-type(1){ background: aquamarine; } p1 p2 span p3 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/属性选择器.html":{"url":"web2/属性选择器.html","title":"2.3 属性选择器","keywords":"","body":"2.3 属性选择器 页面结构： 1 2 3 4 5 6 7 8 9 10 属性选择器： 选择a标签中有id属性的元素 /*选择a标签中有id属性的元素*/ a[id]{ background: #c4f1ff; } 选择a标签中id=first的元素 /*选择a标签中id=first的元素*/ a[id=first]{ background: yellow; } 选择a标签中class属性含有links的元素 /*选择a标签中class属性含有links的元素*/ a[class*=\"links\"]{ background: yellowgreen; } 选择a标签中href属性以http开头的元素 /*选择a标签中href属性以http开头的元素*/ a[href^=http]{ background: greenyellow; } 选择a标签中href属性以pdf结尾的元素 /*选择a标签中href属性以pdf结尾的元素*/ a[href$=pdf]{ background: green; } 正则表达式： *= 包含 ^= 开头包含 &= 结尾包含 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/字体和文本样式.html":{"url":"web2/字体和文本样式.html","title":"2.4 字体和文本样式","keywords":"","body":"2.4 字体和文本样式 字体样式： font属性： font 属性可以用来作为font-style, font-variant, font-weight, font-size, line-height 和 font-family属性的简写，或将元素的字体设置为系统字体。 如果 font 字体相关的属性的简写： 必须包含以下值： 可以选择性包含以下值： /*font作为简写所属，必须指定字体和字体大小*/ span[id=example1]{ font: 50px \"LiSong Pro\"; } font-size：字体大小 /*设置字体大小*/ span[id=example1]{ font-size: 50px; } font-weight：指定字体粗细程度，一些字体只提供 normal 和 bold 两种值 /*指定字体的粗细程度*/ span[id=example1] { font-weight: bold; } color：设置字体颜色 /*设置字体颜色*/ span[id=example1] { color: darkred; } line-height：指定行高 /*设置行高*/ span[id=example1] { line-height:60px; } 文本样式： 颜色： 也可以使用rgba(R,G,B,A)函数设置颜色，A指透明度，范围在(0~1) /*设置文本颜色*/ span[id=example1] { color: rgba(169,0,255,0.6); text-align: center; } 文本对齐方式： CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。 /*文本在块父元素内居中*/ div[id=example2]{ text-align: center; } 首行缩进： /*首行缩进两个字符*/ div[id=example2]{ text-indent: 2em; } 行高： 行高和块父元素高度相同则上下居中 /*设置行高*/ div[id=example2]{ line-height: 2; } 下划线 /*给文本添加指定颜色的下划线*/ span[id=example1] { text-decoration:underline red; } /*给文本添加中划线*/ span[id=example1] { text-decoration:line-through; } /*给文本添加上划线*/ span[id=example1] { text-decoration:overline; } 文本阴影 参数：颜色、水平偏移（左右）、垂直偏移（上下）、阴影半径 p>a{ text-decoration: none; color: black; /*颜色、水平偏移（左右）、垂直偏移（上下）、阴影半径*/ text-shadow: aquamarine 5px -3px 5px; } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/超链接伪类.html":{"url":"web2/超链接伪类.html","title":"2.4 超链接伪类","keywords":"","body":"2.4 超链接伪类 鼠标悬浮时:hover /*鼠标悬浮时样式*/ p a:hover{ color: yellowgreen; font-size: 20px; } 鼠标按住未释放时:active /*鼠标按住未释放时的样式*/ p a:active{ color: darkred; } 链接访问过时:visited /*链接被访问过时*/ p a:visited{ color: aquamarine; } 链接没被访问时:link /*链接没被访问时*/ p a:link{ text-decoration: none; color: black; } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/列表样式.html":{"url":"web2/列表样式.html","title":"2.5 列表样式","keywords":"","body":"2.5 列表样式 没有样式的列表： Title 全部商品分类 图书&nbsp;&nbsp;音像&nbsp;&nbsp;数字商品 家用电器&nbsp;&nbsp;手机&nbsp;&nbsp;数码 电脑&nbsp;&nbsp;办公 添加样式： #nav{ width: 260px; background: #c4f1ff; border-radius: 10px; } .title{ font-size: 18px; font-weight: bold; text-indent: 1em; line-height: 3; background: red; color: white; border-radius: 10px; } ul>li{ line-height: 2; /* list-style: none:无样式，去掉点或序号 circle:空心圆 decimal:数字序号 square:正方形 */ list-style: none; text-indent: 1em; } li>a{ text-decoration: none; font-size: 14px; color: black; } li>a:hover{ color: orange; background: white; border-radius: 7px; } 样式属性： border-radius：圆角 font-weight：文本粗细 text-indent：首行缩进（单位一般用em） line-height：行高 list-style：列表样式 text-decoration：none无下划线 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/背景图片及渐变.html":{"url":"web2/背景图片及渐变.html","title":"2.6 背景图片及渐变","keywords":"","body":"2.6 背景图片及渐变 背景图常用属性： /*设置背景图片*/ background-image:url(\"me.jpg\") ; /*图片横向重复*/ background-repeat: repeat-x; /*图片纵向重复*/ background-repeat: repeat-y; /*图片不重复*/ background-repeat: no-repeat; /*背景图大小*/ background-size: 100px; 也可以用background简写属性： 背景颜色、图片、不重复、位置 background: red url(\"me.jpg\") no-repeat 230px; 渐变色背景： https://www.grabient.com/ 通过这个网站选择合适的样式，复制css代码： background-color: #FFFFFF; background-image: linear-gradient(180deg, #FFFFFF 0%, #6284FF 50%, #FF0000 100%); Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/盒子模型及边框使用.html":{"url":"web2/盒子模型及边框使用.html","title":"2.7 盒子模型及边框使用","keywords":"","body":"2.7 盒子模型及边框使用 盒子模型： 最内层蓝色区域就是内容 padding：内边距 border：边框 margin：外边距 任何元素都有边框(border)，从边框到元素内的内容之间的距离叫内边距(padding)，从边框往外延伸的一个距离叫外边距(margin) 边框的样式： 边框的粗细 边框的样式（实线、虚线...） 边框的颜色 代码示例：登陆表单： 会员登录 姓名： 密码： 邮箱： 默认样式： 添加css样式： /*body总有一个8px的外边距*/ body { margin: 0px; } /*选择id=box的div，设置div宽度、边框border样式、背景颜色*/ #box { width: 300px; border: 1px rgb(0, 0, 0); border-radius: 10px; background-color: #8EC5FC; background-image: linear-gradient(62deg, #8EC5FC 0%, #E0C3FC 100%); } /*设置h2标题颜色*/ h2 { color: #2d3436; } /*设置输入框的无边框，有圆角*/ form div input { border: none; border-radius: 5px; } /*设置form表单中div间的行高*/ form > div { line-height: 2; } 添加样式后： 虽然没好看到哪去，但是已经添加了一些样式。 border简写属性： /*边框粗细1px、红色、实线*/ border:1px red solid 也可以分别设置上下左右边框的颜色、粗细、样式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/内外边距及div居中.html":{"url":"web2/内外边距及div居中.html","title":"2.8 内外边距及div居中","keywords":"","body":"2.8 内外边距及div居中 外边距 margin： margin: style /*单值语法 所有边缘 */ 举例： margin: 1em; margin: vertical horizontal /*二值语法 纵向 横向 */ 举例： margin: 5% auto; margin: top horizontal bottom /*三值语法 上 横向 下*/ 举例： margin: 1em auto 2em; margin: top right bottom left /*四值语法 上 右 下 左*/ 举例： margin: 2px 1em 0 auto; 只有一个 值时，这个值会被指定给全部的 四个边. 两个 值时，第一个值被匹配给 上和下, 第二个值被匹配给 左和右. 三个 值时，第一个值被匹配给 上, 第二个值被匹配给 左和右, 第三个值被匹配给 下. 四个 值时，会依次按 上、右、下、左 的顺序匹配 (即顺时针顺序). 使div块居中: div{ margin:0px auto; } 内边距padding： 内边距是元素内容到边框的距离，可以设置上下左右的内边距 CSS可以通过浏览器的开发者工具来调试，实时预览。 盒子的计算方式： 计算盒子具体多大，margin+border+padding+内容 上一节会员登录框样式： /*body总有一个8px的外边距*/ body { margin: 0px; } /*选择id=box的div，设置div宽度、边框border样式、背景颜色*/ #box { width: 300px; height: 150px; border: 1px rgb(0, 0, 0); border-radius: 10px; background-color: #8EC5FC; background-image: linear-gradient(62deg, #8EC5FC 0%, #E0C3FC 100%); /*外边距上下为0px，左右为auto，实现居中*/ margin: 0px auto; } /*设置h2标题颜色*/ h2 { color: #2d3436; /*设置标题居中*/ text-align: center; margin-bottom: 1px; /*标题的内上边距设置10px*/ padding-top: 10px; } /*设置输入框的无边框，有圆角*/ form div input { border: none; border-radius: 5px; } /*设置form表单中div间的行高*/ form > div { line-height: 2; /*div中文本和输入框居中*/ text-align: center; } 样式： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/圆角及阴影.html":{"url":"web2/圆角及阴影.html","title":"2.8 圆角及阴影","keywords":"","body":"2.8 圆角及阴影 圆角边框：border-radius 如果你在 border-radius 属性中只指定一个值，那么将生成 4 个 圆角。 但是，如果你要在四个角上一一指定，可以使用以下规则： 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 一个值： 四个圆角值相同 阴影： box-shadow: h-shadow v-shadow blur spread color inset; 注意：boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。 值 说明 h-shadow 必需的。水平阴影的位置。允许负值 v-shadow 必需的。垂直阴影的位置。允许负值 blur 可选。模糊距离 spread 可选。阴影的大小 color 可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表 inset 可选。从外层的阴影（开始时）改变阴影内侧阴影 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/display和浮动.html":{"url":"web2/display和浮动.html","title":"2.9 display和浮动","keywords":"","body":"2.9 display和浮动 本节内容： display属性 float属性：浮动 父级元素塌陷解决 overflow属性 display属性： Title /* display属性值： block：块（可以把行内元素变成展示成块元素） inline：行内元素（可以把块元素展示成行内元素） inline-block：行内块元素 none：不展示 */ div{ width: 100px; height: 100px; border: 1px black solid; display: inline-block; } span{ width: 100px; height: 100px; border: 1px black solid; display: inline-block; } div块元素 span行内元素 display属性值： block：块（可以把行内元素变成展示成块元素） inline：行内元素（可以把块元素展示成行内元素） inline-block：行内块元素 none：不展示 浮动float： CSS 的 Float（浮动），会使元素向左或向右移动，由于浮动的元素会脱离文档流，所以其周围的元素也会重新排列。 元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动元素之后的元素将围绕它。 浮动元素之前的元素将不会受到影响。 清除浮动 - 使用 clear： 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。 clear 属性指定元素两侧不能出现浮动元素。 属性 描述 值 CSS clear 指定不允许元素周围有浮动元素。 left right both none inherit 1 float 指定一个盒子（元素）是否可以浮动。 left right none inherit 1 CSS1指在css1版本中定义的属性。 父级边框塌陷问题 父级塌陷：父元素的高度是由内部子元素撑起来的，当内部的子元素浮动之后会脱离文档流，所以父元素的高度会塌陷。如果内部的子元素都浮动起来的话，父元素就会如下图一样，只剩下本身内边距的高度。 解决方案： 增加父块元素的高度（不建议使用） 在父块中添加一个空的div，设置margin和padding都为0px，并清除左右浮动 .clear{ margin: 0px; padding: 0px; clear: both; } 页面效果： 给这个空的div添加个边框就可以看出效果，空div清除左右浮动之后，它就会跑到其他浮动元素的下方，这样就会把父级div撑开，并且高度会随着其他元素自动调整。 在父块元素中添加overflow属性 在父块元素添加伪类:after（推荐使用） #father:after{ /*添加空文本*/ content: ''; /*空文本以块元素方式显示*/ display: block; /*清除左右浮动*/ clear: both; } overflow属性： overflow属性指定如果内容溢出一个元素的框，会发生什么。 属性值 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/相对定位的使用.html":{"url":"web2/相对定位的使用.html","title":"2.10 相对定位的使用","keywords":"","body":"2.11 相对定位的使用 定位position属性的四个值：static、relative、absolute、fixed。 绝对定位：absolute 和 fixed 统称为绝对定位 相对定位：relative 默认值：static 相对定位：relative 相对于原来位置移动，元素设置此属性之后仍然处在文档流中，不影响其他元素的布局 设置三个盒子： Title div{ margin: 5px; padding: 3px; font-size: 25px; line-height: 2; } #father{ border:1px black solid; } #first{ border:1px red dashed; } #second{ border:1px yellowgreen dashed; } #third{ border:1px blue dashed; } 第一个盒子 第二个盒子 第三个盒子 让第一个盒子向右下方移动50px： #first{ border:1px red dashed; position: relative; left: 50px; top:50px } 先设置定位方式是【相对定位】，也就是距离原来的位置如何移动，再设置偏移量。 left表示相对于原来左边移动，50px即盒子向右移动50px，如果left=\"-50px\"即盒子向左移动50px top表示相对于原来顶部移动，50px即盒子向下移动50px，如果top=\"-50px\"即盒子向上移动50px right和bottom也是同理，都是距离原来的方向增加或减少偏移量。 注意，元素在使用相对定位时，无论是否偏移，元素仍在文档流中，仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。（而像浮动float的元素会脱离文档流，所以其他元素的位置会重新排列） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/方块定位练习.html":{"url":"web2/方块定位练习.html","title":"2.11 方块定位练习","keywords":"","body":"2.12 方块定位练习 代码： Title div{ margin: 0px; text-align: center; line-height: 100px; } #father{ border: 1px black solid; width: 300px; height: 300px; padding: 10px; } #father>div:nth-child(1){ width: 100px; height: 100px; background: #E0C3FC; } #father>div:nth-child(2){ width: 100px; height: 100px; background: #E0C3FC; position: relative; left: 200px; bottom: 100px; } #father>div:nth-child(3){ width: 100px; height: 100px; background: #E0C3FC; } #father>div:nth-child(4){ width: 100px; height: 100px; background: #E0C3FC; position: relative; left: 200px; bottom: 100px; } #father>div:nth-child(5){ width: 100px; height: 100px; background: #6284FF; position: relative; left: 100px; bottom: 300px; } a{ text-decoration: none; color: #FFFFFF; } 链接1 链接2 链接3 链接4 链接5 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/绝对定位和固定定位.html":{"url":"web2/绝对定位和固定定位.html","title":"2.12 绝对定位和固定定位","keywords":"","body":"2.13 绝对定位和固定定位 绝对定位：absolute absolute:元素会脱离文档流，如果设置偏移量，会影响其他元素的位置定位 使用绝对定位的元素会脱离文档流，不会占据原来的位置，所以其他文档流内的元素会重新排列位置。 absolute定位原理剖析： 在父元素没有设置相对定位或绝对定位的情况下，元素相对于根元素定位（即html元素）（是父元素没有）。 父元素设置了相对定位或绝对定位，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位（或者说离自己最近的不是static的父元素进行定位，因为元素默认是static）。 会相对离自己最近的设置了相对或绝对定位的父元素进行定位。 固定定位：fixed 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动. 通过设置距离浏览器的上下左右设置元素的固定位置。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/z-index及透明度.html":{"url":"web2/z-index及透明度.html","title":"2.13 z-index及透明度","keywords":"","body":"2.14 z-index及透明度 页面效果： z-index属性： z-index 属性指定一个元素的堆叠顺序。 拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 属性值 值 描述 auto 默认。堆叠顺序与父元素相等。 number 设置元素的堆叠顺序。 inherit 规定应该从父元素继承 z-index 属性的值。 opacity属性： 所有主流浏览器都支持opacity属性。. 注意：IE8和早期版本支持另一种过滤器属性。像：filter:Alpha(opacity=50) 属性值 值 描述 value 指定不透明度。从0.0（完全透明）到1.0（完全不透明） inherit Opacity属性的值应该从父元素继承 代码： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/css实现动画.html":{"url":"web2/css实现动画.html","title":"2.14 css实现动画","keywords":"","body":"2.14 css实现动画 css可以实现动画效果，这里不需要掌握 也可以了解一下js中的canvas动画 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web2/总结.html":{"url":"web2/总结.html","title":"2.15 css总结（思维导图）","keywords":"","body":"2.15 css总结（思维导图） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web3/javascript.html":{"url":"web3/javascript.html","title":"3. JavaScript基础","keywords":"","body":"3. JavaScript基础 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web4/htmldom.html":{"url":"web4/htmldom.html","title":"4. HTML DOM","keywords":"","body":"4. HTML DOM Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web5/ajax.html":{"url":"web5/ajax.html","title":"5. Ajax","keywords":"","body":"5. Ajax Asynchronous JavaScript + XML（异步JavaScript和XML） 同步：必须等待前面的任务完成，才能继续后面的任务 异步：不受当前任务的影响 XMLHttpRequest XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。 构造函数： XMLHttpRequest() 该构造函数用于初始化一个 XMLHttpRequest 实例对象。在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。 使用Ajax发送请求 AJAX的核心js对象就是XMLHttpRequest，发送Ajax请求的五个步骤： 创建异步对象XMLHttpRequest，var req = new XMLHttpRequest(); 设置请求的参数req.open(\"POST\", url, true);包括请求方式，URL，是否是异步 发送请求，req.send(null);，可以发送数据，也可以不发 注册时间，req.onreadystatechange，当状态有改变时调用 获取返回的数据 代码： Ajax Demo 用户名： let url = \"TestServlet\"; var req; function onChangeShow() { if (window.XMLHttpRequest) { req = new XMLHttpRequest(); } else { req = new ActiveXObject(); } if (req) { req.open(\"POST\", url, true); req.onreadystatechange = function () { if (req.readyState == 4) { if (req.status == 200) { parseMessageByText(); } else { alert(\"请求失败\") } } }; req.send(null); } } function parseMessageByText() { document.getElementById(\"name\").value = req.responseText; } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web6/json.html":{"url":"web6/json.html","title":"6. JSON","keywords":"","body":"6. JSON JSON的数据格式： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web6/fastjson.html":{"url":"web6/fastjson.html","title":"6.1 FastJson","keywords":"","body":"6.1 FastJson fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。 Java对象序列化成JSON格式字符串： String text = JSON.toJSONString(obj); //序列化 JSON格式字符串反序列化成Java对象： VO vo = JSON.parseObject(\"{...}\", VO.class); //反序列化 JSON对象转成Java对象： User user = JSON.toJavaObject(jsonObject, User.class); 代码示例： 定义JavaBean： public class User { private int id; private String name; private int age; private String dateOfBirth; public User() { } public User(int id, String name, int age, String dateOfBirth) { this.id = id; this.name = name; this.age = age; this.dateOfBirth = dateOfBirth; } //此处省略getter/setter方法、toString方法 } JavaBean转换为Json格式字符串 使用JSON.toJSONString(JavaBean)方法： package com.neu.json; import com.alibaba.fastjson.JSON; import com.neu.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.util.ArrayList; import java.util.List; public class JsonDemo { private static ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); public static void main(String[] args) { User user1 = context.getBean(\"user1\", User.class); User user2 = context.getBean(\"user2\", User.class); List list = new ArrayList(); list.add(user1); list.add(user2); //将Java对象转换为Json格式字符串 String s = JSON.toJSONString(user1); String s1 = JSON.toJSONString(list); System.out.println(\"JavaBean转换为String：\" + s); System.out.println(\"封装JavaBean的列表转换为String：\" + s1); } } 结果： JavaBean转换为String：{\"age\":25,\"dateOfBirth\":\"1995-2-6\",\"id\":1001,\"name\":\"张三\"} 封装JavaBean的列表转换为String：[{\"age\":25,\"dateOfBirth\":\"1995-2-6\",\"id\":1001,\"name\":\"张三\"},{\"age\":26,\"dateOfBirth\":\"1994-7-16\",\"id\":1002,\"name\":\"李四\"}] 将Json格式字符串转为JavaBean 使用JSON.parseObject(String str, Class)方法： //Json格式字符串解析成JavaBean String str = \"{\\\"age\\\":25,\\\"dateOfBirth\\\":\\\"1995-2-6\\\",\\\"id\\\":1004,\\\"name\\\":\\\"小张\\\"}\"; User user3 = JSON.parseObject(str, User.class); System.out.println(user3); 结果： User{id=1004, name='小张', age=25, dateOfBirth='1995-2-6'} 将JSONObject对象转为JavaBean 使用JSON.toJavaObject(Json json, Class);方法： Map map = new HashMap(); map.put(\"id\", 1003); map.put(\"name\", \"小野\"); map.put(\"age\", 27); map.put(\"dateOfBirth\", \"1993-5-7\"); //JSONObject中有一个带参构造可以传入map JSONObject json = new JSONObject(map); User user = JSON.toJavaObject(json, User.class); System.out.println(user); 结果： User{id=1003, name='小野', age=27, dateOfBirth='1993-5-7'} Servlet中request获取JSON对象 var vm = new Vue({ el: '#app', data: { username: '', password: '', }, methods: { login: function () { this.$http.post(\"./ServletDemo\", { username: this.username, password: this.password }).then(function (res) { console.log(res.body) }, function () { console.log(\"请求失败\") }) } } }) 获取前端请求的JSON数据： //把接收到的request请求数据放到BufferedReader中 BufferedReader streamReader = new BufferedReader(new InputStreamReader(request.getInputStream(), \"UTF-8\")); //读取缓冲区数据到字符串 String str = streamReader.readLine(); //将字符串解析成Json对象 JSONObject paramsObj = JSONObject.parseObject(str); 得到paramsObj之后，就可以像操作Map一样获取JSON中的数据了。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web7/jquery.html":{"url":"web7/jquery.html","title":"7. JQuery","keywords":"","body":"6. JQuery Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web8/bootstrap.html":{"url":"web8/bootstrap.html","title":"8. BootStrap","keywords":"","body":"7. BootStrap Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/vuejs.html":{"url":"web9/vuejs.html","title":"9. Vue.js","keywords":"","body":"1. Vue.js Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 引入Vue 或者： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/创建一个Vue实例.html":{"url":"web9/创建一个Vue实例.html","title":"创建一个Vue实例","keywords":"","body":"9.1 创建一个Vue实例 创建一个Vue实例 每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： var vm = new Vue({ // 选项 }) 当创建一个 Vue 实例时，你可以传入一个选项对象。 作为参考，可以在 API 文档中浏览完整的选项列表。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/数据与方法.html":{"url":"web9/数据与方法.html","title":"数据与方法","keywords":"","body":"9.2 数据与方法 当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 //我们的数据对象 var data = {a: 1} //将data对象加入到Vue实例中 var vm = new Vue({ data: data }) vm.a == data.a //=>true vm.a = 2 data.a //=>2 data.a = 3 vm.a //=>3 当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。 例如在Vue实例后加入一个属性： data.b = 3 //或者 vm.b = 3 则b的改动将不会触发任何视图的更新。 如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如： data: { newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null } Object.freeze()会阻止修改现有的属性，也就意味着响应系统无法在追踪到变化 var obj = { foo: 'bar' } Object.freeze(obj) //将data对象加入到Vue实例中 var vm = new Vue({ el: '#app', data: obj }) {{ foo }} Change it 当点击页面按钮之后，本应该在视图显示修改后的baz，由于加入了Object.freeze()，则视图不会发生改变。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/实例生命周期钩子.html":{"url":"web9/实例生命周期钩子.html","title":"实例生命周期钩子","keywords":"","body":"9.3 实例生命周期钩子 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 beforeCreate 组件状态： 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据。 常用于初始化非响应式变量。 /** *在实例初始化之后，数据观测(data observer)和event/watcher事件配置之前被调用 */ beforeCreate: function () { console.log(\"beforeCreate\") }, created 组件状态： 实例创建完成，可以访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组。 常用于简单的ajax请求，页面的初始化。 /** * 在实例创建完成之后被立即调用 * 在这一步，实例已完成以下配置：数据观测(data observer)，属性和方法的运算，watch/event事件回调 * 然而，挂载阶段还没开始，$el属性目前不可见 */ created: function () { console.log(\"created\") }, beforeMount 组件状态： 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 /** * 在挂载开始之前被调用：相关的渲染函数首次被调用 */ beforeMount: function () { console.log(\"beforeMount\") }, mounted 组件状态： 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 常用语获取VNode信息和操作，ajax请求 /** * el被新创建的vm.$el替换，挂载成功 */ mounted: function () { console.log(\"mounted\") }, beforeUpdate 组件状态： 响应式数据更新时调用，发生在虚拟DOM打补丁之前 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 /** * 数据更新时被调用 */ beforeUpdate: function () { console.log(\"beforeUpdate\") }, updated 组件状态： 虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 避免在这个钩子函数中操作数据，可能陷入死循环 /** * 组件DOM已经更新，组件更新完毕 */ updated: function () { console.log(\"updated\") } beforeDestroy 组件状态： 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 常用于销毁定时器、解绑全局事件、销毁插件对象等操作 destroyed 组件状态： 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 参见官方API：选项 / 生命周期钩子) 总结： Vue示例生命周期四个阶段： 创建 挂载 更新 销毁 每个阶段分别有两个钩子函数，分别对应四个阶段的前和后 代码示例： #box { width: 100px; height: 100px; background-color: red; } 输入： 信息显示: {{msg}} var vm = new Vue({ el: '#app', data: { msg: '初始值', }, /** * Vue实例初始化后，this指向当前实例，不能访问到data、methods...数据 */ beforeCreate() { console.log(\"beforeCreate被执行了~，msg：\" + this.msg) }, /** * Vue实例初始化完成，可以访问到data、methods中的数据和方法，此时还有没挂载真实DOM */ created() { console.log(\"created被执行了~，msg：\" + this.msg) }, /** * Vue实例挂载到真实DOM之前 */ beforeMount() { var el = document.getElementById(\"res\").innerHTML console.log(\"beforeMount被调用了~，挂载之前：span：\" + el) }, /** * Vue实例挂载到真实DOM上，挂载完成 */ mounted() { var el = document.getElementById(\"res\").innerHTML console.log(\"mounted被调用了~，挂载完成，span：\" + el) }, /** * 响应数据更新时调用，响应数据更新到真实DOM之前 */ beforeUpdate() { console.log(\"beforeUpdate被调用了~，msg：\" + this.msg) }, /** * 实例中的响应数据更新到真实DOM上 */ updated() { console.log(\"updated被调用了~，msg：\" + this.msg) }, /** *Vue实例销毁前之前，此时实例可用 */ beforeDestroy() { console.log(\"beforeDestroy被调用了~Vue实例销毁前~\") }, /** * Vue实例销毁后执行 */ destroyed() { console.log(\"destroyed被调用了~Vue实例已经销毁~\") } }) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/Vue指令.html":{"url":"web9/Vue指令.html","title":"Vue指令","keywords":"","body":"Vue指令 v-text 预期：string 详细： 更新元素的 textContent。如果要更新部分的 textContent，需要使用 `` 插值。 示例： 参考：数据绑定语法 - 插值 v-html 预期：string 详细： 更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 元素手动设置类似 BEM 的作用域策略。 示例： 参考：数据绑定语法 - 插值 v-show 预期：any 用法： 根据表达式之真假值，切换元素的 display CSS property。 当条件变化时该指令触发过渡效果。 参考：条件渲染 - v-show v-if 预期：any 用法： 根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 ，将提出它的内容作为条件块。 当条件变化时该指令触发过渡效果。 当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。详见列表渲染教程 参考：条件渲染 - v-if v-else 不需要表达式 限制：前一兄弟元素必须有 v-if 或 v-else-if。 用法： 为 v-if 或者 v-else-if 添加“else 块”。 0.5\"> Now you see me Now you don't 参考：条件渲染 - v-else v-else-if 2.1.0 新增 类型：any 限制：前一兄弟元素必须有 v-if 或 v-else-if。 用法： 表示 v-if 的“else if 块”。可以链式调用。 A B C Not A/B/C 参考：条件渲染 - v-else-if v-for 预期：Array | Object | number | string | Iterable (2.6 新增) 用法： 基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 alias in expression，为当前遍历的元素提供别名： 另外也可以为数组索引指定别名 (或者用于对象的键)： v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示： 从 2.6 起，v-for 也可以在实现了可迭代协议的值上使用，包括原生的 Map 和 Set。不过应该注意的是 Vue 2.x 目前并不支持可响应的 Map 和 Set 值，所以无法自动探测变更。 当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。详见列表渲染教程 v-for 的详细用法可以通过以下链接查看教程详细说明。 参考： 列表渲染 key v-on 缩写：@ 预期：Function | Inline Statement | Object 参数：event 修饰符： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 用法： 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。 用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。 在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event property：v-on:click=\"handle('ok', $event)\"。 从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。 示例： 在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)： 参考： 事件处理器 组件 - 自定义事件 v-bind 缩写：: 预期：any (with argument) | Object (without argument) 参数：attrOrProp (optional) 修饰符： .prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 用法： 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。 在绑定 class 或 style attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。 示例： .camel 修饰符允许在使用 DOM 模板时将 v-bind property 名称驼峰化，例如 SVG 的 viewBox property： 在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。 参考： Class 与 Style 绑定 组件 - Props 组件 - .sync 修饰符 v-model 预期：随表单控件类型不同而不同。 限制： components 修饰符： .lazy - 取代 input 监听 change 事件 .number - 输入字符串转为有效的数字 .trim - 输入首尾空格过滤 用法： 在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。 参考： 表单控件绑定 组件 - 在输入组件上使用自定义事件 v-slot 缩写：# 预期：可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。 参数：插槽名 (可选，默认值是 default) 限用于 组件 (对于一个单独的带 prop 的默认插槽) 用法： 提供具名插槽或需要接收 prop 的插槽。 示例： Header content Default slot content Footer content Mouse position: , 更多细节请查阅以下链接。 参考： 组件 - 插槽 RFC-0001 v-pre 不需要表达式 用法： 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 示例： 这里用插值的话会原样显示 v-cloak 不需要表达式 用法： 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 示例： [v-cloak] { display: none; } 不会显示，直到编译结束。 v-once 不需要表达式 详细： 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 This will never change: comment 参考： 数据绑定语法- 插值 组件 - 对低开销的静态组件使用 v-once Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/计算属性.html":{"url":"web9/计算属性.html","title":"计算属性","keywords":"","body":"计算属性 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/监听器.html":{"url":"web9/监听器.html","title":"监听器","keywords":"","body":"监听器 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 实例代码： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/过滤器.html":{"url":"web9/过滤器.html","title":"过滤器","keywords":"","body":"过滤器 Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。 过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。 过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： {{ message | capitalize }} 你可以在一个组件的选项中定义本地的过滤器： filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } 或者在创建 Vue 实例之前全局定义过滤器： Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) new Vue({ // ... }) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 示例： 局部过滤器： 全局过滤器： 注意： 全局过滤器要定义在new Vue()实例之前 如果全局过滤器和局部过滤器同名，会调用局部过滤器 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/自定义指令.html":{"url":"web9/自定义指令.html","title":"自定义指令","keywords":"","body":"自定义指令 自定义指令可以在Vue示例中定义（局部指令），也可以定义全局指令 // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 或者： directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 然后你可以在模板中任何元素上使用新的 v-focus property，如下： 钩子函数： 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数中的参数 el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注意：除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 示例： 注意： 如果自定义的全局指令和局部指令同名，则在调用时会调用局部指令 定义的指令不支持驼峰式写法，所以指令命名统一变为小写,或者用用-或_分割要使用自定义的指令 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/vue-resource.html":{"url":"web9/vue-resource.html","title":"Vue.js Ajax(vue-resource)","keywords":"","body":"Vue.js Ajax(vue-resource) Vue2.0之后已经不推荐使用vue-resource了 引入vue-resource库： 语法和API： 可以使用全局对象Vue.http或者在一个Vue实例内部使用this.$http来发起HTTP请求 // 基于全局Vue对象使用http Vue.http.get('/someUrl', [options]).then(successCallback, errorCallback); Vue.http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); // 在一个Vue实例内使用$http this.$http.get('/someUrl', [options]).then(successCallback, errorCallback); this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); vue-resource提供了7中请求API（REST风格）： get(url, [options]) head(url, [options]) delete(url, [options]) jsonp(url, [options]) post(url, [body], [options]) put(url, [body], [options]) patch(url, [body], [options]) 除了 jsonp 以外，另外 6 种的 API 名称是标准的 HTTP 方法。 options 参数说明: 参数 类型 描述 url string 请求的目标URL body Object, FormData, string 作为请求体发送的数据 headers Object 作为请求头部发送的头部对象 params Object 作为URL参数的参数对象 method string HTTP方法 (例如GET，POST，...) timeout number 请求超时（单位：毫秒） (0表示永不超时) before function(request) 在请求发送之前修改请求的回调函数 progress function(event) 用于处理上传进度的回调函数 ProgressEvent credentials boolean 是否需要出示用于跨站点请求的凭据 emulateHTTP boolean 是否需要通过设置X-HTTP-Method-Override头部并且以传统POST方式发送PUT，PATCH和DELETE请求。 emulateJSON boolean 设置请求体的类型为application/x-www-form-urlencoded 通过如下属性和方法处理一个请求获取到的响应对象： 属性 类型 描述 url string 响应的 URL 源 body Object, Blob, string 响应体数据 headers Header 请求头部对象 ok boolean 当 HTTP 响应码为 200 到 299 之间的数值时该值为 true status number HTTP 响应码 statusText string HTTP 响应状态 方法 类型 描述 text() 约定值 以字符串方式返回响应体 json() 约定值 以格式化后的 json 对象方式返回响应体 blob() 约定值 以二进制 Blob 对象方式返回响应体 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/axios.html":{"url":"web9/axios.html","title":"Vue.js Axios","keywords":"","body":"Vue.js Axios axios是一个开源的可以用在浏览器和NodeJS的异步通信框架，它的主要作用是ajax异步通信，其功能特点如下： 在浏览器中创建XMLHttpRequest 从node.js创建http请求 支持Promise API [JS中链式编程] 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON 客户端支持防御XSRF（跨站请求伪造） var vm = new Vue({ el: '#app', data: { items: [\"java\", \"Linux\", \"前端\"], }, data(){ return{ info:{ name:null, age:null, } } }, mounted() { axios.get(\"./json/data.json\").then(res => (this.info=res.data), res => (alert(\"请求失败\"))) } }) 在Vue项目中引入 安装axios依赖 import axios from 'axios' Vue.prototype.$http = axios mounted() { axios.get(\"./json/data.json\").then(res => (this.info=res.data), res => (alert(\"请求失败\"))) } 具体的使用方式和vue-resource非常类似 axios常用请求方法： get: 一般用于获取数据 post: 提交数据（表单提交、文件上传...） put: 更新数据（所有数据都推送到服务端） patch: 更新数据（只将修改的数据推送到服务端） delete: 删除数据 GET请求： 第一种写法： // 请求地址：http://localhost:8080/data.json?id=1 axios.get('/data.json',{params:{id:1}}).then(res => { console.log(res) }) 第二种写法： axios({ method: 'get', url: '/data.json', params: {id:2} }).then(res =>{ console.log(res) }) POST请求： 提交参数的两种格式： form-data 表单提交（图片上传，文件上传） application/json application/json格式： let data = {id: 12} axios.post('/post', data).then(res => { console.log(res) }) 或者： let data = {id: 12} axios({ method: 'post', url: '/post', data: data }).then(res => { console.log(res) }) 请求头：Content-Type: application/json;charset=UTF-8 form-data格式数据： let data = {id: 12} // form-data请求 // 实例化form-data格式数据，将数据从data对象中遍历出来放到formData中 let formData = new FormData() for(let key in data){ formData.append(key, data[key]) } axios.post('/post',formData).then(res =>{ console.log(res) }) 请求头：Content-Type: multipart/form-data; PUT/PATCH请求： 提交参数的两种格式： form-data 表单提交（图片上传，文件上传） application/json // put请求 axios.put('/put',data).then(res =>{ console.log(res) }) // patch请求 axios.patch('/patch',data).then(res =>{ console.log(res) }) 第二种写法同上。 DELETE请求： delete请求和get请求一样，axios.delete(url,config)两个参数 // 参数拼接在url上 axios.delete('/delete',{params:{id:13}}).then(res =>{ console.log(res) }) // 参数不拼接在url上 axios.delete('/delete',{data:{id:123}}).then(res =>{ console.log(res) }) 并发请求： 同时进行多个请求，并统一处理返回值 //axios.all()并发请求， axios.spread()处理响应 axios.all([ axios.get('/data.json'), axios.get('/city.json') ]).then( axios.spread((dataRes,cityRes)=>{ console.log(dataRes,cityRes) }) ) Axios创建实例： 如果需要访问不同的后端域名接口，可以创建多个axios实例，每个实例绑定不同的域名和其他配置： // axios可以创建多个实例，每个实例绑定不同的请求域名或配置 let instance1 = axios.create({ baseURL: 'http://localhost:8080', timeout: 1000 }) let instance2 = axios.create({ baseURL: 'http://localhost:9090', timeout: 5000 }) instance1.get('/data.json').then(response => { console.log(response) }) instance2.get('/data.json').then(response => { console.log(response) }) axios常用配置参数： axios.create({ baseURL: 'http://localhost:8080',// 请求的基本地址 timeout: 1000,// 设置请求超时时长ms url: '/data.json',// 请求的资源路径 method: 'get,post,put,patch,delete',// 请求方法 headers: { token: '123asd' },// 设置请求头 params: {},// 会将请求参数拼接到url中 data: {},// 请求参数在请求体中 }) 都在哪里可以配置axios的参数： // 1. axios全局配置 axios.defaults.timeout = 1000 axios.defaults.baseURL = 'http://localhost' // 2. axios实例配置 let instance = axios.create({ baseURL: 'http://localhost:8080', }) instance.defaults.timeout = 2000 // 3. axios请求配置 instance.get('/data.json', {timeout: 5000, params: {id: 1}}) 优先级从低到高 全局 拦截器： 请求拦截器：（请求没到后端，如404） // 请求拦截器 axios.interceptors.request.use(config => { // 在发送请求前doSomething return config }, error => { // 在请求错误时doSomething return Promise.reject(error) }) 响应拦截器：（请求到达后端） // 响应拦截器 axios.interceptors.response.use(res => { // 请求成功后，对响应数据做处理 return res }, error => { // 响应错误，对响应数据做处理 return Promise.reject(error) }) 拦截器中return的数据都到哪了？ axios.get('/data.json') .then(res => { // 响应拦截器，return的res就返回到这里 console.log(res) }).catch(err => { // 响应拦截器中，return Promise.reject(error)就返回到这里 console.log(err) }) 取消拦截器： // 取消拦截器（了解） let interceptor = axios.interceptors.request.use(config=>{ config.headers = {auth:true} return config }) // 取消定义的拦截器 axios.interceptors.request.eject(interceptor) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/vue组件.html":{"url":"web9/vue组件.html","title":"vue组件","keywords":"","body":"vue组件 定义组件component： JavaScript： //定义组件 Vue.component('liyan',{ props:['item'], template:'{{item}}' }) var vm = new Vue({ el:'#app', data:{ items:[\"java\",\"Linux\",\"前端\"] } }) HTML： Vue全局对象.component()创建组件 component()需要传递两个参数，一个是组件名，一个是属性对象 属性对象中有两个属性： props：用于绑定数据 template：模板 在div中，使用自定义的组件标签循环tiems数组，通过v-bind绑定组件中的props属性，把循环的每一个值传进来 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/slot插槽.html":{"url":"web9/slot插槽.html","title":"slot插槽","keywords":"","body":"slot插槽：内容分发 代码示例： Title Vue.component('todo', { //slot用来定义插槽 template: '' +//slot通过name属性绑定要插入的组件 '' + '' + '' + '' + '' }) Vue.component('todo-title', { props: ['title'], template: '{{title}}' }) Vue.component('todo-items', { props: ['item'], template: '{{item}}' }) var vm = new Vue({ el: '#app', data: { title:'Java技术', todoItems:['JavaSE','Spring','SpringMVC','Mybatis'] }, }) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/自定义事件.html":{"url":"web9/自定义事件.html","title":"自定义事件","keywords":"","body":"自定义事件 代码示例：this.$emit('remove',index) 事件名称,参数 Title Vue.component('todo', { //slot用来定义插槽 template: '' +//slot通过name属性绑定要插入的组件 '' + '' + '' + '' + '' }) Vue.component('todo-title', { props: ['title'], template: '{{title}}' }) Vue.component('todo-items', { props: ['item','index'], template: '{{index}}---{{item}} 删除', methods:{ remove(index){ this.$emit('remove',index) } } }) var vm = new Vue({ el: '#app', data: { title:'Java技术', todoItems:['JavaSE','Spring','SpringMVC','Mybatis'] }, methods: { removeItem(index){ this.todoItems.splice(index,1) } } }) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web9/vue-cli.html":{"url":"web9/vue-cli.html","title":"vue-cli脚手架","keywords":"","body":"vue-cli脚手架 什么是CLI ？ 命令行界面(command-line interface)，缩写成CLI，是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令之后，予以执行。也有人称其为字符用户界面CUI 什么是Vue-CLI ？ Vue CLI是一个机遇Vue.js进行快速开发的完整系统。使用Vue脚手架之后，我们开发的页面将是一个完整的系统（项目），而不是单单的页面了。 通过 @vue/cli 实现的交互式的项目脚手架。之前需要使用bootstrap JQuery等都需要下载引入这些库，而现在只需要通过命令就可以下载相关依赖 通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置；webpack：项目打包工具，编译好的项目源码===》部署到服务器上 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 安装Vue-Cli 安装Vue-Cli： npm install -g @vue/cli 查看版本： vue --version 创建Vue项目 进入到要创建项目的目录，通过vue create创建项目（项目名使用中划线或者下划线连接）,然后根据提示选择配置进行创建Vue项目: vue create projectname 终端指令：图形化快速创建构建项目： vue ui 或者，通过webstorm等IDE构建vue项目 通过npm运行项目 终端进入项目目录，通过npm run serve命令运行项目 Windows 平台命令：npm run dev Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web10/nodejs.html":{"url":"web10/nodejs.html","title":"10. Node.js","keywords":"","body":"9. Node.js Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"web10/nvm-Node版本管理工具.html":{"url":"web10/nvm-Node版本管理工具.html","title":"nvm Node版本管理工具","keywords":"","body":"nvm Node版本管理工具 官方地址：https://github.com/nvm-sh/nvm 安装 在终端输入命令： curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash 安装好后，在.bash_profile中添加环境变量： export NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm 环境变量添加完成后，source ~/.bash_profile使配置文件生效。 查看nvm版本： nvm -version 常用命令: 下载、编译安装最新版本的node： nvm install node # \"node\" is an alias for the latest version 安装指定版本node： nvm install 6.14.4 # or 10.10.0, 8.9.1, etc 查看远程所有版本：(会罗列出node的所有版本，通过上面命令就可以安装指定版本) nvm ls-remote 选择使用本地的版本：（如果本地安装多个版本，可以在不同版本间切换） nvm use node 更多命令参见官方文档 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"xml1/xml入门.html":{"url":"xml1/xml入门.html","title":"XML入门","keywords":"","body":"XML入门 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/JavaEE.html":{"url":"javaee1/JavaEE.html","title":"1. JavaEE","keywords":"","body":"JavaEE Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/tomcat.html":{"url":"javaee1/tomcat.html","title":"Tomcat","keywords":"","body":"Tomcat 文件结构： bin：Tomcat启动文件目录 conf：依赖jar包 logs：日志文件 temp：临时文件 webapps：Tomcat运行项目文件 work：Tomcat运行之后存放数据 IDEA配置Tomcat： 注意：web项目的依赖要放到web-->WEB-INF-->lib下（WEB-INF文件夹没有需自己创建，文件夹名称不能出错，否则会出问题） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/Servlet.html":{"url":"javaee1/Servlet.html","title":"Servlet","keywords":"","body":"24.Servlet 概念：Servlet：server applet * Servlet是一个接口，定义了Java类能被浏览器访问到(Tomcat识别)的规则。 * 我们自定义一个类，实现Servlet接口，重写方法。 快速入门： 创建JavaEE（Web项目）项目 定义一个类，实现Servlet接口，实现接口中的方法 public class ServletDemo1 implements Servlet{ //实现Servlet接口的方法 } 配置Servlet：配置web.xml文件 下面的标签写在web-app标签内 demo1 cn.itcast.web.servlet.ServletDemo1 demo1 /demo1 执行原理： 1. 当服务器接收到客户端浏览器的请求后，会解析这个请求的URL路径，获取要访问的Servlet的资源路径 2. Tomcat会查找web.xml文件是否有对应的标签内容 3. 如果有，则再找到对应的的类 4. 找到对应类后，Tomcat会将其字节码文件加载进内存，创建其对象 5. 然后调用方法 Servlet中的生命周期(方法)： 被创建：执行init()方法，只执行一次。一般用于加载资源 - Servlet什么时候被创建？ 1. 默认情况下，第一次被访问时，Servlet被创建 2. 还可以配置执行Servlet的创建时机(配置web.xml文件) 在标签下： 1.第一次被访问时创建： 标签值为负数，则第一次访问时被创建。（该标签默认值为-1） 2.在服务器启动时创建： 标签值配置成0或正整数 - Servlet的init()方法，只执行一次，说明一个Servlet在内存中只存在一个对象，说明Servlet是单例的。 - 多个用户同时访问时，可能存在线程安全问题 - 解决： 尽量不要在Servlet中定义成员变量，即是定义了成员变量，也不要对其修改值。 提供服务：执行service()方法，Servlet每次被访问时，都会被执行 - 每次访问Servlet时，service()方法都会被调用一次。 被销毁：执行destroy()方法，只执行一次 - Servlet被销毁时执行。服务器关闭时，Servlet被销毁 - 只有服务器正常关闭时，才会执行destroy()方法 - destroy()在Servlet销毁之前执行，一般用于释放资源。 Servlet 3.0 : 好处： ​ 支持注解配置。可以不需要web.xml了。 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口，实现Servlet接口方法 在类上使用@WebServlet注解，进行配置 @WebServlet(urlPatterns = \"/demo1\") 或@WebServlet(\"/demo1\") IDEA与Tomcat的相关配置： IDEA会为每一个Tomcat部署的项目，单独建立一份儿配置文件 查看控制台log日志CATALINA_BASE: /Users/liyan/Library/...... 工作空间项目和Tomcat部署的web项目是两个路径 Tomcat真正访问的是\"Tomcat部署的web项目\"，它对应着工作空间下web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 断点调试：通过debug启动 Servlet体系结构： 实现类： Servlet 接口 GenericServlet 抽象类：将Servlet接口中其他的方法做了空实现，只将service()方法作为抽象，之后定义Servlet类时，可以继承GenericServlet类，实现service()方法即可。 HttpServlet 抽象类 定义一个类，继承HttpServlet类 重写doGet()、doPost()方法 ​ Servlet相关配置： urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径 @WebServlet({\"/d4\",\"/dd4\",\"/ddd4\"}) 路径定义规则： /xxx /xxx/xxx ：多层路径，目录结构 *.do Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/使用STS创建Web项目.html":{"url":"javaee1/使用STS创建Web项目.html","title":"使用STS创建Web项目","keywords":"","body":"使用STS创建Web项目 New-->Other-->Dynamic Web Project 新建动态的Web项目 新建动态项目，定义项目名，以及相关环境配置 Dynamic web module version中，3.0版本之前不支持注解开发 Next-->设置class文件输出路径 Next-->设置root目录 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/HTTP协议.html":{"url":"javaee1/HTTP协议.html","title":"HTTP协议","keywords":"","body":"HTTP协议 基本概念： Hyper Test Transfer Protocol 超文本传输协议 传输协议：定义了客户端与服务端通信时，发送数据的格式 http协议特点： 1.基于TCP/IP的高级协议 2. 默认端口号：80 3. 基于请求/响应模型，一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每一次请求响应都会建立新的连接 1.1：每一次请求响应会复用连接 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/Request.html":{"url":"javaee1/Request.html","title":"Request","keywords":"","body":"Request Request请求消息分四个部分： 请求行： 请求头： 请求空行：起分割作用 请求体：通过POST方式请求时，请求体中包含请求参数 各个部分说明： 1. 请求行： 请求行格式： 请求方式/请求url 请求协议/版本 如：GET /day14/demo3?username=liyan HTTP/1.1 请求方式： HTTP协议有7中请求方式，常用的有两种: GET： 请求参数在请求行中，如：GET /day14/demo3?username=liyan HTTP/1.1 请求的URL长度是有限制的 GET请求不太安全 POST： 请求参数在请求体中，如：username=liyan 请求的URL长度没有限制 POST请求相对安全 2. 请求头：（浏览器告诉服务器的一些信息） 请求头格式：请求头名称:值,值,值... Host：主机 User-Agent：浏览器告诉服务器，我访问你使用的浏览器的版本信息 可以在服务器端获取该头信息，来解决浏览器的兼容性问题 Referer：http://localhost:8080/login.html 告诉服务器，当前请求从哪里来 防盗链 统计来源 ... ... 图示： 3. 请求空行： 请求空行就是一个空行，起分割作用 4. 请求体（请求正文）：封装POST请求消息的请求体的 GET请求：没有请求体； POST请求：请求体中包含请求参数，如：username=liyan 图示：（在页面上写了两个输入框用来提交用户名和密码） Servlet中的Request对象： request对象和response对象的原理： request和response是由Tomcat服务器创建的，我们来使用； request对象是来获取请求消息的，response是来设置响应消息的。 request对象继承结构： Interface ServletRequest：是一个接口 Interface HttpServletRequest：继承自ServletRequest org.apache.catalina.connector.RequestFacade：HttpServletRequest的实现类(Tomcat实现) request获取功能：(获取请求数据) 1. 获取请求行数据：请求行数据的格式 (GET /day14/demo3?username=liyan HTTP/1.1) 获取请求方式：String getMethod(); 获取虚拟目录：String getContextPath(); 获取Servlet路径：String getServletPath(); 获取get方式请求参数：String getQueryString(); 获取请求URI：String getRequestURI(); 获取请求URL：StringBuffer getRequestRUL(); URI:统一资源标识符 URL:统一资源定位符 获取连接协议和版本：String getProtocol(); 获取客户机IP地址：String getRemoteAddr(); 2. 获取请求头数据： String getHeader(String name); 通过请求头的名称获取请求头的值 Enumeration getHeaderNames(); 获取所有请求头的名称 Enumeration names = request.getHeaderNames(); while (names.hasMoreElements()) { String s = names.nextElement(); System.out.println(s + \"为：\" + request.getHeader(s)); } 3. 获取请求体数据： 只有POST请求方式才有请求体，请求体中封装了POST请求的请求参数，获取步骤： 获取流对象： BufferedReader getReader(); 获取字符输入流，只能操作字符数据。 BufferedReader对象可以通过调用readLine()方法返回字符串。 ServletInputStream getInputStream(); 获取字节输入流，可以操作所有类型的数据 在从流对象中拿数据： BufferedReader bufferedReader = request.getReader(); String line = null; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } Request其他功能： 1. 获取请求参数(GET/POST通用方法)： 1. String getParameter(String name); 根据参数名称获取参数值 2. String[] getParameterValues(String name); 根据参数名称获取参数值的数组 3. Enumeration getParameterName(); 获取所有请求参数的名称 4. Map getParameterMap();获取所有桉树的map集合 代码示例： import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Enumeration; import java.util.Map; @WebServlet(\"/requestDemo\") public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //如果是get方式请求，则调用post方法获取请求参数 this.doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //post获取请求参数 //根据参数名称获取参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); System.out.println(\"post获取到的用户名：\" + username + \"，密码：\" + password); //根据参数名称获取参数，得到数据 String[] langs = req.getParameterValues(\"lang\"); for (String lang : langs) { System.out.println(\"获取到的lang：\" + lang); } //获取所有请求参数的名称 Enumeration parameterNames = req.getParameterNames(); System.out.println(\"所有请求参数名：\"); while (parameterNames.hasMoreElements()) { String name = parameterNames.nextElement(); String value = req.getParameter(name); System.out.println(\"请求参数：\" + name + \"，值：\" + value); } System.out.println(\"--------------------------------\"); //获取所有参数，得到map集合 Map parameterMap = req.getParameterMap(); for (String s : parameterMap.keySet()) { System.out.print(\"请求参数：\" + s +\": \"); for (String val : parameterMap.get(s)) { System.out.print(val+\" \"); } System.out.println(); } } } 中文乱码问题： get方式：Tomcat8已经解决了get方式的中文乱码问题 post方式：在获取参数前，设置request的编码：req.setCharacterEncoding(\"utf-8\"); 2. 请求转发：一种在服务器内部资源跳转的方式 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发：forward(ServletRequest request,ServletResponse response) @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/demo2\");// \"/demo2\"是要跳转到的Servlet类的urlPatterns requestDispatcher.forward(request, response); } 特点： 浏览器地址栏路径没有发生变化 只能转发到当前服务器的内部资源 转发是一次请求 3. 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj); 存储数据 Object getAttribute(String name); 通过键获取值 void removeAttribute(String name); 通过键移除数据 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo1被访问了~\"); //存储数据到request域中，要在请求转发之前 request.setAttribute(\"msg\",\"Hello\"); //请求转发 request.getRequestDispatcher(\"/demo2\").forward(request, response); } 4. 获取ServletContext ServletContext servletContext = request.getServletContext(); 概念：ServletContext对象代表了整个Web应用，可以和程序的容器（服务器）来通信 获取：(在同一个Web应用中，无论哪种获取方式，获取到的ServletContext对象都是同一个) 通过request对象获取： request.getServletContext(); 通过HttpServlet获取：this.getServletContext(); GenericServle()方式是其父类GenericServlet的方法 功能： 获取MIME类型：在互联网通信过程中定义的一种文件数据类型 格式：大类型/小类型，如:text/html image/jpeg 获取：String getMimeType(String file); Mime类型是通过文件后缀获取到的，通过后缀映射到它对应的Mime类型，所有的映射关系都存储在Tomcat-->conf-->web.xml中。由于ServletContext对象能和Web容器通信，所以，可以访问到所有的映射关系，获取文件的Mime类型。 String mimeType = servletContext.getMimeType(fileName); 域对象：共享数据（ServletContext对象是域对象） 域对象有三个方法： void setAttribute(String name,Object obj); 存储数据 Object getAttribute(String name); 通过键获取值 void removeAttribute(String name); 通过键移除数据 ServletContext对象的范围：所有用户所有请求 获取文件的真实（服务器）路径 方法：String getRealPath(String path); 获取不同目录下文件的真是路径的获取方式： String realPath1 = context.getRealPath(\"/WEB-INF/classes/1.txt\");//src下的文件获取 String realPath2 = context.getRealPath(\"/2.txt\");//web下的文件获取 String realPath3 = context.getRealPath(\"/WEB-INF/3.txt\");//web->WEB-INF下的文件获取 扩展：BeanUtils工具类 可以把页面获取到的所有参数直接封装成JavaBean @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.设置编码 request.setCharacterEncoding(\"utf-8\"); //2.获取所有参数 Map parameterMap = request.getParameterMap(); //3.创建User对象 User loginUser = new User(); //使用BeanUtils封装 try { BeanUtils.populate(loginUser,parameterMap);//使用BeanUtils中populate() } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } //4.调用UserDao中login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user==null){ request.getRequestDispatcher(\"/failServlet\").forward(request,response); }else { request.setAttribute(\"user\",user); request.getRequestDispatcher(\"/successServlet\").forward(request,response); } } BeanUtils概述： 用于封装JavaBean，什么是JavaBean： JavaBean是表标准的Java类 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共的setter/getter方法 概念： 成员变量： 属性：setter/getter方法截取后的产物 例如：getName()-->Name-->name /** *说明下属性的含义 */ public class User { private int id; private String username; private String password; private String gender;//成员变量gender public void setHehe(String gender){//setHehe来给成员变量gender赋值 this.gender = gender; } public String getHehe(){ return gender; } } User user = new User(); BeanUtils.setProperty(user,\"hehe\",\"male\");//设置属性hehe的值 String gender = BeanUtils.getProperty(user, \"hehe\"); 上面说属性是setHehe()-->Hehe-->hehe后得到的这个hehe，通过hehe可以完成对JavaBean的赋值和取值。 方法： setProperty(); 设置属性值 getProperty(); 获取属性值 populate(); 封装JavaBean 注意：使用BeanUtils.populate()封装JavaBean时，请求参数的参数名（即页面中的name属性）要和实体类中的属性名一致，才能正常封装，不一致的话运行时会报错。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee1/Response.html":{"url":"javaee1/Response.html","title":"Response","keywords":"","body":"Response 请求消息：客户端发送给服务器端的数据 数据格式：- 请求行 - 请求头 - 请求空行 - 请求体 相应消息：服务器端发送给客户端的数据 数据格式：- 响应行 - 响应头 - 响应空行 - 响应体 各部分说明： 响应行： 格式：HTTP/1.1 200 OK HTTP/1.1：协议和版本 200：响应状态码 OK：状态码描述 响应状态码： 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 状态码都是3位数字 分类：- 1xx：服务器接收客户端消息，但是没有接收完成，等待一段时间后，发送1xx状态码，询问客户端还要不要发送消息。 - 2xx：本次请求和响应成功，代码状态码：200 - 3xx：重定向。代表：302（重定向），304（访问缓存） 4xx：客户端错误（请求错误）- 404（请求路径没有对应的资源） - 405（页面的请求方式没有对应的doGet()或doPost()方法） 5xx：服务器端错误。代表：500（服务器内部出现异常） 响应头： 格式：键值对，名称:值 常见的响应头： content-type：服务器告诉客户端本次响应体数据格式以及编码格式 content-disposition：服务器告诉客户端以什么格式打开响应体数据，常用值： in-line：默认值，在当前页面打开 attachment; filename = xxx：以附件形式打开响应体。（文件下载） 响应体： 就是真实的传输的数据。 Servlet中的Response对象： Response是用来设置相应消息的： 设置相应行 格式：HTTP/1.1 200 OK 设置状态码：void setStatus(int sc);方法 设置响应头 void setHeader(String name,String value);方法 设置相应体 使用流的方式： 获取输出流 字符输出流（只能输出字符）：PrintWriter getWriter(); 字节输出流：ServletOutputStream getOutputStream(); 使用输出流，将数据输出到客户端浏览器 重定向： 重定向：资源跳转的方式 方式一： @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置状态码为302（重定向） response.setStatus(302); //设置响应头 response.setHeader(\"location\",\"/response_war_exploded/ResponseDemo2\"); } 分两步： 设置状态码为302（重定向） 设置响应头，键为location，值为要跳转的URI地址（URI：虚拟目录+Servlet路径） 方式二： void sendRedirect(String url); response.sendRedirect(\"/response_war_exploded/ResponseDemo2\"); 重定向和转发的比较： 重定向的特点： 地址栏发生变化 重定向可以访问其他站点的资源 重定向是两次请求 转发的特点：RequestDispatcher 浏览器地址栏路径没有发生变化 只能转发到当前服务器的内部资源 转发的整个流程只有一次请求 路径的写法： 相对路径：通过相对路径不可以确定唯一资源，有相对位置关系 如：./index.html 当前目录下的index.html资源 不以 / 开头，以 . 开头的路径 规则： 找到当前资源和目标资源之间的相对位置关系 ./ 当前目录 ../ 后退一级目录 绝对路径：通过绝对路径可以确定唯一的资源 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 以 / 开头的路径 案例：文件下载 在web中创建了三个用于下载的文件： HTML页面代码： 写了三个超链接，用于点击下载相应的文件： 超链接的href属性值，指向downloadServlet并携带请求参数文件名，Servlet通过获取不同的文件名，来实现下载对应的文件。 文件下载Demo 文本文档.txt下载 下载用.zip下载 text.txt下载 DownloadServlet类： import util.DownLoadUtils; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; @WebServlet(\"/downloadServlet\") public class DownloadServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取要请求的文件的名称 String filename = request.getParameter(\"filename\"); //获取请求文件的真是路径 ServletContext context = this.getServletContext(); String realPath = context.getRealPath(\"/doc/\" + filename); //获取浏览器的信息，根据浏览器处理文件中文名编码问题 String agent = request.getHeader(\"User-Agent\"); filename = DownLoadUtils.getFileName(agent, filename); //把文件写进输入流 FileInputStream fis = new FileInputStream(realPath); //设置response响应头 String mimeType = context.getMimeType(filename); response.setHeader(\"content-type\", mimeType); response.setHeader(\"content-disposition\", \"attachment; filename = \" + filename); //将输入流的数据写出到字节缓冲区，然后Servlet输出流再从缓冲区中读出 ServletOutputStream outputStream = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while ((len = fis.read(buff)) != -1) { outputStream.write(buff, 0, len); } //释放输入流资源 fis.close(); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee6/会话技术.html":{"url":"javaee6/会话技术.html","title":"2. 会话技术","keywords":"","body":"会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。 功能：在一次会话的范围内的多次请求之间共享数据。 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee6/Cookie.html":{"url":"javaee6/Cookie.html","title":"Cookie","keywords":"","body":"Cookie 概念：客户端会话技术，将数据保存到客户端 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value); 发送Cookie response.addCookie(Cookie cookie); 获取Cookie，拿到数据 Cookie[] request.getCookies(); 实现原理： 基于响应头set-cookie和请求头cookie实现 创建Cookie对象同时绑定数据并通过response发送Cookie对象，在浏览器第一次访问服务器时，服务器把cookie数据发送给浏览器（在浏览器的响应头set-cookie属性可见），浏览器接收到cookie时会把cookie数据保存到浏览器，当浏览器再次访问服务器时，请求消息会携带刚刚保存的cookie数据（在浏览器请求头cookie属性可见）。 Cookie的细节： 一次发送多个Cookie：创建多个Cookie对象，使用response调用addCookie()多次即可。 Cookie在浏览器中保存时间： 默认情况下，当浏览器被关闭后，Cookie数据被销毁 设置Cookie的生命周期，来持久化存储：setMaxAge(int seconds);方法。其中int参数为正数，Cookie数据则持久化存储到硬盘文件中，int参数为存活时间（秒）；负数表示Cookie默认的生命周期，浏览器关闭时销毁Cookie数据；int参数为0时表示删除Cookie数据。 Cookie存储中文数据 在Tomcat8之前，Cookie中不能直接存储中文数据，需要将中文数据转码，一般采用URL编码 在Tomcat8之后，Cookie中可以直接存储中文数据 Cookie共享 1 同一个Tomcat服务器内共享Cookie： 假设在一个Tomcat服务器中，部署了多个Web项目，默认情况下Cookie不能共享。 setPath(String path);方法： 设置Cookie的共享范围。默认情况下，设置当前项目的虚拟目录。如果想设置成整个Tomcat容器内的所有Web项目共享，则可设置成：setPath(\"/\"); 2 不同的Tomcat服务器间共享Cookie： setDomain(String path);方法： 如果设置一级域名相同，那么多个服务器之间Cookie可以共享。 setDomain(\".baidu.com\"); 那么tieba.baidu.com和news.baidu.com中的Cookie可以共享。 Cookie的特点和作用： Cookie存储数据在客户端浏览器（相对不太安全） 浏览器对于单个Cookie的大小有限制(4KB)，以及对同一个域名下的总Cookie数量有限制(一般限制在20个以内)。 作用： Cookie一般用于存储少量的不太敏感的数据 在不登录的情况下，完成对客户端的身份识别 案例：记住上一次访问的时间 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee6/Session.html":{"url":"javaee6/Session.html","title":"Session","keywords":"","body":"Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中：HttpSession 快速入门： HttpSession对象： 获取Session对象 HttpSession session = request.getSession(); 使用Session对象： void setAttribute(String name,Object value); Object getAttribute(String name); void removeAttribute(String name); Session创建过程（原理）： 浏览器第一次访问服务器端时，服务器端会检查请求头中的cookie是否含有JSESSIONID，如果没有，服务器会创建一个Session对象，并响应给浏览器一个JSESSIONID： 浏览器之后再访问服务器端时，请求消息的请求头cookie会携带服务器给的JSESSIONID，服务器端收到请求后会按照JSESSIONID检索Session对象（如果检索不到，可能会新建一个） SESSIONID的值一般是一个既不会重复，又不容易被仿造的字符串，这个SESSIONID将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee2/JSP.html":{"url":"javaee2/JSP.html","title":"3. JSP","keywords":"","body":"JSP 概念： Java Server Pages：Java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义HTML标签，又可以定义Java代码 用于简化书写的 原理： JSP本质上就是一个Servlet JSP引擎会把JSP文件转换成.java文件，这个.java文件继承自Tomcat内的一个org.apache.jasper.runtime.HttpJspBase类，而HttpJspBase类又继承了HttpServlet，所以说，JSP本质上就是一个Servlet。 JSP的脚本： JSP脚本：JSP定义Java代码的方式 ：定义的Java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 ：定义的Java代码，在JSP转换后的Java类的成员位置，即定义成员变量、成员方法、代码块等（用得比较少）。 ：定义的Java代码，会输出到页面上，输出语句中可以定义什么，该脚本就可以定义什么。这个输出语句定义在service方法中。 JSP的指令： 作用：用于配置JSP页面，导入资源文件 格式： 分类： page：配置JSP页面的 contentType：等同于response.setContentType()， 设置响应体的mime类型及字符集，设置当前JSP页面的编码 设置当前JSP页面的编码（只能是高级的IDE才能生效，如果使用低级的工具，则需要设置pageEncoding属性来设置当前页面的字符集） import：导包（推荐一个包一行） errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：表示当前页面是否是错误页面，设置成true，可以使用exception内置对象。 include：页面包含的。导入页面的资源文件 可以把其它页面引入进来，例如很多页面都有共同的头和脚，那就可以单独写一个头页面或脚页面，然后在其它页面中通过include把头页面的资源引进来。 taglib：导入资源（例如导入标签库） prefix：定义前缀 JSP的注释： HTML注释：注释的代码在前端页面源码中可见 JSP注释：不会发送到前端页面中 JSP的内置对象： 内置对象：在JSP页面中不需要获取创建，可以直接使用的对象。 JSP一共有9个内置对象：(前四个是域对象) PageContext pageContext：当前页面共享数据，还可以获取其他八个内置对象，通过它的get方法 HttpServletRequest request：一次请求访问的多个资源（转发） HttpSession session：一次会话的多个请求间 ServletContext application：所有用户间共享数据（服务器开启被创建，服务器关闭被销毁） HttpServletResponse response：相应对象 Object page：当前页面(Servlet)对象，this JspWriter out：字符输出流对象，可以将数据输出到页面上。和response.getWriter()类似，区别： 在Tomcat服务器真正给客户端作出相应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前。 ServletConfig config：Servlet的配置对象 Throwable exception：异常对象，声明isErrorPage=\"true\"，才能使用 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee2/MVC.html":{"url":"javaee2/MVC.html","title":"MVC模式","keywords":"","body":"MVC MVC是一种开发模式： M：Model，模型 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图 展示数据（MVC模式中，JSP只用于展示数据，而不做业务逻辑） C：Controller，控制器 获取用户的输入（获取请求） 调用模型 将模型返回的数据交给视图展示 MVC优缺点： 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求较高 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee2/EL表达式.html":{"url":"javaee2/EL表达式.html","title":"EL表达式","keywords":"","body":"EL表达式 概念： EL：Expression Language 表达式语言 作用： 替换和简化JSP页面中Java代码的编写 语法： ${表达式} EL表达式的结果会输出到页面上 注意： JSP默认支持EL表达式 如果要忽略EL表达式，设置JSP中page的属性，isELIgnored=\"true\"，则EL表达式会原样输出到页面上。 \\${表达式} 忽略单个的EL表达式 EL表达式使用： 运算符： 算术运算符：+ - * /(div) %(mod) 比较运算符：> = 逻辑运算符：&&(and) ||(or) !(not) 空运算符：empty，用于判断字符串、集合、数组对象是否为null或长度是否为0 ${empty list} list为null或长度为0，则返回true ${not empty str} 表示判断字符串、集合、数组对象是否不为null并且长度大于0 获取值： EL表达式只能从域对象中获取值 ${域名城.键名}：从指定域中获取指定键的值 域名称： pageScope --> pageContext域 ​ requestScope --> request域 ​ sessionScope -->session ​ applicationScope -->application(ServletContext) ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名}，本质上回去调用对象的getter/setter方法 List集合：${域名称.键名[index]} Map集合： ${域名称.键名.key} ${域名称.键名[\"key\"]} 隐式对象： el表达式中有11个隐式对象： pageScope requestScope sessionScope applicationScope pageContext： 获取jsp中其它8个内置对象 ${pageContext.request.contextPath} 动态获取虚拟目录 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee2/JSTL.html":{"url":"javaee2/JSTL.html","title":"JSTL","keywords":"","body":"JSTL 概念：JSTL：JavaServer pages Tag Library （JSP标准标签库） 由Apache组织提供的开源的免费的JSP标签库 作用：用于简化和替换JSP页面的java代码 使用步骤： 导入JSTL相关jar包 在JSP页面引入标签库 使用标签 常用的JSTL标签： if：相当于Java代码的if语句 if被输出了 number为奇数 注意：c:if 标签没有else的情况，想要else情况只能再定义一个c:if标签 choose：相当于Java代码的switch语句 星期一 星期二 星期三 星期四 星期五 星期六 星期日 没有对象项 foreach：相当于Java代码的for语句 用法一：完成循环行操作 begin：开始值 end：结束值 var：临时变量 step：步长 varStatus：循环状态对象(index属性：容器中元素的索引，从0开始；count属性：循环次数，从1开始) 用法二：遍历容器 list = new ArrayList<>(); list.add(new User(\"沙瑞金\", \"男\")); list.add(new User(\"田国富\", \"男\")); list.add(new User(\"高小琴\", \"女\")); request.setAttribute(\"list\", list); %> items：容器对象 var：容器中元素的临时变量 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee4/Filter.html":{"url":"javaee4/Filter.html","title":"4. Filter","keywords":"","body":"Filter 在网上找到一个对过滤器作用的总结： 过滤一些敏感的字符串【规定不能出现敏感字符串】、避免中文乱码【规定Web资源都使用UTF-8编码】、权限验证【规定只有带Session或Cookie的浏览器，才能访问web资源】等等等，过滤器的作用非常大，只要发挥想象就可以有意想不到的效果 也就是说：当需要限制用户访问某些资源时、在处理请求时提前处理某些资源、服务器响应的内容对其进行处理再返回、我们就是用过滤器来完成的！ Filter过滤器的使用： Filter和Servlet非常像，使用方式也类似，Servlet是实现Servlet接口，而Filter是实现Filter接口。 功能代码写完之后就需要配置过滤器，配置过滤器的过程和Servlet相似，可以通过web.xml配置文件和注解两种方式配置。 配置web.xml： CharacterEncodingFilter com.neu.filter.CharacterEncodingFilter CharacterEncodingFilter /servlet/* 最关键的就是url-pattern路径的配置，它决定了哪些请求和响应要经过过滤器 注解方式： 测试： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"javaee5/Listener.html":{"url":"javaee5/Listener.html","title":"5. Listener","keywords":"","body":"Listener 实现监听器接口，有N多种监听器 Javaweb中主要监听对象：ServletContext、Session、request、response Javaweb中的监听器主要有8个： ServletContext、Session、request、response的创建和销毁 监听域对象存放值、修改值、删除值(setAttribute/getAttribute/removeAttribute) 监听session中Javabean的操作、session本身的钝化和活化 创建类实现HttpSessionListener接口： 该接口有两个抽象方法： sessionCreated(HttpSessionEvent se)： session被创建时调用 sessionDestroyed(HttpSessionEvent se)：session被销毁时调用 配置监听器： 通过web.xml com.neu.listener.OnlineCountListener 使用@WebListener注解 小案例：统计在线人数 package com.neu.listener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; /** * 统计在线人数：统计session */ @WebListener public class OnlineCountListener implements HttpSessionListener { private static int onlineCount; //创建Session监听：一旦Session创建就会触发这个方法 public void sessionCreated(HttpSessionEvent se) { HttpSession session = se.getSession(); session.setMaxInactiveInterval(60); if (session == null) { onlineCount = 1; } else { onlineCount++; System.out.println(session.getId()); } se.getSession().getServletContext().setAttribute(\"onlineCount\", onlineCount); } //销毁Session监听：一旦Session销毁就会触发这个方法 public void sessionDestroyed(HttpSessionEvent se) { onlineCount--; se.getSession().getServletContext().setAttribute(\"onlineCount\", onlineCount); } } 演示： 使用不同浏览器访问时，会看到在线人数增加，当浏览器关闭之后，通过设置session销毁时间，当session销毁时，人数减少。 Session销毁的两种情况： 手动销毁：通过invalidate()方法销毁session 自动销毁：通过web.xml配置session销毁时间(minute) 1 或者通过setMaxInactiveInterval(int second);设置session的最大不活跃时间。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/mybatis.html":{"url":"frame3/mybatis.html","title":"1. Mybatis","keywords":"","body":"22. mybatis框架 什么是框架？ 软件框架（software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。 框架的功能类似于基础设施，与具体的软件应用无关，但是提供并实现最为基础的软件架构和体系。软件开发者通常依据特定的框架实现更为复杂的商业运用和业务逻辑。这样的软件应用可以在支持同一种框架的软件系统中运行。 简而言之，框架就是制定一套规范或者规则（思想），大家（程序员）在该规范或者规则（思想）下工作。或者说使用别人搭好的舞台来做编剧和表演。 三层架构 3-tier architecture： ​ User Interface layer 表现层（界面层）：用于展示数据的，例如：SpringMVC框架 ​ Business Logic Layer 业务层（业务逻辑层）：处理业务需求的 ​ Data access layer 持久层（数据访问层）：是和数据库交互的，例如：MyBatis框架 持久化（行为）： 数据持久化： 持久化就是将程序的数据在持久状态黑瞬时状态转化的过程 内存：断电即失 数据库(JDBC)，io文件都属于持久化数据的方式 为什么需要持久化？ 有一些对象，不能让他丢失，所以需要持久化 内存太贵了-。- 持久层（概念）： Dao层、Service层、Controller层... 完成持久化工作的代码块 层的界限是十分明显的 持久层解决方案： JDBC技术： Connection PareparedStatement ResultSet Spring的JdbcTemplate，Spring中对JDBC的简单封装 Apache的DBUtils，和JdbcTemplate很像，也是对JDBC的简单封装 ​ 以上这些都不是框架： ​ JDBC是规范，Sun提供接口，厂商提供接口实现。 ​ Spring的JdbcTemplate、Apache的DBUtils都只是工具类。 MyBatis的概述： MyBatis 是一款优秀的持久层框架，由Java语言编写， 它支持自定义 SQL、存储过程以及高级映射 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github 它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理接在驱动、创建连接、创建Statement等繁杂的过程。 ​ 它使用了ORM思想实现了结果集的封装。 ​ ORM： ​ Object Relational Mapping 对象关系映射 ​ 就是把数据库表和实体类及实体类的属性对应起来，让我们操作实例类就实现操作数据库表。 获取MyBatis： Maven仓库 org.mybatis mybatis 3.5.5 GitHub：https://github.com/mybatis/mybatis-3 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/第一个mybatis程序.html":{"url":"frame3/第一个mybatis程序.html","title":"1.1 第一个Mybatis程序","keywords":"","body":"第一个Mybatis程序 思路：搭建环境-->导入MyBatis-->编写代码-->测试 1. 创建数据库： mysql> create database mybatistest; mysql> use mybatistest; mysql> create table user( -> id int primary key auto_increment, -> name varchar(32), -> pwd varchar(32) -> ); 2. 在IDEA上新建项目： 新建一个普通的Maven项目，删除src目录，作为父工程 在父工程的pom.xml中添加需要的依赖坐标 4.0.0 org.example MybatisStudy 1.0-SNAPSHOT mysql mysql-connector-java 8.0.20 org.mybatis mybatis 3.5.5 junit junit 4.12 3. 创建一个子模块 配置MyBatis核心配置文件：mybatis-config.xml 4. 编写工具类 package com.neu.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; /** * SqlSessionFactory --> sqlSession * 1. 获取SqlSessionFactory对象 * 2. 通过SqlSessionFactory对象获取SqlSession对象 * * @author liyan */ public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; /** * 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 * 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。 * MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。 */ static { String resource = \"mybatis-config.xml\"; InputStream inputStream = null; try { inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); }finally { if(inputStream!=null){ try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 * SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 * 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 * * @return sqlSession */ public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); } } 5. 编写代码 创建User实体类： 定义UserMapper(UserDao)接口： 这里把UserDao接口的名字写成UserMapper了，在Mybatis里面主要体现的是映射的关系 创建UserMapper.xml配置文件： 注意：每创建一个UserMapper.xml文件，都要在mybatis的主配置文件中注册，否则在运行程序时会报一下错误，未知的Mapper注册： org.apache.ibatis.binding.BindingException: Type interface com.neu.dao.UserMapper is not known to the MapperRegistry. 6. 测试代码： 执行UserMapper中的方法的步骤： @Test public void testGetUserList() { //通过工具类获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //得到接口对象mapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); //通过接口对象mapper执行接口中的方法（实际上是映射到xml中） List userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } //关闭SqlSession sqlSession.close(); } 最终的运行结果： 使用完SqlSession对象之后，要关闭，这里我的测试代码中忘记写了（sqlSession.close();） 测试运行结果时，报了一个错误，错误信息是找不到UserMapper.xml，这里涉及一个Maven的注意事项，maven正常只能直接读取resources内的文件，而我把UserMapper.xml写在了src/main/java/com/neu/dao里面了： 解决办法是需要在Maven的pom.xml文件中配置build信息： （尝试了只在父工程的pom.xml文件中添加也可以） src/main/resources **/*.properties **/*.xml true src/main/java **/*.properties **/*.xml true 再次运行时，得到上面的运行结果，第一个Mybatis程序完成~ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/mybatis增删改查.html":{"url":"frame3/mybatis增删改查.html","title":"1.2 Mybatis增删改查","keywords":"","body":"Mybatis增删改查 接口代码： 和之前操作数据库dao层接口是一样的 package com.neu.dao; import com.neu.pojo.User; import java.util.List; public interface UserMapper { /** * 查询所有User * @return List */ List getUserList(); /** * 通过id查询User * @param id * @return int */ User getUserById(int id); /** * 插入User * @param user * @return int */ int addUser(User user); /** * 修改User * @param user * @return int */ int updateUser(User user); /** * 通过id删除User * @param id * @return int */ int deleteUser(int id); } UserMapper.xml select * from user select * from user where id = #{id} insert into user values (#{id},#{name},#{pwd}) update user set name = #{name} ,pwd = #{pwd} where id = #{id} delete from user where id = #{id} 测试代码： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/Map和模糊查询.html":{"url":"frame3/Map和模糊查询.html","title":"1.3 Map和模糊查询","keywords":"","body":"1.3 Map和模糊查询 Map传参： 假设实体类或数据库中的属性或字段比较多，可以适当使用Map来操作数据库： 现在在UserMapper接口中又定义了一个插入方法，addUser2，传入的参数使用Map： UserMapper.xml 测试方法： Map传递参数，直接在sql中取key即可---parameterType=\"map\" 对象传递参数，直接sql中取对象属性即可---parameterType=\"com.neu.pojo.User\" 只有一个基本数据类型参数的话，可以直接在sql中取到 多个参数用Map，或注解 模糊查询： 在Java代码执行时，传递通配符% % select * from user where name like #{name} List list = mapper.getUserLike(\"%李%\"); 在sql拼接中使用通配符 select * from user where name like \"%\"#{name}\"%\" List list = mapper.getUserLike(\"李\"); Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/配置之属性优化.html":{"url":"frame3/配置之属性优化.html","title":"1.4 Mybatis配置之属性优化","keywords":"","body":"1.4 配置之属性优化 官方文档：https://mybatis.org/mybatis-3/zh/configuration.html MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） environments（环境配置） MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 环境配置： 环境id： 事务管理器配置：在 MyBatis 中有两种类型的事务管理器，常用是JDBC JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。 MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如: 数据源： UNPOOLED：不使用连接池 POOLED：使用连接池 JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用 属性（properties） 可以把数据源的一些属性定义在Properties文件中，再通过mybatis-config.xml核心配置文件引入这个外部文件： 创建一个db.properties： driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatistest username=root password=123456 引入外部文件时要注意标签的书写顺序： 动态获取属性值： 或者： 官方文档说：如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载： 首先读取在 properties 元素体内指定的属性。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。 最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/配置之别名优化.html":{"url":"frame3/配置之别名优化.html","title":"1.5 Mybatis配置之别名优化","keywords":"","body":"1.5 Mybatis配置之别名优化 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 这个别名配置只能在Mybatis核心配置文件中使用，且对位置有要求，放在引入外部文件的配置下面。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 这种方法，name中设置实体类的包名，这样直接引用该包下的实体类时，会自动在这个包中搜索实体类。 小结： 第一种方式给实体类起别名，可以自定义实体类的别名，如果实体类比较少可以使用这种方法 如果一个包中实体类比较多，则可以使用第二种方式，但是不能给实体类起别名；如果想给实体类定义别名的话，可以通过在实体类中加入@Alias(\"XXX\")注解，定义别名。 代码演示： 第一种方式： 在mybatis-config.xml中添加别名配置： 在UserMapper.xml中结果类型可以直接引入别名： select * from user 第二种方式： 在UserMapper.xml中结果类型可直接引入包中的实体类（建议小写）： select * from user 可以使用注解给实体类加别名： @Alias(\"UserAlias\") public class User { private int id; private String name; private String pwd; //... } 那么，UserMapper.xml中引用实体类型时，必须使用别名，否则会找不到该实体类： select * from user 设置： 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。 一个配置完整的 settings 元素的示例如下： 在Mybatis官方文档查询具体说明：https://mybatis.org/mybatis-3/zh/configuration.html#settings Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/配置之映射器.html":{"url":"frame3/配置之映射器.html","title":"1.6 Mybatis配置之映射器","keywords":"","body":"1.6 Mybatis配置之映射器 在【第一个mybatis程序】中，后面运行中报了一个错误，找不到UserMapper.xml 所以，每一个Mapper.xml都需要在mybatis核心配置文件中注册（映射），注册方式有4中，常用的是一下三种： 方式一： 方式二： 注意： 接口和Mapper.xml配置文件必须同名 接口和Mapper.xml配置文件必须必须在同一个包下 方式三： 注意： 接口和Mapper.xml配置文件必须同名 接口和Mapper.xml配置文件必须必须在同一个包下 使用后两种方法： 如果需要把Mapper.xml配置文件放到resources里，只要在resources中创建和对应接口相同的包即可： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/生命周期和作用域.html":{"url":"frame3/生命周期和作用域.html","title":"1.7 生命周期和作用域（Scope）","keywords":"","body":"1.7 生命周期和作用域（Scope） 不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（局部变量）。 SqlSessionFactory SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。 因此 SqlSessionFactory 的最佳作用域是应用作用域（全局变量）。 说白了，可以把SqlSessionFactory看作是一个“数据库连接池” SqlSession 每个线程都应该有它自己的 SqlSession 实例。 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后要关闭(sqlSession对象.close())，否则资源会一直被占用。（这个SqlSession就好比是从DataSource中获取的Connection对象，如果用完不关闭，Connection对象会一直被占用） Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/结果集映射.html":{"url":"frame3/结果集映射.html","title":"1.8 结果集映射","keywords":"","body":"1.8 结果集映射 实体类属性名与数据库字段名不一致的情况： 例如，做查询操作时，会出现这种情况： 数据库中表示密码的字段是pwd，而实体类中的属性名是pass，查询时，返回的pass则为null 造成这种情况的原因是，设定的返回的resultType是User类型，执行完查询语句后将查询结果返回成User类型，而数据库的查询结果pwd字段在封装成User类型时，在User实体类中找不到pwd属性，所有查询结果pass=null 解决办法： sql语句中给字段添加别名，让它能找到实体类的对应属性 上面这种解决办法不是好的，所以mybatis给出了一个更好的解决办法，resultMap：结果集映射 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/日志工厂.html":{"url":"frame3/日志工厂.html","title":"1.9 日志工厂","keywords":"","body":"1.9 日志工厂 在数据库操作出现问题时，可以通过日志来帮助我们查找错误。 Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 如果你的应用部署在一个类路径已经包含 Commons Logging 的环境中，而你又想使用其它日志实现，你可以通过在 MyBatis 配置文件 mybatis-config.xml 里面添加一项 setting 来选择其它日志实现。 ... ... 可选的值有：SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者是实现了 org.apache.ibatis.logging.Log 接口，且构造方法以字符串为参数的类完全限定名。 上面这些都来自于官方文档，下面就来实际操作一下： 示例： 在mybatis-config.xml中配置日志工厂 在执行select * from user查询语句后，控制台打印出日志信息： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/log4j.html":{"url":"frame3/log4j.html","title":"1.10 log4j","keywords":"","body":"1.10 log4j Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等。 我们也可以控制每一条日志的输出格式， 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程， 这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 mybatis中配置log4j： 第一步：导入jar包，如果是Maven项目则可以通过添加坐标导入依赖： log4j log4j 1.2.17 第二步：在CLASSPATH下建立log4j.properties # 将等级为DEBUG的日志信息输出到console和file两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file # 控制台输出的相关配置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold = DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n # 文件输出的相关配置 log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/debug.log log4j.appender.file.MaxFileSize = 10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout = org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n # 日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 第三步：mybatis-config.xml中配置日志 第四步：运行，控制台输出了日志信息 log4j简单使用： 通过Logger对象，自定义输出不同级别的日志 在要使用log4j的类中，导入包import org.apache.log4j.Logger; 获取Logger对象，参数为当前类的class static Logger logger = Logger.getLogger(Test.class); 日志级别，常用： logger.info(\"info：进入了testLog4j\"); logger.debug(\"debug：进入了testLog4j\"); logger.error(\"error：进入了testLog4j\"); Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/limit实现分页.html":{"url":"frame3/limit实现分页.html","title":"1.11 Limit实现分页","keywords":"","body":"1.10 Limit实现分页 分页查询： select * from tableName limit startIndex,pageSize # startIndex 是查询的起始位置 # pageSize 每页查询的数量 如： select * from user limit 0,2; 查询结果：（实际user表中有4条数据） 1,admin,123456 2,李四,123456 拓展： select * from user limit 0,-1; 这个之前表示从第一条查到最后一条，但这种用法之前实际上是mysql的一个bug，现在已经被修复了。 代码示例： 接口： List getUserByLimit(Map map); xml select * from user limit #{startIndex},#{pageSize} 测试： @org.junit.Test public void test(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map map = new HashMap(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List userByLimit = mapper.getUserByLimit(map); for (User user : userByLimit) { System.out.println(user); } } 运行结果： User{id=1, name='admin', pwd='123456'} User{id=2, name='李四', pwd='123456'} Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/RowBounds分页.html":{"url":"frame3/RowBounds分页.html","title":"1.12 RowBounds分页","keywords":"","body":"1.11 RowBounds分页 limit是通过sql层面实现分页，RowBounds是通过Java代码实现分页 代码示例： 接口： List getUserByRowBounds(Map map); xml： select * from user 测试： @org.junit.Test public void test1(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(0,2); //通过Java代码层面实现分页 List selectList = sqlSession.selectList(\"com.neu.dao.UserMapper.getUserByRowBounds\",null,rowBounds); for (Object o : selectList) { System.out.println(o); } } 运行结果： User{id=1, name='admin', pwd='123456'} User{id=2, name='李四', pwd='123456'} MyBatis 分页插件 PageHelper使用： https://pagehelper.github.io/docs/ 1. 引入分页插件 引入分页插件有下面2种方式，推荐使用 Maven 方式。 1). 引入 Jar 包 你可以从下面的地址中下载最新版本的 jar 包 https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/ http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/ 由于使用了sql 解析工具，你还需要下载 jsqlparser.jar： http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/ 2). 使用 Maven 在 pom.xml 中添加如下依赖： com.github.pagehelper pagehelper 最新版本 最新版本号可以从首页查看。 2. 配置拦截器插件 特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 1. 在 MyBatis 配置 xml 中配置拦截器插件 2. 在 Spring 配置文件中配置拦截器插件 使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置： params=value1 3. 分页插件参数介绍 分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby 特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。 你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum 时会查询第一页， pageNum>pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 4. 如何选择配置这些参数 单独看每个参数的说明可能是一件让人不爽的事情，这里列举一些可能会用到某些参数的情况。 场景一 如果你仍然在用类似ibatis式的命名空间调用方式，你也许会用到rowBoundsWithCount， 分页插件对RowBounds支持和 MyBatis 默认的方式是一致，默认情况下不会进行 count 查询，如果你想在分页查询时进行 count 查询， 以及使用更强大的 PageInfo 类，你需要设置该参数为 true。 注： PageRowBounds 想要查询总数也需要配置该属性为 true。 场景二 如果你仍然在用类似ibatis式的命名空间调用方式，你觉得 RowBounds 中的两个参数 offset,limit 不如 pageNum,pageSize 容易理解， 你可以使用 offsetAsPageNum 参数，将该参数设置为 true 后，offset会当成 pageNum 使用，limit 和 pageSize 含义相同。 场景三 如果觉得某个地方使用分页后，你仍然想通过控制参数查询全部的结果，你可以配置 pageSizeZero 为 true， 配置后，当 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果。 场景四 如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum 会查询第一页，如果 pageNum>总页数 会查询最后一页。 场景五 如果你在 Spring 中配置了动态数据源，并且连接不同类型的数据库，这时你可以配置 autoRuntimeDialect 为 true，这样在使用不同数据源时，会使用匹配的分页进行查询。 这种情况下，你还需要特别注意 closeConn 参数，由于获取数据源类型会获取一个数据库连接，所以需要通过这个参数来控制获取连接后，是否关闭该连接。 默认为 true，有些数据库连接关闭后就没法进行后续的数据库操作。而有些数据库连接不关闭就会很快由于连接数用完而导致数据库无响应。所以在使用该功能时，特别需要注意你使用的数据源是否需要关闭数据库连接。 当不使用动态数据源而只是自动获取 helperDialect 时，数据库连接只会获取一次，所以不需要担心占用的这一个连接是否会导致数据库出错，但是最好也根据数据源的特性选择是否关闭连接。 3. 如何在代码中使用 阅读前请注意看重要提示 分页插件支持以下几种调用方式： //第一种，RowBounds方式的调用 List list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(0, 10)); //第二种，Mapper接口方式的调用，推荐这种使用方式。 PageHelper.startPage(1, 10); List list = countryMapper.selectIf(1); //第三种，Mapper接口方式的调用，推荐这种使用方式。 PageHelper.offsetPage(1, 10); List list = countryMapper.selectIf(1); //第四种，参数方法调用 //存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数 public interface CountryMapper { List selectByPageNumSize( @Param(\"user\") User user, @Param(\"pageNum\") int pageNum, @Param(\"pageSize\") int pageSize); } //配置supportMethodsArguments=true //在代码中直接调用： List list = countryMapper.selectByPageNumSize(user, 1, 10); //第五种，参数对象 //如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页 //有如下 User 对象 public class User { //其他fields //下面两个参数名和 params 配置的名字一致 private Integer pageNum; private Integer pageSize; } //存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数 public interface CountryMapper { List selectByPageNumSize(User user); } //当 user 中的 pageNum!= null && pageSize!= null 时，会自动分页 List list = countryMapper.selectByPageNumSize(user); //第六种，ISelect 接口方式 //jdk6,7用法，创建接口 Page page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() { @Override public void doSelect() { countryMapper.selectGroupBy(); } }); //jdk8 lambda用法 Page page = PageHelper.startPage(1, 10).doSelectPage(()-> countryMapper.selectGroupBy()); //也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPage pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() { @Override public void doSelect() { countryMapper.selectGroupBy(); } }); //对应的lambda用法 pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -> countryMapper.selectGroupBy()); //count查询，返回一个查询语句的count数 long total = PageHelper.count(new ISelect() { @Override public void doSelect() { countryMapper.selectLike(country); } }); //lambda total = PageHelper.count(()->countryMapper.selectLike(country)); 下面对最常用的方式进行详细介绍 1). RowBounds方式的调用 List list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。 分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。 关于这种方式的调用，有两个特殊的参数是针对 RowBounds 的，你可以参看上面的 场景一 和 场景二 注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如： //这种情况下也会进行物理分页查询 List selectAll(RowBounds rowBounds); 注意： 由于默认情况下的 RowBounds 无法获取查询总数，分页插件提供了一个继承自 RowBounds 的 PageRowBounds，这个对象中增加了 total 属性，执行分页查询后，可以从该属性得到查询总数。 2). PageHelper.startPage 静态方法调用 除了 PageHelper.startPage 方法外，还提供了类似用法的 PageHelper.offsetPage 方法。 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 例一： //获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); //紧跟着的第一个select方法会被分页 List list = countryMapper.selectIf(1); assertEquals(2, list.get(0).getId()); assertEquals(10, list.size()); //分页时，实际返回的结果list类型是Page，如果想取出分页信息，需要强制转换为Page assertEquals(182, ((Page) list).getTotal()); 例二： //request: url?pageNum=1&pageSize=10 //支持 ServletRequest,Map,POJO 对象，需要配合 params 参数 PageHelper.startPage(request); //紧跟着的第一个select方法会被分页 List list = countryMapper.selectIf(1); //后面的不会被分页，除非再次调用PageHelper.startPage List list2 = countryMapper.selectIf(null); //list1 assertEquals(2, list.get(0).getId()); assertEquals(10, list.size()); //分页时，实际返回的结果list类型是Page，如果想取出分页信息，需要强制转换为Page， //或者使用PageInfo类（下面的例子有介绍） assertEquals(182, ((Page) list).getTotal()); //list2 assertEquals(1, list2.get(0).getId()); assertEquals(182, list2.size()); 例三，使用PageInfo的用法： //获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); List list = countryMapper.selectAll(); //用PageInfo对结果进行包装 PageInfo page = new PageInfo(list); //测试PageInfo全部属性 //PageInfo包含了非常全面的分页属性 assertEquals(1, page.getPageNum()); assertEquals(10, page.getPageSize()); assertEquals(1, page.getStartRow()); assertEquals(10, page.getEndRow()); assertEquals(183, page.getTotal()); assertEquals(19, page.getPages()); assertEquals(1, page.getFirstPage()); assertEquals(8, page.getLastPage()); assertEquals(true, page.isFirstPage()); assertEquals(false, page.isLastPage()); assertEquals(false, page.isHasPreviousPage()); assertEquals(true, page.isHasNextPage()); 3). 使用参数方式 想要使用参数方式，需要配置 supportMethodsArguments 参数为 true，同时要配置 params 参数。 例如下面的配置： 在 MyBatis 方法中： List selectByPageNumSize( @Param(\"user\") User user, @Param(\"pageNumKey\") int pageNum, @Param(\"pageSizeKey\") int pageSize); 当调用这个方法时，由于同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。params 提供的几个参数都可以这样使用。 除了上面这种方式外，如果 User 对象中包含这两个参数值，也可以有下面的方法： List selectByPageNumSize(User user); 当从 User 中同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。 注意：pageNum 和 pageSize 两个属性同时存在才会触发分页操作，在这个前提下，其他的分页参数才会生效。 3). PageHelper 安全调用 1. 使用 RowBounds 和 PageRowBounds 参数方式是极其安全的 2. 使用参数方式是极其安全的 3. 使用 ISelect 接口调用是极其安全的 ISelect 接口方式除了可以保证安全外，还特别实现了将查询转换为单纯的 count 查询方式，这个方法可以将任意的查询方法，变成一个 select count(*) 的查询方法。 4. 什么时候会导致不安全的分页？ PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。 只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。 如果代码在进入 Executor 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 MappedStatement 时）， 这种情况由于线程不可用，也不会导致 ThreadLocal 参数被错误的使用。 但是如果你写出下面这样的代码，就是不安全的用法： PageHelper.startPage(1, 10); List list; if(param1 != null){ list = countryMapper.selectIf(param1); } else { list = new ArrayList(); } 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： List list; if(param1 != null){ PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1); } else { list = new ArrayList(); } 这种写法就能保证安全。 如果你对此不放心，你可以手动清理 ThreadLocal 存储的分页参数，可以像下面这样使用： List list; if(param1 != null){ PageHelper.startPage(1, 10); try{ list = countryMapper.selectAll(); } finally { PageHelper.clearPage(); } } else { list = new ArrayList(); } 这么写很不好看，而且没有必要。 4. MyBatis 和 Spring 集成示例 如果和Spring集成不熟悉，可以参考下面两个 只有基础的配置信息，没有任何现成的功能，作为新手入门搭建框架的基础 集成 Spring 3.x 集成 Spring 4.x 这两个集成框架集成了 PageHelper 和 通用 Mapper。 5. Spring Boot 待定 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/使用注解开发.html":{"url":"frame3/使用注解开发.html","title":"1.13 使用注解开发","keywords":"","body":"1.12 使用注解开发 来自官方文档的说明： 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。 使用流程： 给接口中的方法添加@Select(\"sql语句\")注解： public interface UserMapper { @Select(\"select * from user\") List getUsers(); } 需要在mybatis-config.xml中注册（映射）接口： 测试代码： @org.junit.Test public void test(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); //底层主要应用反射 UserMapper mapper = sqlSession.getMapper(UserMapper.class); List users = mapper.getUsers(); for (User user : users) { System.out.println(user); } sqlSession.close(); } 运行： User{id=1, name='admin', pwd='123456'} User{id=2, name='李四', pwd='123456'} User{id=3, name='liyan', pwd='123'} User{id=4, name='李炎', pwd='123'} 本质：反射机制 底层：动态代理 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/mybatis执行流程剖析.html":{"url":"frame3/mybatis执行流程剖析.html","title":"1.14 Mybatis执行流程剖析","keywords":"","body":"1.13 Mybatis执行流程剖析 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/使用注解增删改查.html":{"url":"frame3/使用注解增删改查.html","title":"1.15 使用注解增删改查","keywords":"","body":"1.15 使用注解增删改查 设置自动提交事务： SqlSessionFactory接口中提供了一个openSession(boolean autoCommit)方法，可以设置自动提交事务，下面是该方法的实现： @Override public SqlSession openSession(boolean autoCommit) { return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit); } 查询操作： 不带参数查询： @Select(\"select * from user\") List getUsers(); 带参数查询：如通过id查询User @Select(\"select * from user where id = #{id}\") User getUserById(@Param(\"id\") int id); 注意事项： 如果方法中的参数是基本数据类型或String类型，且只有一个参数的情况下，参数前面的@Param(\"id\")注解加不加都可以 如果是多个参数的情况下，则每个参数前必须加@Param(\"xxx\")注解，SQL语句中的参数是通过@Param来查找的。 插入操作： @Insert(\"insert into user values(#{id},#{name},#{pwd})\") int addUser(User user); 注意事项： SQL语句中#{\"xxx\"}的参数名要和实体类中的属性名一致，否则会找不到 更新操作： @Update(\"update user set name = #{name},pwd = #{pwd} where id = #{id}\") int updateUser(User user); 删除操作： @Delete(\"delete from user where id = #{id}\") int deleteUser(@Param(\"id\") int id); 号外~ SQL语句中#{}和${}的区别： #{}是预编译的，能很大程度防止SQL注入问题 ${}不能防止SQL注入问题，相对不安全 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/动态SQL的使用.html":{"url":"frame3/动态SQL的使用.html","title":"1.16 动态SQL的使用","keywords":"","body":"1.16 动态SQL的使用 使用 jdbc 或类似的框架，动态拼接 SQL 是很痛苦的。比如根据当前日期选择数据表、根据传入的参数决定更新哪些字段等，都是比较常用的动态查询。MyBatis 拥有强大的动态 SQL 功能，可以在任何 SQL 语句中使用。MyBatis 的动态 SQL 主要使用以下几个元素来实现： 单一条件：if 多个条件：choose, when, otherwise 自动封装：trim, where, set 遍历集合：foreach 由于mybatis 的sql 是配置在mapper.xml文件中的，所有xml解析 , =会出错，那怎么解决呢？ 通过转义字符 原符号 > >= & ' \" 替换符号 &lt; &lt;= &gt; &gt;= &amp; &apos; &quot; if if 用于检测条件，动态包含 SQL 语句。例如下面的语句中，根据输入的 title 是否为空来决定是否在查询条件中增加 title 搜索条件。 SELECT * FROM Person WHERE state = ‘ACTIVE’ AND title like #{title} choose, when, otherwise choose 元素提供了类似于 Java 语言中的 switch 功能，可以从多个选项中选择一个加入 SQL 语句。 例如下面的语句，使用了两个 when 和一个 otherwise，类似于 switch 中的 case 和 default。 SELECT * FROM Person WHERE state = ‘ACTIVE’ AND title like #{title} AND sex = #{sex} AND height = 170 trim, where, set trim 元素可以用于为 SQL 语句增加前缀、后缀，并去除指定的开头和结尾。一共有四个属性： prefix：语句的前缀； prefixOverrides：去除开头； suffix：语句的后缀； suffixOverrides：去除结尾。 在下面的语句中，trim 会先删除 somesql 的开头和结尾，然后再增加前缀和后缀。 somesql 假设使用 if 语句增加两个动态条件，如下所示。如果只满足第二个条件，或者两个条件都不满足，最终得到的 SQL 是一个有 WHERE 但没有条件的非法 SQL。 SELECT * FROM Person WHERE sex = #{sex} AND title like #{title} 使用 where 元素可以避免这一点，如下所示。where 元素可以检测内部的查询条件是否合法，比如为空、多了 AND / OR，并进行处理使 SQL 语句合法。经过 where 元素处理后，无论内部 if 元素是否成立，我们都可以得到合法的 SQL 语句。 SELECT * FROM Person sex = #{sex} AND title like #{title} 同样地，update 语句中也可以使用 set 元素来实现类似于 where 元素的功能。在如下的示例中，set 元素确保了 SQL 语句中的 SET 永远是合法的，它能自动处理 SET 为空、结尾多逗号，并自动拼接 SET 字符串。 update Person title=#{title}, sex=#{sex}, where id=#{id} 注意set中的,逗号，这里：title=#{title}, foreach foreach 用于处理集合，比如批量插入、批量查询条件等情况，支持 List、Array、Set、Map 等。在下面的例子中，查询条件是一个 list，使用 in 来查询。 SELECT * FROM Person WHERE id in #{item} foreach 的属性定义如下： Item：集合中元素迭代的别名，如果集合为 map 这里是 value； index：集合中元素迭代的索引，如果集合为 map 这里是 key； collection：集合的类型； open：语句的前缀； separator：语句的分隔符； close：语句的后缀。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/一对一查询.html":{"url":"frame3/一对一查询.html","title":"1.17 高级映射：一对一查询","keywords":"","body":"1.17 一对一查询 准备工作： 1、准备数据表，数据库直接导入这四张表 DROP TABLE IF EXISTS `tb_item`; -- 创建商品表 CREATE TABLE `tb_item` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `item_name` VARCHAR(32) NOT NULL COMMENT '商品名称', `item_price` FLOAT(6,1) NOT NULL COMMENT '商品价格', `item_detail` TEXT COMMENT '商品描述', PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; INSERT INTO `tb_item` VALUES ('1', 'iPhone 6', '5288.0', '苹果公司新发布的手机产品。'); INSERT INTO `tb_item` VALUES ('2', 'iPhone 6 plus', '6288.0', '苹果公司发布的新大屏手机。'); -- 创建用户表 DROP TABLE IF EXISTS `tb_user`; CREATE TABLE `tb_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `user_name` VARCHAR(100) DEFAULT NULL COMMENT '用户名', `password` VARCHAR(100) DEFAULT NULL COMMENT '密码', `name` VARCHAR(100) DEFAULT NULL COMMENT '姓名', `age` INT(10) DEFAULT NULL COMMENT '年龄', `sex` TINYINT(1) DEFAULT NULL COMMENT '性别，1男性，2女性', `birthday` DATE DEFAULT NULL COMMENT '出生日期', `created` DATETIME DEFAULT NULL COMMENT '创建时间', `updated` DATETIME DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `username` (`user_name`) ) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; INSERT INTO `tb_user` VALUES ('1', 'zhangsan', '123456', '张三', '30', '1', '1984-08-08', '2014-09-19 16:56:04', '2014-09-21 11:24:59'); INSERT INTO `tb_user` VALUES ('2', 'lisi', '123456', '李四', '21', '2', '1991-01-01', '2014-09-19 16:56:04', '2014-09-19 16:56:04'); INSERT INTO `tb_user` VALUES ('3', 'wangwu', '123456', '王五', '22', '2', '1989-01-01', '2014-09-19 16:56:04', '2014-09-19 16:56:04'); INSERT INTO `tb_user` VALUES ('4', 'zhangwei', '123456', '张伟', '20', '1', '1988-09-01', '2014-09-19 16:56:04', '2014-09-19 16:56:04'); INSERT INTO `tb_user` VALUES ('5', 'lina', '123456', '李娜', '28', '1', '1985-01-01', '2014-09-19 16:56:04', '2014-09-19 16:56:04'); INSERT INTO `tb_user` VALUES ('6', 'lilei', '123456', '李磊', '23', '1', '1988-08-08', '2014-09-20 11:41:15', '2014-09-20 11:41:15'); -- 订单表 DROP TABLE IF EXISTS `tb_order`; CREATE TABLE `tb_order` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `user_id` BIGINT(20) NOT NULL, `order_number` VARCHAR(20) NOT NULL COMMENT '订单号', PRIMARY KEY (`id`), KEY `FK_orders_1` (`user_id`), CONSTRAINT `FK_orders_1` FOREIGN KEY (`user_id`) REFERENCES `tb_user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION ) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; INSERT INTO `tb_order` VALUES ('1', '1', '20140921001'); INSERT INTO `tb_order` VALUES ('2', '2', '20140921002'); INSERT INTO `tb_order` VALUES ('3', '1', '20140921003'); -- 创建订单明细表 DROP TABLE IF EXISTS `tb_orderdetail`; CREATE TABLE `tb_orderdetail` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `order_id` INT(32) DEFAULT NULL COMMENT '订单号', `item_id` INT(32) DEFAULT NULL COMMENT '商品id', `total_price` DOUBLE(20,0) DEFAULT NULL COMMENT '商品总价', `status` INT(11) DEFAULT NULL COMMENT '状态', PRIMARY KEY (`id`), KEY `FK_orderdetail_1` (`order_id`), KEY `FK_orderdetail_2` (`item_id`), CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`order_id`) REFERENCES `tb_order` (`id`), CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`item_id`) REFERENCES `tb_item` (`id`) ) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; INSERT INTO `tb_orderdetail` VALUES ('1', '1', '1', '5288', '1'); INSERT INTO `tb_orderdetail` VALUES ('2', '1', '2', '6288', '1'); INSERT INTO `tb_orderdetail` VALUES ('3', '2', '2', '6288', '1'); INSERT INTO `tb_orderdetail` VALUES ('4', '3', '1', '5288', '1'); 2、这是这4张表之间的关系： 一对一查询： 需求：通过订单ID查询订单信息及对应的用户信息 分析： 一个订单对应一个用户，这是一对一的关系；一个用户会对应多个订单，这是一对多的关系。 这里面只涉及tb_order表和tb_user表 首先，在Order实体类中添加User属性，为了把查询的User信息映射到user属性里 @Data @AllArgsConstructor @NoArgsConstructor public class Order implements Serializable { private Integer id; private Long userId; private String orderNumber; //添加一个User类型的属性 private User user; private static final long serialVersionUID = 1L; } 定义Dao接口 Order queryOrderById(Integer id); OrderMapper.xml select tb_order.id, tb_order.user_id, tb_order.order_number, tb_user.* from tb_order, tb_user where tb_order.user_id = tb_user.id and tb_order.id = #{id} 结果映射使用resultMap，通过标签为Order中的User属性赋值，把select查询返回的User表中的数据映射到User属性中。 association：用于映射类中的自定义类型的属性，把结果映射到该对象的属性中 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/一对多查询.html":{"url":"frame3/一对多查询.html","title":"1.18 高级映射：一对多查询","keywords":"","body":"1.18 一对多查询 需求：通过订单id查询订单数据及订单详情 分析： 一个订单中可能包含多个商品，订单详情表中一件商品就对应一条数据，所以这是一个一对多的关系 这里面涉及tb_order表和tb_orderdetail表 实体类Order中添加List属性： @Data @AllArgsConstructor @NoArgsConstructor public class Order implements Serializable { private Integer id; private Long userId; private String orderNumber; private User user; //一条订单可能会查询出多条订单详情的数据，所以这里声明的是列表 private List orderDetails; private static final long serialVersionUID = 1L; } Dao接口： 通过id查询： Order queryOrderdetails(Integer id); OrderMapper.xml： 属性赋值， 把查询到的多条orderDetail数据注入到List属性中 --> select o.*, od.id odid, od.item_id, od.order_id, od.total_price, od.status from tb_order o, tb_orderdetail od where o.id = od.order_id and o.id = #{id} 通过collection标签为Order类中的List属性赋值，把查询结果映射到这个属性中 注意：查询的两个表中都有id这个字段，所以需要给一个id字段设置个别名，在resultMap中显式地去定义映射关系，否则查询结果可能无法正常映射，甚至会报错。 ​ ​ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/多对多查询.html":{"url":"frame3/多对多查询.html","title":"1.19 高级映射：多对多查询","keywords":"","body":"1.19 多对多查询 需求：通过订单id查询订单信息，以及对应的用户，对应的订单详情和订单中对应地商品信息 分析：这里涉及这4个表地关联查询 实体类Order： @Data @AllArgsConstructor @NoArgsConstructor public class Order implements Serializable { private Integer id; private Long userId; private String orderNumber; //添加User类型属性 private User user; //添加List private List orderDetails; private static final long serialVersionUID = 1L; } 实体类：OrderDetail： @Data @AllArgsConstructor @NoArgsConstructor public class OrderDetail implements Serializable { private Integer id; private Integer orderId; private Integer itemId; private Double totalPrice; private Integer status; //添加Item类型属性，通过订单详情查询对应的商品信息，把查询地商品信息映射到这个属性里 private Item item; private static final long serialVersionUID = 1L; } Dao接口： Order queryOrderdetails(Integer id); OrderMapper.xml： 属性中， 查询结果可能是多条，所以实体类中声明List类型 --> select o.*, od.id odid, od.item_id, od.order_id, od.total_price, od.status, u.id uid, u.user_name, u.password, u.name, u.age, u.sex, i.id iid, i.item_name, i.item_price, i.item_detail from tb_order o, tb_orderdetail od, tb_user u, tb_item i where o.id = od.order_id and u.id = o.user_id and od.item_id = i.id and o.id = #{id} 重点理解涉及多个表关联查询的时候，只能用一个实体类来接收，这时候怎么办呢，需要通过在实体类中添加涉及查询的其它实体类的属性，将关联的表的查询结果映射到对应类型的属性中 resultMap中涉及的两个标签association和collection，用于解决复杂的映射关系 当看到mybatis官方文档讲解高级映射这一块时，看到官方的代码示例真是一脸懵B，完全不知所以。等自己理解这其中的关系之后，感觉真实so easy Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame3/缓存.html":{"url":"frame3/缓存.html","title":"1.20 缓存","keywords":"","body":"1.20 缓存 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/Mybatis-Plus.html":{"url":"mybatisplus/Mybatis-Plus.html","title":"Mybatis-Plus","keywords":"","body":"Mybatis-Plus Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/快速入门.html":{"url":"mybatisplus/快速入门.html","title":"1. 快速入门","keywords":"","body":"1. 快速入门 新建Spring Boot项目，之后导入Mavan依赖： com.baomidou mybatis-plus-boot-starter 3.4.0 之后配置好数据源，创建实体类，这些都准备好之后，创建dao层接口： // 接口继承BaseMapper public interface UserMapper extends BaseMapper { } 继承BaseMapper接口之后，可以直接通过映射器对象进行单表的查询，无需再写接口方法以及SQL。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/通用传统模式简介及通用Mapper.html":{"url":"mybatisplus/通用传统模式简介及通用Mapper.html","title":"2. 通用传统模式简介及通用Mapper","keywords":"","body":"2. 通用传统模式简介及通用Mapper SSM传统编程模式： 接口中写抽象方法--》XML或注解写SQL--》Service中调用接口--》Controller中调用Service 通用Mapper： 新增(Create) Mybatis-plus中的BaseMapper接口定义了很多通用的抽象方法，我们直接调用即可。 @Autowired private UserMapper userMapper; @Test public void insert(){ User user = new User(9003L,\"刘华强\", 31, \"liu@qq.com\", 1001L, LocalDateTime.now()); userMapper.insert(user); } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/常用注解.html":{"url":"mybatisplus/常用注解.html","title":"3. 常用注解","keywords":"","body":"3. 常用注解 @TableName注解：当实体类名与表名不一致时，可以通过该注解声明对应的数据表名。 @TableId注解：作用属性，注明该属性是数据表中的主键id @TableField注解：作用属性，注明该属性对应数据表中哪个字段 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/排除非表字段的三种方法.html":{"url":"mybatisplus/排除非表字段的三种方法.html","title":"4. 排除非表字段的三种方法","keywords":"","body":"4. 排除非表字段的三种方法 有些时候，实体类中的一些属性不在数据表中，这种时候在做插入或更新时，由于实体类属性值不为null且在数据表中没有对应字段，所以运行时会报错。 解决： 属性使用transient关键字进行修饰 属性使用static关键字修饰 属性添加@TableField(exist = false)注解 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/普通查询.html":{"url":"mybatisplus/普通查询.html","title":"5. 普通查询","keywords":"","body":"5. 普通查询 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/条件构造器查询.html":{"url":"mybatisplus/条件构造器查询.html","title":"6. 条件构造器查询","keywords":"","body":"6. 条件构造器查询 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/select不例出全部字段.html":{"url":"mybatisplus/select不例出全部字段.html","title":"7. select不例出全部字段","keywords":"","body":"7. select不例出全部字段 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/condition作用.html":{"url":"mybatisplus/condition作用.html","title":"8. condition作用","keywords":"","body":"8. condition作用 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/实体作为条件构造器构造方法的参数.html":{"url":"mybatisplus/实体作为条件构造器构造方法的参数.html","title":"9. 实体作为条件构造器构造方法的参数","keywords":"","body":"9. 实体作为条件构造器构造方法的参数 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/AllEq用法.html":{"url":"mybatisplus/AllEq用法.html","title":"10. AllEq用法","keywords":"","body":"10. AllEq用法 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/其他使用条件构造器的方法.html":{"url":"mybatisplus/其他使用条件构造器的方法.html","title":"11. 其他使用条件构造器的方法","keywords":"","body":"11. 其他使用条件构造器的方法 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/lambda条件构造器.html":{"url":"mybatisplus/lambda条件构造器.html","title":"12. lambda条件构造器","keywords":"","body":"12. lambda条件构造器 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/自定义sql.html":{"url":"mybatisplus/自定义sql.html","title":"13. 自定义sql","keywords":"","body":"13. 自定义sql Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/分页查询.html":{"url":"mybatisplus/分页查询.html","title":"14. 分页查询","keywords":"","body":"14. 分页查询 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/更新方法.html":{"url":"mybatisplus/更新方法.html","title":"15. 更新方法","keywords":"","body":"15. 更新方法 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/删除方法.html":{"url":"mybatisplus/删除方法.html","title":"16. 删除方法","keywords":"","body":"16. 删除方法 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/AR模式.html":{"url":"mybatisplus/AR模式.html","title":"17. AR模式","keywords":"","body":"17. AR模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/主键策略.html":{"url":"mybatisplus/主键策略.html","title":"18. 主键策略","keywords":"","body":"18. 主键策略 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/基本配置.html":{"url":"mybatisplus/基本配置.html","title":"19. 基本配置","keywords":"","body":"19. 基本配置 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"mybatisplus/通用service.html":{"url":"mybatisplus/通用service.html","title":"20. 通用service","keywords":"","body":"20. 通用service Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/spring.html":{"url":"frame1/spring.html","title":"2. Spring","keywords":"","body":"Spring Spring简介： 2020年，首次推出Spring框架的出行：interface21框架 Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月23日，发布了1.0正式版。 创始人：Rod Johnson，悉尼大学博士，然而不是计算机专业博士，而是音乐学。 Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。 SSH：Struct2 + Spring + Hibernate SSM：SpringMVC + Spring + Mybatis 官网：https://spring.io/ 官方下载地址：https://repo.spring.io/release/org/springframework/spring/ Github：https://github.com/spring-projects/spring-framework Maven： org.springframework spring-webmvc 5.2.6.RELEASE org.springframework spring-jdbc 5.2.6.RELEASE Spring优点： Spring是一个开源免费的框架（容器）！ Spring是一个轻量级、非入侵式的框架 控制反转(IoC) 面向切面编程(AOP) 支持事务的处理 对框架整合的支持 ==总结：Spring就是一个轻量级的控制反转(IoC)和面向切面编程(AOP)的框架。== Spring组成： Spring Boot： 快速开发的脚手架 基于SpringBoot可以快速得开发单个微服务 约定大于配置 Spring Cloud： 基于Spring Boot实现的 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/ioc理论推导.html":{"url":"frame1/ioc理论推导.html","title":"2.1 IoC理论推导","keywords":"","body":"IoC理论推导 之前在操作数据库时，我们首先需要在Dao层定义接口，定义增删改查等抽象方法，然后在Dao层定义实现类来实现这些方法： UserDao接口 package com.neu.dao; public interface UserDao { //从数据库中获取用户数据 void getUser(); } UserDaoImpl实现类 package com.neu.dao; public class UserDaoImpl implements UserDao{ //实现接口中的方法，操作数据库获取用户数据 public void getUser() { System.out.println(\"默认获取用户的数据\"); } } 在Service层中定义和Dao层相同的接口，然后定义一个实现类来实现这些方法，使用实现的方法调用Dao层的接口，使用户面向业务层，而不是直接操作Dao层。 UserService接口 package com.neu.service; public interface UserService { //定义与Dao层接口相同的方法 void getUser(); } UserServiceImpl实现类 package com.neu.service; import com.neu.dao.UserDao; import com.neu.dao.UserDaoImpl; public class UserServiceImpl implements UserService{ private UserDao userDao = new UserDaoImpl(); /** * 业务层中实现的方法只用来调用Dao层实现类中的方法 */ public void getUser() { userDao.getUser(); } } 测试代码： import com.neu.service.UserServiceImpl; public class MyTest { public static void main(String[] args) { //用户实际调用的是service层，dao层他们不需要接触 UserServiceImpl userService = new UserServiceImpl(); userService.getUser();//调用业务层来实现功能 } } ==这里就会有一个问题：如果Dao层中有多个实现类需要操作的话，需要怎么办？== 下图是之前的做法，UserDao对象指向不同的实现类（子类）实例，来调用不同实现类的重写方法： 这里就会遇到一个很大的问题，==那就是如果再增加需求，就需要再次修改业务层的代码，如果项目很大的话，就需要修改很多的代码，这明显不是一个好的程序。== 所以，需要换一个思路来解决这个问题： 这样，用户可以自己去选择调用哪个，而不需要在业务层上做修改： 总结： 修改前和修改后的区别： 修改前，程序是主动创建对象，控制权在程序员手里，程序员需要去手动修改业务层创建哪个对象去调用哪个实现类 之后set注入之后，程序不再具有主动性，而是变成了被动接受对象，传入哪个实现类对象，就可以调用哪个实现类 这种思想，从本质上解决了问题，程序猿不用再去管理对象的创建了，大大降低了系统的耦合性，可以更加专注在业务的实现上，这就是IoC的原型。 IoC的本质： 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是：获得依赖对象的方式反转了。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把二者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的。 控制反转是一种通过(XML或注解)并通过第三方去生产或获取特定对象的方法。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入(Dependency Injection,DI)。 写完第一个Spring Hello程序，回来用Spring的方式改造下上面的例子： 1. 在resources中创建beans.xml文件： 2. 测试： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/hello-spring.html":{"url":"frame1/hello-spring.html","title":"2.2 Hello Spring","keywords":"","body":"Hello Spring 创建第一个Spring程序，体会Spring的使用方式和IoC控制反转的思想，IoC控制反转的实现方式是DI依赖注入。 创建Maven项目并添加坐标： org.springframework spring-webmvc 5.2.6.RELEASE 添加spring-webmvc，Maven会自动导入其他的Spring依赖。 创建实体类Hello： Java代码： package com.neu.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Hello{\" + \"str='\" + str + '\\'' + '}'; } } 在resources中创建Spring配置文件： XML配置文件：起名beans.xml（文件名自定义） XML配置文件说明： 之前传统Java在实例化对象的时候都需要去主动new对象 而在Spring中，将实体类交由Spring容器去管理，通过配置XML或注解的方式 在XML配置文件中，可以使用bean标签去绑定多个实体类，之后再通过获取ApplicationContext对象，来获取实体类的对象。 测试： Java代码： import com.neu.pojo.Hello; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象现在都在Spring中管理了，我们要使用，直接去Spring里面取 Hello hello = (Hello) context.getBean(\"hello\"); System.out.println(hello); } } 总结一句话：对象由Spring来创建、管理、装配。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/IoC创建对象的方式.html":{"url":"frame1/IoC创建对象的方式.html","title":"2.3 IoC创建对象的方式","keywords":"","body":"IoC创建对象的方式 无参构造创建对象： Spring默认调用无参构造器来创建对象。 在获取Spring的ApplicationContext对象，加载xml配置文件时，xml中所有的Bean就被初始化了。 有参构造创建对象： 当实体类中只有带参构造，没有无参构造器时，XML中会报错，因为Spring是默认调用实体类的无参构造器来创建对象的，这时，可以用几种不同的方式使用带参构造器来创建对象： 实体类Student： package com.neu.pojo; public class Student { private String name; public Student(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void show() { System.out.println(\"name = \" + name); } } 使用带参构造器创建对象，需要使用constructor-arg标签 方式一：index下标，为构造器参数赋值，0为第一个参数 方式二：type类型，根据带参构造的参数类型赋值（不建议使用） 方式三：name属性，通过参数名为参数赋值 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/Spring配置.html":{"url":"frame1/Spring配置.html","title":"2.4 Spring配置","keywords":"","body":"2.4 Spring配置 别名：alias 使用alias给Bean添加个别名 测试代码： import com.neu.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"u1\");//getBean(\"Bean的别名\") System.out.println(user); } } Bean的配置： id:Bean的唯一标识符，相当于对象名 class：Bean对象所对应的类型，使用全限定名 name：也是别名，而且name可以同时取多个别名，并且可以通过空格，逗号，分号分割 import： import一般用于团队开发使用，它可以将多个配置文件，导入合并成一个 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/依赖注入DI.html":{"url":"frame1/依赖注入DI.html","title":"2.5 依赖注入(DI)","keywords":"","body":"2.5 依赖注入(DI) 基于构造器的依赖注入，参照【IoC创建对象的方式】 基于setter的依赖注入 其他方式注入 set注入：【重点】 依赖注入：set注入 依赖：Bean对象的创建依赖于Spring容器 注入：Bean对象中的所有属性由容器来注入 创建实体类Student，里面定义了各种类型参数，分别注入： 其中Address是自定义的类，里面只有一个String address参数和get/set方法 public class Student { private String name; private Address address; private String[] books; private List hobbies; private Map cards; private Set games; private Properties info; private String wife; } xml中的注入方式： Java编程思想 数据结构与算法 打游戏 写代码 看动漫 奥日与黑暗森林 消逝的光芒 巫师三 --> root 123456 p命名注入、c命名空间注入 需要先导入xml约束：xmlns:p xmlns:c 导入方式： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/bean的作用域.html":{"url":"frame1/bean的作用域.html","title":"2.6 Bean的作用域","keywords":"","body":"2.6 Bean的作用域 Bean scopes: singleton：单例，全局唯一 prototype：原型，每一个都是单独的对象 request： session： application： websocket： Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 单例： Spring的Bean默认是单例的 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"userbean.xml\"); User user = context.getBean(\"user\",User.class); User use2 = context.getBean(\"user\",User.class); System.out.println(user==use2); } //结果是true 原型： 测试： @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"userbean.xml\"); User user = context.getBean(\"user\",User.class); User use2 = context.getBean(\"user\",User.class); System.out.println(user==use2); } //结果是false 原型模式：每次从容器中get的时候，都会产生新的对象 其余的： 其余的request、session、application只能在web开发中使用。 request：请求响应一次之后，request就销毁 session： application： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/bean的自动装配.html":{"url":"frame1/bean的自动装配.html","title":"2.7 Bean的自动装配","keywords":"","body":"2.7 Bean的自动装配 自动装配是Spring满足Bean依赖一种方式 Spring会在上下文中自动寻找，并自动给Bean装配属性 在Spring中有三种装配方式： 在xml中显式配置 在Java中显式配置 隐式地自动配置Bean【重要】 搭建测试环境： 一个人两个动物： package com.neu.pojo; public class Person { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } Dog类： package com.neu.pojo; public class Dog { public void shout(){ System.out.println(\"汪汪汪~\"); } } Cat类： package com.neu.pojo; public class Cat { public void shout(){ System.out.println(\"喵喵喵~\"); } } Beans.xml： Test类： import com.neu.pojo.Person; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { @Test public void test1() { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Person person = context.getBean(\"person\", Person.class); person.getDog().shout(); person.getCat().shout(); } } 结果： 汪汪汪~ 喵喵喵~ ByName自动装配 ByType自动装配： 小结： ByName的时候，要保证所有Bean的id唯一，并且Bean的id要和自动装配的属性的set方法的值一致 ByType的时候，要保证Bean的Class唯一，并且这个Bean需要和自动装配的属性的类型一致 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/注解实现自动装配.html":{"url":"frame1/注解实现自动装配.html","title":"2.8 注解实现自动装配","keywords":"","body":"2.8 注解实现自动装配 官网文档说： The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” 使用注解开发，需要： 导入约束：xmlns:context=\"http://www.springframework.org/schema/context\" 添加配置：\\ @Autowired 是Spring的注解 直接在属性上使用即可，也可以在setter方法上使用 使用@Autowired注解，可以是写setter方法，前提是自动装配的属性在IoC(Spring)容器中存在，且符合ByName @Autowired(required = false) private Cat cat; 如果@Autowired注解显示地定义了required = false，则该对象可以为null @Autowired是通过容器中的对象的id或对象的Class进行匹配实现自动装配的，如果容器中有多个相同Class的对象，并且对象的id和要装配的属性名对应不上，则会报错或不会自动装配。 public class Person { @Autowired private Cat cat; @Autowired private Dog dog; private String name; //... } 容器：容器中的Cat和Dog的bean有多个且id和上面的属性名对不上，则会报错 这时，可以使用@Qualifier(value = \"cat1\")注解，解决这个这个问题。 public class Person { @Autowired @Qualifier(value = \"cat1\") private Cat cat; @Autowired @Qualifier(value = \"dog2\") private Dog dog; private String name; } 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解完成的时候，就可以使用@Qualifier(value = \"XXX\")配合@Autowired使用，指定去装配唯一的Bean对象。 @Resource 是javax的注解 @Resource(name = \"cat1\") private Cat cat; 用法和@Autowired差不多，可以单独使用，也可以指定name指定装配哪个Bean 小结：@Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired 通过ByType的方式实现，而且必须要求这个对象存在 @Resource 默认通过ByName的方式实现，如果Bean的id与属性名不匹配，则通过ByType实现，如果两个都找不到则报错 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/Spring注解开发.html":{"url":"frame1/Spring注解开发.html","title":"2.9 Spring注解开发","keywords":"","body":"2.9 Spring注解开发 在Spring4之后，使用注解开发，必须要保证导入了AOP依赖 使用注解需要导入context约束，增加注解支持 @Autowired 自动装配，自动给属性装配值（在容器中找到Bean并装配） 会自动在Ioc容器上下文中查找，找到同类型的Bean，并装配。ByType方式（默认） 会自动在IoC容器上下文中查找，找到与属性set方法同名的Bean（setXxx()，即找到Xxx）并装配，ByName方式 通过类型可能会找到多个Bean，然后会通过name去确定装配哪一个，如果name确定不了，可以通过@Qualifier注解装配指定的Bean @Nullable 该注解修饰属性，则该属性允许为null @Resource javax中的注解 用法和@Autowired类似，可以单独使用，也可以通过name或class自动装配指定Bean @Resource(name = \"cat1\") @Component Spring上下文配置文件中，扫描指定包 扫描到该注解作用的类，会自动注册到IoC容器中，自动注册Bean 衍生注解： Dao层：@Repository service层：@Service controller层：@Controller 配置文件中要配置组件扫描指定包，Spring扫描到这些注解，就会自动注册Bean @Scope(\"prototype\") 配置注册Bean的作用域，单例、原型等等 @Value 相当于 可以作用在属性，或setter上 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/使用JavaConfig实现配置.html":{"url":"frame1/使用JavaConfig实现配置.html","title":"2.10 使用JavaConfig实现配置","keywords":"","body":"2.10 使用JavaConfig实现配置 通过JavaConfig来配置Spring，而不实用XML配置 JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心项目。 实体类User： package com.neu.pojo; import org.springframework.beans.factory.annotation.Value; public class User { private String name; public String getName() { return name; } @Value(\"张三\") public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } 配置类： package com.neu.config; import com.neu.pojo.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(\"com.neu.pojo\") public class AppConfig { @Bean public User user(){ return new User(); } } @Configuration作用在类上，说明这是一个Spring配置类 @Bean注册到IoC容器的Bean，方法名就是Bean的名字 方法名：相当于id 返回值：相当于class return：相当于Bean注入的对象 @ComponentScan(\"com.neu.pojo\")扫描组件 @Import(AppConfig2.class)引入其它配置类 获取配置类的上下文对象 ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); 这种纯Java的配置方式，在SpringBoot中随处可见 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/spring-test.html":{"url":"frame1/spring-test.html","title":"2.11 spring-test","keywords":"","body":"spring-test Maven坐标： org.springframework spring-test 5.2.7.RELEASE test 还需要导入junit依赖： junit junit 4.11 test org.junit.jupiter junit-jupiter-api 5.6.2 test 简单用法： Spring + Junit4： @RunWith(SpringRunner.class) @ContextConfiguration(locations = {\"classpath:ApplicationContext.xml\"}) public class TestUserService{ //自动装配 @Autowired @Qualifier(\"userServiceImpl\") UserService userService; @Test public void test(){ } } @RunWith(SpringRunner.class)测试环境 @ContextConfiguration(locations = {\"classpath:ApplicationContext.xml\"})导入上下文配置 这是两个常用注解，测试类中可以实现自动装配 Spring + Junit5： @ExtendWith(SpringExtension.class) @ContextConfiguration(locations = {\"classpath:ApplicationContext.xml\"}) public class TestUserService{ //自动装配 @Autowired @Qualifier(\"userServiceImpl\") UserService userService; public void test(){ } } @ExtendWith(SpringExtension.class)替换了Junit4的RunWith @ContextConfiguration(locations = {\"classpath:ApplicationContext.xml\"})导入上下文配置 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/静态代理模式.html":{"url":"frame1/静态代理模式.html","title":"2.12 静态代理模式","keywords":"","body":"2.12 静态代理模式 代理模式是Spring AOP（面相切面编程）的底层实现。 代理模式是Java23种设计模式之一。 代理模式分类： 静态代理 动态代理 静态代理 角色分析： 抽象角色：一般会使用接口或抽象类来解决 真实角色：被代理的角色（上图中指代房东） 代理真实：代理真实角色，除了代理真实角色的业务之外，还会做一些附加的操作 客户：访问代理角色的人（我本人） 代码步骤： 接口： //主要业务，出租房子 public interface Rent { void rent(); } 真实角色：只需关注自己的业务，不用去关注其它 //房东 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房东要出租房子\"); } } 代理 //中介（代理） public class Proxy implements Rent{ private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { host.rent(); } /** * 除了代理真实角色的业务，还有一些附加操作 */ public void seeHose(){ System.out.println(\"中介带你看房\"); } public void fare(){ System.out.println(\"中介收中介费\"); } } 客户端访问代理角色 //客户 public class Client { public static void main(String[] args) { Host host = new Host(); Proxy proxy = new Proxy(host);//找到中介 proxy.rent(); } } 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注公共的业务 公共业务也交给代理角色，实现业务分工 公共业务发生扩展的时候，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，降低开发效率 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/动态代理.html":{"url":"frame1/动态代理.html","title":"2.13 动态代理","keywords":"","body":"2.13 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理，基于接口的动态代理和基于类的动态代理 基于接口：JDK动态代理 基于类：cglib Java字节码实现：javasist 需要知道两个类： Proxy：代理 InvocationHandler：调用处理程序 InvocationHandler 它是一个接口，在java.lang.reflect包下 方法：Objext invoke(Object proxy,method方法,Object[] args) throws Throwable Proxy 它是一个类，在java.lang.reflect包下 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * 代理调用处理程序 * 用来生成代理类 */ public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口或类 private Object target; public void setTarget(Object target) { this.target = target; } /** * 生成代理类 * @return */ public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(), this); } /** * 处理代理实例，并返回结果（执行真实角色的方法） * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = method.invoke(target, args); return result; } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/AOP实现方式一.html":{"url":"frame1/AOP实现方式一.html","title":"2.14 AOP实现方式一","keywords":"","body":"2.14 AOP实现方式 AOP(Aspect Oriented Programming) 面向切面编程（面向方面编程），通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。 先导入AOP织入依赖 org.aspectj aspectjweaver 1.9.5 AOP在Spring中的作用： 提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能，即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点，如日志、安全、缓存、事务等等... 切面(ASPECT)：横切关注点，被模块化的特殊对象，即一个类，是切入点和通知的结合 通知/增强(Advice)：增强代码，切面必须要完成的功能。即它是类中的一个方法，如before、after... 目标(Target)：被通知对象，需要被代理的类 代理(Proxy)：向目标对象应用通知之后创建的对象 切入点(PointCut)：切面通知 执行的”地点“的定义，即在哪个方法处切入 连接点(JointPoint)：与切入点匹配的执行点 增强/通知（Advice）的五中方式： 前置通知：在切入点方法执行前执行（@Before） 后置通知：在切入点方法执行结束后执行，不管有没有异常（@After） 返回通知：在切入点方法正常返回值之后执行（@AfterReturning） 异常通知：在切入点方法出现异常后执行（@AfterThrowing） 环绕通知：动态代理，需要手动执行joinPoint.procced() ​ (其实就是执行切入点方法之前执行，类似于前置通知, 执行之后就相当于后置通知@Around) 方式一：使用Spring API接口 public class Log implements MethodBeforeAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { } } before方法的三个参数： method：要执行的目标对象的方法 args：参数 target：目标 代码示例： 前置通知： @Component public class Log implements MethodBeforeAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName() + \"的\" + method.getName() + \"被执行了\"); } } 后置通知： @Component public class AfterLog implements AfterReturningAdvice { @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\"执行了\" + method.getName() + \"，返回结果为：\" + o); } } Xml: 测试： @ExtendWith(SpringExtension.class) @ContextConfiguration(locations = {\"classpath:applicationContext.xml\"}) public class MyTest { @Autowired UserService userService; @Test public void test(){ userService.query(); } } 只能通过UserService接口对象去调用，代理只能代理接口 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/AOP实现方式二.html":{"url":"frame1/AOP实现方式二.html","title":"2.15 AOP实现方式二","keywords":"","body":"2.15 AOP实现方式二 使用自定义类（自定义切面） 自定义通知类： @Component public class UserAdvice{ //最终通知 public void after(){ System.out.println(\"最终通知\"); } //前置通知 public void before(){ System.out.println(\"前置通知\"); } //后置通知 public void afterReturn(){ System.out.println(\"后置通知\"); } //环绕通知 public void around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"环绕通知，被拦截之前执行\"); joinPoint.proceed(); System.out.println(\"环绕通知，被拦截之后执行\"); } } Xml： 测试： @ExtendWith(SpringExtension.class) @ContextConfiguration(locations = {\"classpath:ApplicationContext.xml\"}) public class TestUserDao { @Autowired UserDao userDao; @Test public void test(){ userDao.queryUser(); } } 结果： 前置通知 环绕通知，被拦截之前执行 查询User 环绕通知，被拦截之后执行 后置通知 最终通知 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/注解实现AOP.html":{"url":"frame1/注解实现AOP.html","title":"2.16 注解实现AOP","keywords":"","body":"2.16 注解实现AOP 几种常用注解： @Aspect：标记类为切面 @Pointcut(\"execution(* com.neu.service.LoginServiceImpl.*(..))\")：作用方法，参数设置切入点 @Before()：前置通知，需要指定切入点 @After()：后置通知，需要指定切入点 @AfterReturning()：返回通知，需要指定切入点 @AfterThrowing()：异常通知，需要指定切入点 @Around()：环绕通知，需要指定切入点 配置文件中需要将切面类注册Bean，并开启注解支持： 代码示例： 通知/增强类： @Aspect @Component public class LoginAdvice { @Pointcut(\"execution(* com.neu.service.LoginServiceImpl.*(..))\") public void pointcut(){} /** * 方法执行前执行 */ @Before(\"pointcut()\") public void before(){ System.out.println(\"前置通知\"); } /** * 方法执行后执行 */ @After(\"pointcut()\") public void after(){ System.out.println(\"后置通知\"); } /** * 在环绕增强中，给定一个参数，代表我们要获取处理切入的点 */ @Around(\"pointcut()\") public void around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"环绕前\"); joinPoint.proceed(); System.out.println(\"环绕后\"); } } XML只需要开启注解支持即可： 测试： @ExtendWith(SpringExtension.class) @ContextConfiguration(locations = \"classpath:ApplicationContext.xml\") public class TestLoginService { @Autowired LoginService loginService; @Test public void test(){ loginService.login(); } } 结果： 环绕前 前置通知 调用了Dao层登录方法 环绕后 后置通知 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/整合Mybatis.html":{"url":"frame1/整合Mybatis.html","title":"2.17 整合Mybatis","keywords":"","body":"2.17 整合Mybatis方式一 回顾Mybatis使用流程： 导入Mybatis的Maven坐标 编写实体类 编写核心配置文件 编写接口，定义方法 编写Mapper.xml（记得要在mybatis配置文件中注册） 测试 MyBatis-Spring 官方文档：https://mybatis.org/spring/zh/ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 在 MyBatis-Spring 中，可使用 SqlSessionFactoryBean来创建 SqlSessionFactory。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 注意：SqlSessionFactory 需要一个 DataSource（数据源）。 这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 小结： Spring容器中，先创建dataSource 在创建sqlSessionFactory 有了sqlSessionFactory之后，就可以做很多事情了，下面通过不同的方式，来实现执行SQL： 方式一： 获取sqlSessionTemplate sqlSessionTemplate就相当于mybatis中的sqlSession，可以getMapper()获取获取映射器对象执行接口中的方法。 方式二： 通过MapperFactoryBean 将接口加入到 Spring 中 官方文档说：所指定的映射器类必须是一个接口，而不是具体的实现类。 配置好之后，你就可以像 Spring 中普通的 bean 注入方法那样，将映射器注入到你的业务或服务对象中。MapperFactoryBean 将会负责 SqlSession 的创建和关闭。如果使用了 Spring 的事务功能，那么当事务完成时，session 将会被提交或回滚。最终任何异常都会被转换成 Spring 的 DataAccessException 异常。 测试代码： @Autowired UserMapper userMapper; @Test public void test() { List users = userMapper.queryAll(); System.out.println(users); } 方式三： 通过MapperScannerConfigurer配置映射器扫描，将包内的接口都注册到Spring中 测试方法： @Autowired UserMapper userMapper; @Test public void test() { List users = userMapper.queryAll(); System.out.println(users); } 同方式二类似，方式二是指定映射器接口，这种方法是直接扫描包。 这三种方法都需要sqlSessionFactory的支持 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame1/Spring声明式事务.html":{"url":"frame1/Spring声明式事务.html","title":"2.19 Spring声明式事务","keywords":"","body":"2.19 Spring声明式事务 回顾事务： 事务：要么都成功，要么都失败 事务在项目开发中十分重要，涉及到数据的一致性问题 确保数据完整性和一致性 事务的ACID的原则： A：原子性 C：一致性 I：隔离性：多个业务操作同一个资源时，防止数据损坏 D：持久性：事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化到存储中 事务： 一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。 一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。 事务配置好了以后，MyBatis-Spring 将会透明地管理事务。这样在你的 DAO 类中就不需要额外的代码了。 Spring中的事务分两类： 编程式事务：需要在代码中进行事务管理 声明式事务：AOP 标准配置： 要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象： 传入的 DataSource 可以是任何能够与 Spring 兼容的 JDBC DataSource。包括连接池和通过 JNDI 查找获得的 DataSource。 注意：为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。 通过AOP织入事务： 默认情况下，代理被创建都是基于接口的，但有些情况会出现类型注入错误的问题，那么就开启基于类创建： 注解配置： 在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象，之后开启注解支持： 声明式事务可以直接使用@Transactional注解来配置，看一下@Transactional注解都有啥： @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Transactional { // 别名为transactionManager，其实这两是同一个。就是事务的名字。 @AliasFor(\"transactionManager\") String value() default \"\"; // 事务的传播行为，默认值为REQUIRED Propagation propagation() default Propagation.REQUIRED; // 事务的隔离级别，默认为默认值(也就是使用底层数据库的隔离级别) Isolation isolation() default Isolation.DEFAULT; // 超时时间，默认为 -1，也就是没有超时时间。 int timeout() default TransactionDefinition.TIMEOUT_DEFAULT; // 是否只读，默认为false。 boolean readOnly() default false; // 会触发事务回滚的异常的字节码数组 Class[] rollbackFor() default {}; // 不会触发事务回滚的异常的字节码数组 Class[] noRollbackFor() default {}; } 复制代码 这里直接在实现类上使用，这个注解还可以在接口（一般不在接口上使用）和方法上使用（可见性必须为public，否则会被忽略）。 事务的隔离级别： 通过org.springframework.transaction.annotation.Isolation 这个枚举类来指定。 public enum Isolation { // 这是默认值，表示使用底层数据库的默认隔离级别。对于MySQL的InnoDB存储引擎，它是REPEATABLE_READ，其它一般的都是READ_COMMITTED DEFAULT(-1), // 跟没有一样，几乎不使用。 READ_UNCOMMITTED(1), // 只能读取另一个事务已提交的事务，能防止脏读。也是一般数据库的默认隔离级别。 READ_COMMITTED(2), // 可重复读(在一个事务内多次查询的结果相同，其它事务不可修改该查询条件范围内的数据，相当于加了个读锁) REPEATABLE_READ(4), // 所有的事务依次逐个执行,相当于串行化了，效率太低，一般也不使用。 SERIALIZABLE(8); } 事务的传播行为： 如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。org.springframework.transaction.annotation.Propagation枚举类中定义了7表示传播行为的枚举值。 public enum Propagation { // 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 REQUIRED(0), // 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 SUPPORTS(1), // 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 MANDATORY(2), // 创建一个新的事务，如果当前存在事务，则把当前事务挂起。 REQUIRES_NEW(3), // 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED(4), // 以非事务方式运行，如果当前存在事务，则抛出异常。 NEVER(5), // 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。 NESTED(6); } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/springMVC.html":{"url":"frame2/springMVC.html","title":"3. SpringMVC","keywords":"","body":"SpringMVC 什么是SSM？ SSM：mybatis + spring + springMVC SSM的应用图示： 什么是MVC？ MVC分别指代：Model模型、View视图、Controller控制器，MVC是一种软件设计模型，一种设计思想，一种设计规范。 The request processing workflow in Spring Web MVC (high level) SpringMVC中，引入了一个DispatcherServlet（调度者Servlet）的模式， Spring的Web MVC框架是由请求驱动的，围绕中央Servlet设计（即DispatcherServlet），该Servlet将请求分发给其他控制器并提供其他功能来促进Web应用程序的开发。 Spring Web MVC中的典型上下文层次结构 第一个SpringMVC程序搭建 配置web.xml 注册DispatcherSerlvet，并关联SpringMVC的配置文件 springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:springmvc-servlet.xml 1 springmvc / 配置springmvc-servlet.xml 创建一个类实现Controller接口并实现handleRequest()方法 package com.neu.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //实例化ModelAndView对象 ModelAndView mv = new ModelAndView(); //添加一个属性 mv.addObject(\"msg\",\"Hello SpringMVC\"); //设置跳转，设置ViewName，该名称会通过xml的前缀和后缀拼接成/WEB-INF/jsp/hello.jsp mv.setViewName(\"hello\"); return mv; } } 运行Tomcat，浏览器访问http://localhost:8080/springmvc_02_hellomvc/hello 注意事项：浏览器访问可能会出现404问题 检查代码和Tomcat是否有问题 添加相关依赖 重启Tomcat，再次访问 总结： 通过web.xml配置DispatcherServlet，即调度Servlet 创建自定义的HelloController类并实现Controller接口 配置上下文springmvc-servlet.xml，该配置文件中配置了HelloController的bean 浏览器访问http://localhost:8080/springmvc_02_hellomvc/hello，具体请求流程： 浏览器发出请求会先找到web.xml中注册的DispatcherServlet 之后找到DispatcherServlet关联的SpringMVC配置文件 通过BeanNameUrlHandlerMapping和SimpleControllerHandlerAdapter来找可以处理该请求的handler 在上下文配置文件中找到/hello， 再通过/hello找到对应的HelloController类，执行类中handleRequest()方法 在handleRequest()方法中通过（ModelAndView(模型和视图)：模型用来存储数据，视图用来设置要跳转的页面资源）对象添加了一个msg数据，并设置跳转的视图名称，返回ModelAndView对象 之后会通过SpringMVC配置文件的中的视图解析器拼接完整的视图资源地址，跳转到该视图页面，此时，整个请求的处理流程结束~ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/SpringMVC执行流程.html":{"url":"frame2/SpringMVC执行流程.html","title":"3.1 SpringMVC执行流程","keywords":"","body":"3.1 SpringMVC执行流程 分步解析： DispatcherServlet表示前置控制器（调度器），是整个SpringMVC的控制中心，用户发出请求，DispatcherServlet接收请求并拦截请求。 假设请求的url为http://localhost:8080/SpringMVC/hello 把这个url拆分成3个部分： http://localhost:8080表示服务器域名 /SpringMVC是部署在这个服务器上的web站点 /hello表示控制器 通过分析，这个url表示为，请求位于http://localhost:8080上的/SpringMVC站点的/hello控制器 HandlerMapping为处理器映射，由DIspatcherServlet调用： HandlerMapping根据请求url查找Handler HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器，如上url被查找到的控制器为hello HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler Handler让具体的Controller执行 Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet DispatcherServlet调用视图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名 视图解析器将解析的逻辑视图名传递给DispatcherServlet DispatcherServlet根据视图解析器的视图结果，调用具体的视图 最终视图呈现给用户 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/SpringMVC使用注解开发.html":{"url":"frame2/SpringMVC使用注解开发.html","title":"3.2 SpringMVC使用注解开发","keywords":"","body":"3.2 SpringMVC使用注解开发 代码示例： 配置web.xml（使用version 4.0） springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:springmvc-servlet.xml 1 springmvc / 配置springmvc-servlet.xml： 编写Controller类： package com.neu.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"demo\") public class HelloController { @RequestMapping(\"/hello\") public String hello(Model model) { //封装数据 model.addAttribute(\"msg\", \"Hello SpringMVC!\"); //返回的字符串会被视图解析器处理 return \"hello\"; } } 这里面需要解释一下： @Controller注解，（省去了之前需要实现Controller接口的步骤） @RequestMapping(\"/hello\")注解，（省去了在配置文件中配置Handler映射和配置Handler）； 该注解既可以作用于类，也可以作用于方法，像案例中类和方法中都使用了注解，则访问地址为http://localhost:8080/springmvc_03_annotation/demo/hello，要注意访问路径的层级关系。 之前的Servlet实现一个功能就要写一个Servlet类，而现在只需要定义方法即可，使用@RequestMapping()注解 方法return的字符串返回的是ViewName，该字符串会传递给视图解析器，通过解析器得到完整的视图资源路径，最后交由DispatcherServlet，给用户响应最终的视图资源。 如果需要返回像Json字符串，可以通过@RestController注解，该注解下返回的字符串不会被视图解析器解析，而是直接返回字符串 最后小结： SpringMVC使用注开发步骤： 新建一个Web项目 导入相关依赖 编写web.xml，注册DispatcherServlet 编写SpringMVC配置文件 创建对应的控制类，Controller 完善前端视图和Controller之间的对应关系 测试运行调试 使用SpringMVC必须配置的三大件： 处理器映射器 处理器适配器 视图解析器 通常我们只需要手动配置视图解析器即可，而处理器映射器和处理器适配器只需要开启注解驱动即可 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/controller控制器.html":{"url":"frame2/controller控制器.html","title":"3.3 Controller 控制器","keywords":"","body":"3.3 Controller 控制器 控制器 Controller 控制器负责提供访问应用程序的的行为，通常通过接口定义或注解定义两种方法实现 控制器负责解析用户的请求并将其转换为一个模型 在SpringMVC中，一个控制器类可以包含多个方法 在SpringMVC中，对于Controller的配置方式有很多种 具体的实现方法： 实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法： //实现该接口的类会获取控制器功能 @FunctionalInterface public interface Controller { //处理请求返回一个模型和视图对象 @Nullable ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception; } 代码示例： 新建模块，springmvc-04-controller 配置web.xml、springmvc-04-servlet.xml 编写Controller类，ControllerDemo1实现Controller接口 package com.neu.controller; /** * 只要实现了Controller接口的类，这个类就是一个控制器 */ public class ControllerDemo1 implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerDemo1\"); mv.setViewName(\"test1\"); return mv; } } 控制器定义完毕，在springmvc-04-servlert.xml中注册Bean，id对应请求的路径，class对应控制器类 编写test1.jsp页面，注意在WEB-INF/jsp目录下，对应视图解析器 Title ${msg} 运行Tomcat，访问：http://localhost:8080/springmvc_04_controller/controllerDemo 小结： 实现Controller接口定义控制器是比较老的办法 缺点：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦，除了要定义多个控制器类之外，还需要在上下文配置中注册多个Bean 使用注解@Controller @Controller注解类型用于声明Spring类的实例时一个控制器，这几个注解的作用是相同的 @Component 组件 @Service service @Controller controller @Repository dao Spring可以使用扫描机制来找到对应程序中所有的基于注解的控制器类，为了保证Spring能找到控制器，需要在上下文配置中声明组件扫描： 代码示例： 配置spring-04-servlet.xml 编写控制类ControllerDemo2，不需要实现Controller接口，而是通过@Controller注解 package com.neu.controller; @Controller /** * @Controller 代表这个类会被Spring托管 * 这个类中的所有方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析 */ public class ControllerDemo2 { @RequestMapping(\"controllerDemo2\") public String test(Model model) { model.addAttribute(\"msg\", \"ControllerDemo2\"); return \"test1\"; } } 同样是转发到test1.jsp的页面 编写完控制器后，不需要在上下文配置中注册Bean 运行Tomcat，访问：http://localhost:8080/springmvc_04_controller/controllerDemo2 小结： 使用注解可以在同一个控制器类实现多个方法，并且省去了在上下文配置文件中注册Bean的过程 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/RequestMapping.html":{"url":"frame2/RequestMapping.html","title":"3.4 RequestMapping","keywords":"","body":"3.4 RequestMapping @RequestMapping注解 该注解用于映射url到控制器类或控制器类中的特定方法，所以该注解既可以作用在类上，也可以作用在方法上。 用于类上，表示类中的所有的响应请求的方法都是以该地址作为父路径 代码示例： 注解只作用在方法上： package com.neu.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class ControllerDemo3 { @RequestMapping(\"t1\") public String test1(Model model){ model.addAttribute(\"msg\",\"ControllerDemo3中的test1\"); return \"test1\"; } } 访问test1方法，访问的路径应该是http://localhost:8080/springmvc_04_controller/t1 注解同时作用在类和方法上： package com.neu.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/c3\") public class ControllerDemo3 { @RequestMapping(\"t1\") public String test1(Model model){ model.addAttribute(\"msg\",\"ControllerDemo3中的test1\"); return \"test1\"; } } 访问test1方法，访问的路径应该是http://localhost:8080/springmvc_04_controller/c3/t1 如果这个控制器中包含多个方法，那么访问任何一个方法都要经过/c3 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/RestFul风格.html":{"url":"frame2/RestFul风格.html","title":"3.5 RestFul风格","keywords":"","body":"3.5 RestFul风格 RestFul就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 代码示例： @Controller public class RestFulController { @RequestMapping(\"/add\") public String test1(int a, int b, Model model) { int res = a + b; model.addAttribute(\"msg\", \"结果为：\" + res); return \"test1\"; } } 方法参数定义了两个整型变量a和b，会直接获取到前端请求中的a和b 请求路径是这个样子的：http://localhost:8080/springmvc_04_controller/add?a=1&b=2 方法获取到请求中的参数a和b，相加之后再放到msg中 RestFul风格： 在SpringMVC中可以使用@PathVarible注解，让方法参数的值对应绑定到URI模板变量上。 @Controller public class RestFulController { @RequestMapping(value = \"/add/{a}/{b}\", method = RequestMethod.GET) public String test1(@PathVariable int a, @PathVariable int b, Model model) { int res = a + b; model.addAttribute(\"msg\", \"结果为：\" + res); return \"test1\"; } } 请求路径变为这个样子：http://localhost:8080/springmvc_04_controller/add/2/5 @RequestMapping还可以通过method来约束请求方式： @RequestMapping(value = \"/add/{a}/{b}\", method = RequestMethod.GET) 也可以通过这几种注解来代替@RequestMapping来设置请求方式： @GetMapping 相当于@RequestMapping(method = RequestMethod.GET) @PostMapping @PutMapping @DeleteMapping @PatchMapping Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/重定向和转发.html":{"url":"frame2/重定向和转发.html","title":"3.6 重定向和转发","keywords":"","body":"3.6 重定向和转发 通过视图解析器跳转资源 设置ModelAndView对象，根据ViewName，和视图解析器跳转到指定的页面资源 页面：[视图解析器前缀] + ViewName + [视图解析器后缀] 通过HttpServlet跳转资源 除了使用视图解析器跳转资源外，还可以通过原生的Servlet API实现资源的跳转 通过HttpServletResponse进行输出 通过HttpServletResponse重定向 通过HTTPServletRequest转发 例如： @GetMapping(\"/t1\") public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().write(\"test方法\"); } 通过SpringMVC跳转资源 通过SpringMVC来实现转发和重定向，无需视图解析器 @Controller public class ModelTest1 { //转发 @GetMapping(\"/t1\") public String test(Model model) { model.addAttribute(\"msg\",\"转发\"); return \"/WEB-INF/jsp/hello.jsp\"; } //显式地声明：转发 @GetMapping(\"/t2\") public String test2(Model model) { model.addAttribute(\"msg\",\"转发\"); return \"forward:/WEB-INF/jsp/hello.jsp\"; } //显式地声明： @GetMapping(\"/t3\") public String test3(Model model) { model.addAttribute(\"msg\",\"重定向\"); return \"redirect:/hello.jsp\"; } } 注意：使用重定向时，本质是重新请求到一个新的资源路径，不需要视图解析器，但是要注意重定向路径的问题 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/接收请求参数及数据回显.html":{"url":"frame2/接收请求参数及数据回显.html","title":"3.7 接收请求参数及数据回显","keywords":"","body":"3.7 接收请求参数及数据回显 接收请求参数： 方法中定义形参来接收前端的请求参数： @Controller @RequestMapping(\"/user\") public class UserController { @GetMapping(\"t1\") public String test(String name,Model model) { //1. 接收前端参数 System.out.println(name); //2. 将接收到的结果传递给前端 model.addAttribute(\"msg\",name); return \"test1\"; } } 请求URL：http://localhost:8080/springmvc_04_controller/user/t1?name=zhangsan 如果请求参数与控制器中方法的形参不一致，可以在方法形参前加@RequestParam注解： 尽量在需要接收的前端参数前加上这个注解 public String test(@RequestParam(\"username\") String name, Model model) { 也可以接收对象： @GetMapping(\"/t2\") public String test2(User user,Model model) { String jsonString = JSON.toJSONString(user); model.addAttribute(\"msg\",jsonString); return \"test1\"; } 请求URL：http://localhost:8080/springmvc_04_controller/user/t2?id=1001&name=zhangsan&age=25 说明： 接收前端传递的参数时，如果前端的请求参数名与方法形参的参数名一直，则可以直接接收 如果方法形参使用对象接收，则会匹配请求参数名与对象的属性名。如果匹配一致，则可以正常接收；如果属性名匹配不一致，则接收到的是null 例如，把请求参数中的name改成username： http://localhost:8080/springmvc_04_controller/user/t2?id=1001&username=zhangsan&age=25 则后端接收到的User对象就是： User(id=1001, name=null, age=25) 数据显示到前端 方式一：通过ModelAndView 方式二：通过ModelMap 继承了LinkedHashMap 方式三：通过Model 前端提交乱码问题 可以通过过滤器解决，使用SpringMVC提供的过滤器或者自定义过滤器 注意：过滤器url-pattern，要设置/*，不要只写成/ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/整合MyBatis.html":{"url":"frame2/整合MyBatis.html","title":"3.8 整合MyBatis","keywords":"","body":"3.8 整合MyBatis 从头开始搭建：小Demo，对图书进行增删改查 准备工作：在MySQL中创建一张数据表： CREATE table books( bookid int primary key auto_increment comment '书id', bookname varchar(100) not null comment '书名', bookcounts int not null comment '数量', detail varchar(200) not null comment '描述' ); step1. 创建一个普通的Maven项目 导入相关依赖： junit junit 4.11 test mysql mysql-connector-java 8.0.20 com.alibaba druid 1.1.22 javax.servlet javax.servlet-api 4.0.1 provided javax.servlet.jsp javax.servlet.jsp-api 2.3.3 provided javax.servlet jstl 1.2 org.mybatis mybatis 3.5.5 org.mybatis mybatis-spring 2.0.5 org.springframework spring-webmvc 5.2.6.RELEASE org.springframework spring-jdbc 5.2.6.RELEASE src/main/resources **/*.properties **/*.xml true src/main/java **/*.properties **/*.xml true step2. 在resources下创建database.properties、mybatis-config.xml jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/javaweb jdbc.username=root jdbc.password=123456 step3. 写实体类Books package com.neu.pojo; public class Books { private int bookId; private String bookName; private int bookCounts; private String detail; //... } step4. 写接口BookMapper public interface BookMapper { /** * 增加一本书 */ int addBook(Books books); /** * 删除一本书 */ int deleteBookById(@Param(\"bookId\") int id); /** * 更新一本书 */ int updateBook(Books books); /** * 查询一本书 */ Books queryBookById(@Param(\"bookId\") int id); /** * 查询全部书 */ List queryAllBooks(); } step5. 写映射文件BookMapper.xml insert into books(bookname,bookcounts,detail) value (#{bookName},#{bookCounts},#{detail}) delete from books where bookid = #{bookId} update books set bookname = #{bookName}, bookcounts = #{bookCounts},detail = #{detail} where bookid = #{bookId} select * from books where bookid = #{bookId} select * from books step6. 写service层接口和实现类 服务层的接口和Dao层接口是一样的，代码就不粘贴了，下面是实现类： public class BookServiceImpl implements BookService { private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } public int addBook(Books books) { return bookMapper.addBook(books); } public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } public int updateBook(Books books) { return bookMapper.updateBook(books); } public Books queryBookById(int id) { return bookMapper.queryBookById(id); } public List queryAllBooks() { return bookMapper.queryAllBooks(); } } 到这里为止，MyBatis部分就写完了 接下来开始整合Spring Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/整合Spring.html":{"url":"frame2/整合Spring.html","title":"3.9 整合Spring","keywords":"","body":"3.9 整合Spring 现在开始整合Spring，Spring的作用就是整合Dao和Service层 step1. 创建spring-dao.xml 这一步做了什么？ 关联数据库配置文件 database.properties 注册DataSource 注册SqlSessionFactory 配置Dao接口扫描包，动态实现了Dao接口可以注入到Spring容器中 step2. 创建spring-service.xml 这一步做了什么？ 扫描service下的包 将业务类注册到Spring 事务配置 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/整合SpringMVC.html":{"url":"frame2/整合SpringMVC.html","title":"3.10 整合SpringMVC","keywords":"","body":"3.10 整合SpringMVC step1. 项目添加web框架支持，配置web.xml springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:ApplicationContext.xml 1 springmvc / encodingfilter org.springframework.web.filter.CharacterEncodingFilter encoding utf-8 encodingfilter /* 15 配置spring-mvc.xml Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/SpringMVC的编码过滤器.html":{"url":"frame2/SpringMVC的编码过滤器.html","title":"3.10.1 SpringMVC的编码过滤器","keywords":"","body":"3.10.1 SpringMVC的编码过滤器 解决中文乱码问题，主要针对POST请求： web.xml中添加SpringMVC的编码集过滤器 encodingFilter org.springframework.web.filter.CharacterEncodingFilter encoding UTF-8 encodingFilter /* Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/拦截器.html":{"url":"frame2/拦截器.html","title":"3.11 拦截器","keywords":"","body":"3.11 拦截器 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器和拦截器的区别：拦截器是AOP思想的具体应用。 过滤器： 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法，如果访问的是jsp/html/css/image/js等是不会进行拦截的。 如何实现拦截器？ 想要自定义拦截器，必须实现HandlerInterceptor接口 public class MyInterceptor implements HandlerInterceptor {} 可以实现这个接口中的三个方法： public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"-----处理前-----\"); //返回true，才会放行到下一个拦截器，否则会被拦截到此 return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"-----处理后-----\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"-----清理-----\"); } } 在ApplicationContext.xml中配置拦截器： /**：表示拦截/下的所有请求， 例如：/admin/**：表示的是/admin下的所有请求都会被拦截器拦截 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/拦截器实现登录验证.html":{"url":"frame2/拦截器实现登录验证.html","title":"3.11.1 拦截器实现登录验证","keywords":"","body":"3.11.1 拦截器实现登录验证 问题描述： 一个登录案例，登录到后台页面，对于现在写的代码，我们没有登录的情况下，直接访问后台页面是可以访问的，但这在实际情况下是不可以直接访问后台页面的，而是需要登录。 所以，这种情况可以给现有代码添加拦截器。 实现步骤： 现有的登录的Controller： @Controller public class LoginController { @Autowired private UserDao userDao; /** * 访问登录页面 * @return */ @RequestMapping(\"/loginPage\") public String getLoginPage() { return \"login\"; } /** * 点击登录按钮，调用该方法。 * 用户名密码验证成功会在session中添加一个userLoginInfo属性，拦截器通过验证该属性，决定是否放行 * @param user * @param model * @param session * @return */ @RequestMapping(\"loginMethod\") public String login(User user, Model model, HttpSession session) { boolean loginValidate = userDao.loginValidate(user); if (loginValidate) { //登录成功，在session域中存储属性userLoginInfo session.setAttribute(\"userLoginInfo\",user.getUsername()); model.addAttribute(\"msg\", \"登录成功，欢迎：\" + user.getUsername()); return \"main\"; } else { model.addAttribute(\"msg\", \"登录失败，检查用户名或密码\"); return \"forward:/index.jsp\"; } } /** * 直接访问后台页面 * @return */ @RequestMapping(\"/main\") public String main() { return \"main\"; } } 添加拦截器： public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //验证session中userLoginInfo属性，不为空，说明用户已经登录，放行对后台页面的访问 if (request.getSession().getAttribute(\"userLoginInfo\") != null) { return true; } //否则会提示无权限，并转发到index页面 request.setAttribute(\"msg\", \"【无权限，请登录】\"); request.getRequestDispatcher(\"/index.jsp\").forward(request, response); return false; } } Spring配置拦截器： 只对/main进行拦截，拦截对后台页面的访问 直接访问/main页面会跳转到index页面，并提示无权限。 只有通过登录之后，session中有userLoginInfo属性，拦截器才会放行。 代码功能不一定很符合实际的逻辑，只为了展示下拦截器的使用 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/Ajax.html":{"url":"frame2/Ajax.html","title":"3.12 Ajax","keywords":"","body":"3.12 Ajax Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/文件上传和下载.html":{"url":"frame2/文件上传和下载.html","title":"3.13 文件上传和下载","keywords":"","body":"3.13 文件上传和下载 文件上传： 文件上传是项目开发中比较常用的功能之一，SpringMVC可以很好的支持文件上传，但是，SpringMVC上下文中默认是没有装配MultipartResolve，因此默认情况下其不能处理文件上传工作。 如果要使用文件上传功能，则需要在上下文中配置MultipartResolve。 前端表单要求：为了能上传文件，必须将表单的method设置为post，并设置enctype设置为multipart/form-data。只有在这种情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器。 enctypre属性： 值 描述 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 \"+\" 加号，但不对特殊字符编码。 表单代码： 一旦设置了enctype属性为multipart/form-data，浏览器会采用二进制流的方式处理表单的数据，而对于文件上传的处理涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快陈伟Servlet/Jsp程序员上传文件的最佳选择。 Maven依赖： commons-fileupload commons-fileupload 1.4 Servlet3.0规范已经提供方法来处理文件上传，但是这种上传功能只能在Servlet中完成 SpringMVC提供了更简单的封装 SpringMVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolve实现的 SpringMVC使用Apache Commons FileUpload技术实现了一个MultipartResolve实现类： CommonsMultipartResolve类，因此SpringMVC的文件上传功能是需要依赖Apache的该组件的。 注册Bean： 将CommonsMultipartResolve注册到容器中： Controller处理： 方式一： @Controller public class FileController { /** * @RequestParam(\"file\")将name=file控件得到的文件封装成CommonsMultipartFile对象 * 批量上传CommonsMultipartFile为数组即可 */ @RequestMapping(\"/upload\") public String upload(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException { //获取上传文件的文件名 String uploadFileName = file.getOriginalFilename(); //如果文件名为空，则跳转到首页 if(\"\".equals(uploadFileName)){ return \"redirect:/index.jsp\"; } System.out.println(\"上传的文件名：\"+uploadFileName); //上传路径保存位置 String path = request.getServletContext().getRealPath(\"/upload\"); //如果路径不存在，则创建 File realPath = new File(path); if(!realPath.exists()){ realPath.mkdir(); } System.out.println(\"上传文件保存位置：\"+realPath); //输入流 InputStream is = file.getInputStream(); //文件输出流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //读进写出（读进内存、数组，再写出到本地磁盘） int len = 0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer); os.flush(); } os.close(); is.close(); return \"redirect:/index.jsp\"; } } 说明： InputStream is = file.getInputStream();，获取上传文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); 定义一个输出流对象，用于将上传的文件输入流写出到本地 new File(realPath,uploadFileName)，定义一个File实例，指定文件保存的路径和文件名 is.read(buffer)，将字节输入流读进字节数组（缓冲区），返回一个整型，如果返回-1，说明读取到字节流末尾，无字节可读。 os.write(buffer);os.flush();，从字节数组中将数据写出到本地磁盘 方式二： @RequestMapping(\"/upload\") public String upload1(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); File realPath = new File(path); if (!realPath.exists()) { realPath.mkdir(); } System.out.println(\"上传文件保存位置：\" + realPath); //通过CommonsMultipartFile的方法直接把上传的文件保存到本地 file.transferTo(new File(realPath + \"/\" + file.getOriginalFilename())); return \"redirect:/index.jsp\"; } 使用transferTo()方法将上传的文件保存到本地磁盘 文件下载： @RequestMapping(\"/download\") public String download(HttpServletRequest request, HttpServletResponse response) throws IOException { //获取文件的路径 String path = request.getServletContext().getRealPath(\"/upload\"); //文件名称 String fileName = \"2020-04-12_大洼东湖向海大道_IMG_0471.jpeg\"; //1. 设置响应头 response.reset();//设置页面不缓存，清空buffer response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"multipart/form-data\");//以二进制传输 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\" + URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path, fileName); //2. 读取文件--输入流 InputStream is = new FileInputStream(file); //3. 写出文件--输出流 ServletOutputStream os = response.getOutputStream(); int len = 0; byte[] buffer = new byte[1024]; while ((len = is.read(buffer)) != -1) { os.write(buffer); os.flush(); } os.close(); is.close(); return \"redirect:index.jsp\"; } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/Spring中使用thymeleaf.html":{"url":"frame2/Spring中使用thymeleaf.html","title":"3.14 扩展：Spring中使用thymeleaf","keywords":"","body":"3.14 扩展：Spring中使用thymeleaf SpringBoot中使用thymeleaf模板引擎直接添加启动器即可使用，无需再做其它配置。Spring项目中如何使用thymeleaf呢？ 1. 添加thymeleaf依赖： org.thymeleaf thymeleaf-spring5 3.0.11.RELEASE 2. 配置视图解析器： 在Spring配置文件中配置thymeleaf的视图解析器： templateResolver：模板解析器，配置前缀后缀 templateEngine：模板引擎，将模板解析器注入给它（处理模板相关的） thymeleafViewResolver：视图解析器，将模板引擎注入给它（处理视图相关的） 3. HTML页面添加命名空间，使用th绑定属性： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/SSM整合SpringSecurity-环境搭建.html":{"url":"frame2/SSM整合SpringSecurity-环境搭建.html","title":"3.15 扩展：SSM整合SpringSecurity-环境搭建","keywords":"","body":"3.15 扩展：SSM整合SpringSecurity-环境搭建 新建Maven Web项目，添加所需依赖，前端页面使用的依然是狂神教程页面，源码已上传至码云：https://gitee.com/ENNRIAAA/spring-security-material 在之前SSM项目中一直使用的是jsp写前端页面，这里使用thymeleaf： 1. 导入依赖： thymeleaf 依赖： org.thymeleaf thymeleaf-spring5 3.0.11.RELEASE SpringSecurity 依赖： org.springframework.security spring-security-core 5.3.3.RELEASE org.springframework.security spring-security-web 5.3.3.RELEASE org.springframework.security spring-security-config 5.3.3.RELEASE thymeleaf整合SpringSecurity 依赖： thymeleaf页面中使用SpringSecurity的一些属性需要用到的依赖 org.thymeleaf.extras thymeleaf-extras-springsecurity5 3.0.4.RELEASE 2. 将页面源码复制到项目中： 3. 配置web.xml Archetype Created Web Application springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:ApplicationContext.xml 1 springmvc / springSecurityFilterChain过滤器是用来配置SpringSecurity的，过滤器的名字是固定的，否则会报错。 4. 配置ApplicationContext.xml 5. 定义Controller，完成页面路由： @Controller public class RouterController { /** * 首页 * @return */ @RequestMapping({\"/\", \"/index\"}) public String index() { return \"index\"; } /** * 登录页 * @return */ @RequestMapping(\"/toLogin\") public String toLogin() { return \"views/login\"; } /** * level1下的页面 * @param id * @return */ @RequestMapping(\"/level1/{id}\") public String level1(@PathVariable(\"id\") String id) { return \"views/level1/\" + id; } /** * level2下的页面 * @param id * @return */ @RequestMapping(\"/level2/{id}\") public String level2(@PathVariable(\"id\") String id) { return \"views/level2/\" + id; } /** * level3下的页面 * @param id * @return */ @RequestMapping(\"/level3/{id}\") public String level3(@PathVariable(\"id\") String id) { return \"views/level3/\" + id; } } 运行项目，测试页面和页面连接是否正常 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/SSM整合SpringSecurity-开始整合.html":{"url":"frame2/SSM整合SpringSecurity-开始整合.html","title":"3.15 扩展：SSM整合SpringSecurity-开始整合","keywords":"","body":"3.15 扩展：SSM整合SpringSecurity-开始整合 通过Java Config整合： 1. 添加SpringSecurity相关依赖 这个在环境搭建的时候写了需要用到的依赖坐标 2. 配置web.xml中SpringSecurity过滤器： springSecurityFilterChain org.springframework.web.filter.DelegatingFilterProxy springSecurityFilterChain /* 需要在web.xml中配置SpringSecurity过滤器，这个不配置的话，SpringSecurity不会生效，即使SpringSecurity配置了需要授权的请求，访问的时候也不会拦截。 过滤器的名称是固定的，不能变，否则会报错。springSecurityFilterChain 3.创建SpringSecurity配置类： @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 认证 * * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // 角色认证 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\", \"vip2\") .and().withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\", \"vip2\", \"vip3\") .and().withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\"); } /** * 授权 * * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { // 授权规则 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); // 登录页 http.formLogin().loginPage(\"/toLogin\"); // 记住我 http.rememberMe().rememberMeParameter(\"remember\"); // 禁用csrf http.csrf().disable(); // 注销 http.logout().logoutSuccessUrl(\"/\"); } } 配置类和在SpringBoot中的创建方式是一样的，类上要加@EnableWebSecurity注解。 4. 在Spring配置文件注册模板引擎时添加SpringSecurity方言： 设置这个是为了在thymeleaf页面使用SpringSecurity的一些属性，通过判断这些属性，控制页面控件是否显示。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/Shiro基础.html":{"url":"frame2/Shiro基础.html","title":"3.16 扩展：Shiro基础","keywords":"","body":"3.16 扩展：Shiro基础 本页原文地址 一、前言 Apache Shiro 是 Java 的一个安全框架。功能强大，使用简单的Java安全框架，它为开发人员提供一个直观而全面的认证，授权，加密及会话管理的解决方案。 二、介绍 # 2.1 功能特点 Shiro 包含 10 个内容，如下图： Authentication：身份认证/登录，验证用户是不是拥有相应的身份。 Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。 Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的。 Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。 Web Support：Web支持，可以非常容易的集成到 web 环境。 Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率。 Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。 Testing：提供测试支持。 Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。 Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 # 2.2 运行原理 Shiro 运行原理图1（应用程序角度）如下： Subject：主体，代表了当前“用户”。这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等。所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager。我们可以把 Subject 认为是一个门面，SecurityManager 才是实际的执行者。 SecurityManager：安全管理器。即所有与安全有关的操作都会与 SecurityManager 交互，且它管理着所有 Subject。可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，我们可以把它看成 DispatcherServlet 前端控制器。 Realm：域。Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法，也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作。我们可以把 Realm 看成 DataSource，即安全数据源。 Shiro 运行原理图2（Shiro 内部架构角度）如下： Subject：主体，可以看到主体可以是任何与应用交互的“用户”。 SecurityManager：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher。它是 Shiro 的核心，所有具体的交互都通过 SecurityManager 进行控制。它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，我们可以自定义实现。其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了。 Authrizer：授权器，或者访问控制器。它用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的哪些功能。 Realm：可以有1个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的。它可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等。 SessionManager：如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager。而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境。 SessionDAO：DAO 大家都用过，数据访问对象，用于会话的 CRUD。我们可以自定义 SessionDAO 的实现，控制 session 存储的位置。如通过 JDBC 写到数据库或通过 jedis 写入 redis 中。另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能。 CacheManager：缓存管理器。它来管理如用户、角色、权限等的缓存的。因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能。 Cryptography：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密的。 # 2.3 过滤器 当 Shiro 被运用到 web 项目时，Shiro 会自动创建一些默认的过滤器对客户端请求进行过滤。以下是 Shiro 提供的过滤器： 过滤器简称 对应的 Java 类 anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl org.apache.shiro.web.filter.authz.SslFilter user org.apache.shiro.web.filter.authc.UserFilter logout org.apache.shiro.web.filter.authc.LogoutFilter noSessionCreation org.apache.shiro.web.filter.session.NoSessionCreationFilter 解释： /admins/**=anon # 表示该 uri 可以匿名访问 /admins/**=auth # 表示该 uri 需要认证才能访问 /admins/**=authcBasic # 表示该 uri 需要 httpBasic 认证 /admins/**=perms[user:add:*] # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问 /admins/**=port[8081] # 表示该 uri 需要使用 8081 端口 /admins/**=rest[user] # 相当于 /admins/**=perms[user:method]，其中，method 表示 get、post、delete 等 /admins/**=roles[admin] # 表示该 uri 需要认证用户拥有 admin 角色才能访问 /admins/**=ssl # 表示该 uri 需要使用 https 协议 /admins/**=user # 表示该 uri 需要认证或通过记住我认证才能访问 /logout=logout # 表示注销,可以当作固定配置 注意： anon，authcBasic，auchc，user 是认证过滤器。 perms，roles，ssl，rest，port 是授权过滤器。 三、基础入门 # 3.1 添加依赖 commons-logging commons-logging 1.1.3 org.apache.shiro shiro-core 1.4.0 # 3.2 配置文件 在 src/main/resources 目录下创建名为 shiro.ini 的配置文件，内容如下： [users] # admin=admin 分别表示账号和密码，administrator 表示逗号前边的账号拥有 administrator 这个角色。 admin=admin,administrator zhangsan=zhangsan,manager lisi=lisi,guest [roles] # administrator 表示角色名称，* 表示这个角色拥有所有权限 administrator=* manager=user:*,department:* guest=user:query,department:query 其中，每个用户可以拥有多个角色，通过逗号分隔。每个角色可以拥有多个权限，同样通过逗号分隔。 # 3.3 编码 public class ShiroTest { @Test public void test() { // 读取 shiro.ini 文件内容 Factory factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) { System.out.println(\"someKey 的值：\" + value); } // 登陆 UsernamePasswordToken token = new UsernamePasswordToken(\"zhangsan\", \"zhangsan\"); token.setRememberMe(true); try { currentUser.login(token); } catch (UnknownAccountException uae) { System.out.println(\"用户名不存在:\" + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { System.out.println(\"账户密码 \" + token.getPrincipal() + \" 不正确!\"); } catch (LockedAccountException lae) { System.out.println(\"用户名 \" + token.getPrincipal() + \" 被锁定 !\"); } // 认证成功后 if (currentUser.isAuthenticated()) { System.out.println(\"用户 \" + currentUser.getPrincipal() + \" 登陆成功！\"); //测试角色 System.out.println(\"是否拥有 manager 角色：\" + currentUser.hasRole(\"manager\")); //测试权限 System.out.println(\"是否拥有 user:create 权限\" + currentUser.isPermitted(\"user:create\")); //退出 currentUser.logout(); } } } 打印结果： someKey 的值：aValue 用户 zhangsan 登陆成功！ 是否拥有 manager 角色：true 是否拥有 user:create 权限true 在项目的后端代码中，我们可以通过 Subject 对象检测出当前登录用户的认证状态和授权信息，以下是 Subject 对象认证和授权相关的方法列表： 如果开发者不想使用代码进行用户进行授权校验等操作，那么可以使用注解代替。 在使用 Shiro 的注解之前，请确保项目中已经添加支持 AOP 功能的相关 jar 包。常用注解如下： @RequiresRoles( \"manager\" ) # 角色校验 public String save() { //... } @RequiresPermissions(\"user:manage\") # 权限检验 public String delete() { //... } 当客户端发送请求后，系统会使用 AOP 生成请求目标的代理类来解析注解，然后判断当前请求的用户是否拥有权限访问。 在项目的前端代码中，如果使用的是 JSP 模板，我们就可以使用 Shiro 提供的标签对页面元素的展示进行控制。 例如： 点击进入管理界面 没有管理权限 其中，user:manage 对应 shiro.ini 文件中[roles]下边的设置。 四、自定义 Realm 上边的程序使用的是 Shiro 自带的 IniRealm，而 IniRealm 从 ini 配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义 realm。 Shiro 为我们提供了如下 Realm: 其中，最基础的是 Realm 接口，CachingRealm 负责缓存处理，AuthenticationRealm 负责认证，AuthorizingRealm负责授权，通常自定义的 realm 继承 AuthorizingRealm。 自定义 Realm： public class CustomRealm extends AuthorizingRealm { /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 从 token 中获取用户身份信息 String username = (String) token.getPrincipal(); // 通过 username 从数据库中查询 // 如果查询不到则返回 null if(!username.equals(\"zhangsan\")){//这里模拟查询不到 return null; } //获取从数据库查询出来的用户密码 String dbPassword = \"zhangsan\";//这里使用静态数据模拟 //返回认证信息由父类 AuthenticatingRealm 进行认证 SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(username, dbPassword, getName()); return simpleAuthenticationInfo; } /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { // 获取身份信息 String username = (String) principals.getPrimaryPrincipal(); // 根据身份信息从数据库中查询权限数据 // 这里使用静态数据模拟 List permissions = new ArrayList(); permissions.add(\"user:*\"); permissions.add(\"department:*\"); // 将权限信息封闭为AuthorizationInfo SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); // 模拟数据，添加 manager 角色 simpleAuthorizationInfo.addRole(\"manager\"); for(String permission:permissions){ simpleAuthorizationInfo.addStringPermission(permission); } return simpleAuthorizationInfo; } } 在 src/main/resources 目录下创建 shiro-realm.ini 文件，内容如下： [main] #自定义 realm customRealm=com.light.shiroTest.realm.CustomRealm #将realm设置到securityManager securityManager.realms=$customRealm 将测试类中，shiro.ini 改成 shiro-realm.ini 后执行，结果如下： someKey 的值：aValue 用户 zhangsan 登陆成功！ 是否拥有 manager 角色：true 是否拥有 user:create 权限true 五、与 Spring 整合 由于项目设计思路不同，整合 Shiro 框架时的设置也会有所不同，因此下边只列出部分通用的代码。 # 5.1 添加依赖 org.apache.shiro shiro-core 1.4.0 org.apache.shiro shiro-spring 1.4.0 # 5.2 配置文件 web.xml ： shiroFilter org.springframework.web.filter.DelegatingFilterProxy targetFilterLifecycle true shiroFilter /* application-shiro.xml： /resources/** = anon /login = anon /** = authc 其中，application-shiro.xml 中的 shiroFilter 名字和 web.xml 文件中的 shiroFilter是对应的，必须一致。 anon 和 authc 对应上文提到的过滤器。 CustomRealm 类： public class CustomRealm extends AuthorizingRealm { @Autowired private UserService userService; @Autowired private PermissionService permissionService; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 获取用户名 String userName = (String) token.getPrincipal(); // 通过用户名获取用户对象 User user = this.userService.findUserByUserName(userName); if (user == null) { return null; } // 通过 userId 获取该用户拥有的所有权限，返回值根据自己需求编写，并非固定值。 Map> permissionMap = this.permissionService.getPermissionMapByUserId(user.getId()); // （目录+菜单，分层级，用于前端 jsp 遍历） user.setMenuList(permissionMap.get(\"menuList\")); // （目录+菜单+按钮，用于后端权限判断） user.setPermissionList(permissionMap.get(\"permissionList\")); SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(),this.getName()); return info; } /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { User user = (User) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); // （目录+菜单+按钮，用于后端权限判断） List permissionList = user.getPermissionList(); for (Permission permission : permissionList) { if (StringUtil.isNotEmpty(permission.getCode())) { info.addStringPermission(permission.getCode()); } } return info; } } 具体代码可以根据下文提供的源码地址进行下载查看。 六、源码下载 authority-control-shiro 七、参考资料 http://shiro.apache.org/documentation.html 官方文档 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/XML配置Bean.html":{"url":"frame2/XML配置Bean.html","title":"3.16 扩展：XML配置Bean","keywords":"","body":"3.14 扩展：XML配置Bean Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/JavaConfig配置Bean.html":{"url":"frame2/JavaConfig配置Bean.html","title":"3.16 扩展：JavaConfig配置Bean","keywords":"","body":"3.16 扩展：JavaConfig配置Bean 自定义一个Realm类并继承AuthorizingRealm，重写两个方法： AuthorizationInfo：授权 AuthenticationInfo：认证 public class UserRealm extends AuthorizingRealm {} 配置Bean： @Configuration public class ShiroConfig { // ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean shiroFilter(@Autowired DefaultWebSecurityManager securityManager) { // 设置安全管理器 ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); bean.setSecurityManager(securityManager); // 设置Shiro过滤器策略 Map filterMap = new LinkedHashMap<>(); filterMap.put(\"/menus/**\",\"authc\"); bean.setFilterChainDefinitionMap(filterMap); bean.setLoginUrl(\"/login\"); return bean; } // DefaultWebSecurityManager @Bean public DefaultWebSecurityManager securityManager(@Autowired UserRealm userRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联UserRealm securityManager.setRealm(userRealm); return securityManager; } // UserRealm 自定义的Realm类 @Bean public UserRealm userRealm() { return new UserRealm(); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/Shiro中的注解.html":{"url":"frame2/Shiro中的注解.html","title":"3.16 扩展：Shiro中的注解","keywords":"","body":"3.16 扩展：Shiro中的注解 Shiro开启注解： Spring配置文件中： Shiro使用注解： 这样就可以在控制类方法中通过注解添加对请求的授权： @RequiresPermissions(value = \"items:add\") @GetMapping(\"/update/{id}\") public String updateGoodsPage(@PathVariable(\"id\") Integer id, Model model) { Shiro的注解类型大致如下： (1)@RequiresAuthentication 表示当前Subject已经通过login进行了身份验证；即Subject.isAuthenticated()返回true。 (2)@RequiresUser 表示当前Subject已经进行身份验证或者通过“记住我”登录。 (3)@RequiresGuest 表示当前Subject没有身份验证或者通过“记住我”登录过，即是 游客身份。 (4)@RequiresRoles(value={\"admin\",\"user\"},logical=Logical.OR) 表示当前Subject需要角色admin和user。 (5)@RequiresPermissions(value={\"user:a\",\"user:b\"},logical=Logical.OR) 表示当前Subject需要权限user:a或user:b。 拦截异常： 使用注解的时候，如果如果访问的是没有权限的请求，则会抛出异常，通过配置映射异常解析器拦截异常，并设置要跳转的位置： redirect:/menus redirect:/menus /error /error Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame2/Thymeleaf整合Shiro.html":{"url":"frame2/Thymeleaf整合Shiro.html","title":"3.16 扩展：Thymeleaf整合Shiro","keywords":"","body":"3.16 扩展：Thymeleaf整合Shiro pom中添加整合包： com.github.theborakompanioni thymeleaf-extras-shiro 2.0.0 SpringMVC配置文件中，模板引擎中添加方言： 不添加方言的话，页面中的shiro不会生效 Thymeleaf页面添加Shiro命名空间： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/完整搭建一个SSM小项目.html":{"url":"frame6/完整搭建一个SSM小项目.html","title":"4. 完整搭建一个SSM小项目√","keywords":"","body":"3.11 完整搭建一个SSM小项目√ Demo简介：数据库创建一个user表用来存储（id,username,password）,通过前端页面对数据库实现增删改查 用到的技术栈: 使用maven构建项目 开发工具：JetBranins IDEA 2020.01 后端：springMVC + spring + mybatis（数据库mysql，连接池druid） 前端：vue-cli + elementUI 异步通信axios 准备工作： 创建数据表（三个字段，id、username、password） 使用IDEA创建一个普通的maven项目 添加相关依赖 不会Maven的话，可参见https://javabook.shiguangping.com/midd1/Maven.html 安装Maven、创建Maven项目 项目工程结构： 下面开始从后端开始搭建这个项目 项目功能比较简单，主要目的就是为了梳理、熟练SSM的搭建思路和流程 搭建顺序从后端到前端，依次是： Mybatis部分 Spring部分 SpringMVC部分 使用vue脚手架创建项目，实现增删改查，异步通信使用的是axios库 先把实体类创建上： package com.neu.pojo; /** * 实体类User */ public class User { /** * 属性名尽量与数据库表的字段名相同 */ private int id; private String username; private String password; /** * 构造方法和getter/setter方法、toString方法都要写 * Spring的DI（依赖注入）主要是通过setter方法进行注入的，所有Set方法是必须的 */ public User() { } public User(int id, String username, String password) { this.id = id; this.username = username; this.password = password; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/mybatis部分.html":{"url":"frame6/mybatis部分.html","title":"4.1 Mybatis部分（持久层）","keywords":"","body":"4.1 Mybatis部分（持久层） 使用SSM框架搭建项目，离不开各种各样的配置文件，因此， 第一步，先在resources中创建Mybatis的核心配置文件文件，mybatis-config.xml， 再创建一个database.properties用来配置数据库的相关信息： database.properties： mybatis-config.xml： 之后会通过Spring来整合Mybatis，所以在Mybatis的配置文件中，我只配置了实体类的别名，和注册Mapper。 配置数据源的工作，交给了Spring去做，之后会在Spring的配置文件中配置。 编写Dao层： UserMapper接口 UserMapper.xml 相当于之前的UserDaoImpl实现类，SQL语句就在这里写： 编写Service层： UserService.java接口 UserServiceImpl.java实现类 UserServiceImpl中会生命一个Dao层接口的对象，用来调用Dao层方法操作数据库，这里要记得添加setter方法，完成依赖注入。否则，会报错。 （没有使用注解，完全通过配置文件注册Bean） 到这里，Mybatis相关的就写完了，接下来开始配置Spring Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/Spring部分.html":{"url":"frame6/Spring部分.html","title":"4.2 Spring部分","keywords":"","body":"4.2 Spring部分 Spring是一个容器，它就像是一个大管家一样，管理着项目上所有的对象 Spring的核心思想之一：就是控制反转(IoC)， 之前，都是我们手动去new对象，对象间的关系完全是由我们程序猿来控制； 现在，所有的对象都交由Spring的IoC容器去管理，对象间的关系也由Spring自动去注入，把控制权交由Spring，这就是控制反转的思想。 使用Spring一开始，依旧是创建配置文件，通过配置文件完成Bean的注册 创建ApplicationContext.xml 先在resources下创建一个总的Spring配置文件，再分别创建不同的配置文件来配置Dao层、Service层和Controller层， 最后再把这三个配置文件通过import标签导入到ApplicationContext.xml中 （也可以把所有的配置写在一个xml文件里，但如果对对象之间的关系不是很清晰的话，分开写比较容易理清它们之间的关系） 2. spring-dao.xml 整合Dao层： 这一步做了什么？ 引入数据库配置文件database.properties 创建数据源dataSource，这里使用的是Alibaba的Druid，所以class=DruidDataSource 这里可以使用任意的数据源，例如Spring的数据源、C3P0等 注册SqlSessionFactory 这个是Mybatis-Spring中非常核心的对象，有了它，就可以完成Mybatis的所有操作。具体可参见我的Spring整合Mybatis的笔记) 配置Mapper扫描，自动将Mapper注册到Spring容器中 这一步是通过扫描com.neu.dao包，自动将映射器注册到Spring容器中，不需要我们手动去配置每一个映射器(Mapper) 3. spring-service.xml 整合service层： 这一步做了什么？ 组件扫描，扫描指定包下的注解，如@Component、@Service、@Repository、@Controller，将被注解的类自动注册Bean 不使用注解的话，可以手动在Spring中注册Bean，完成依赖注入 （如果不使用注解的话，可以不写第一步；如果使用注解自动注册、自动装配的话，可以不写第二步） 4. 将配置文件引入到ApplicationContext.xml中 将spring-dao.xml和spring-service.xml引入到ApplicationContext.xml中： Spring整合mybatis部分到这儿就结束了，接下来开始配置SpringMVC Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/SpringMVC部分.html":{"url":"frame6/SpringMVC部分.html","title":"4.3 SpringMVC部分","keywords":"","body":"4.3 SpringMVC部分 1.添加web框架支持 首先，项目添加web框架支持，配置web.xml（如果一开始创建的是Web项目，则忽略这一步） 紧接着，要把各种依赖添加到Tomcat中： Tomcat在运行时，会调用WEB-INF/lib中的依赖 2. 配置web.xml SpringMVC的核心就是DispatcherServlet，一切都是围绕这它展开的。 DispatcherServlet是一个核心分发器，所有的请求都会经过它，再由它去分发给能处理该请求的控制器，它是SpringMVC的核心所在。 在web.xml中也可以配置过滤器，来解决像中文乱码等问题。 3. spring-mvc.xml 配置SpringMVC的配置文件，如果需要返回指定视图，则需要配置视图解析器 如果配置了第三步组件扫描包，可以省略第一步开启注解驱动 4.编写Controller控制器 在pojo包下创建一个实体类RespMsg，用来封装响应给前端的信息： 控制类： 在SpringMVC中，被@Controller注解的类会被注解为控制类，并在容器中自动注册Bean 控制类中常用的注解： @Controller：控制类 @RequestMapping请求映射，可以作用在类上或方法上 衍生注解：@GetMapping：get请求、@PostMapping：post请求 @CrossOrigin：跨域请求 和Servlet不同的是，Servlet每实现一个功能就要写一个Servlet类；而SpringMVC中只需要在一个控制类中编写多个方法就可以实现不同的功能，使用注解为每个方法设置url-pattern。 编写控制类中的方法： 每个方法都添加了@ResponseBody注解，用来响应给前端字符串。也可以使用@RestController来替换@Controller，省略方法的@ResponseBody注解，实现相同的功能。 配置Tomcat，运行后端程序 这块就不多说了，直接测试： 添加User： 查询全部User： 这里发现显示中文有乱码：添加一个过滤器试试 后端部分到这儿结束，接下来开始创建前端项目 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/创建Vue项目.html":{"url":"frame6/创建Vue项目.html","title":"4.4 创建Vue项目","keywords":"","body":"4.4 创建Vue项目 终端输入： vue ui 启动图形化界面： 路径选择好之后，点击页面下方的在此创建新项目： 创建项目，项目名自定义，我这里还叫ssm-demo： 下一步，选择默认配置，点击创建项目，等待项目创建完毕。 创建完毕之后，在项目依赖中添加这次需要的依赖，包括： vue-router --vue路由 axios --异步通信 element-ui --饿了吗UI组件库 sass-loader --sass加载器 node-sass 然后，把上面需要的依赖都安装下来... 安装noda-sass耗时较长 所有的依赖都安装完毕之后，使用IDE打开项目，开始写前端功能部分的代码了 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/Vue部分-增.html":{"url":"frame6/Vue部分-增.html","title":"4.5 Vue部分--增","keywords":"","body":"4.4 Vue部分--增 使用IDE打开刚刚创建好的Vue项目，把预带的不需要的组件都删除掉，之后开始写第一个页面功能，“注册用户”，增加User。 开始写增加User功能（注册功能）之前，突然想到一个问题，数据表中username字段设置了unique(唯一约束)，username不能重复，如果注册时输入了已有的用户名，Java程序会报错。 所以，先修改一下后端代码，在Dao层接口中添加一个方法，用来校验是否有重复用户名： 修改了接口，紧接着就要修改Usermapper.xml，添加查询语句： service层接口和实现类也要做修改： service层实现类： 在实现类addUser()方法中做用户名是否重复的验证 后端修改完毕，回到前端IDE，开始写Vue代码： 在components目录下新建AddUser.vue文件： 在template标签中添加两个输入框、一个按钮，我这里输入框使用的是element-ui组件库，这个可以自己研究一下。 方法中使用axios作为异步通信，安装axios库后，需要在main.js中导入组件，并添加到原型中，我把它放到下面的图中了：⬇️⬇️ 在router目录下，新建index.js文件： 编写main.js： 编写App.vue： 运行效果： 用户名重复时： 注册成功时： 注册功能（增）写完了~ 饿了吗UI组件库的官方使用文档：https://element.eleme.cn/#/zh-CN/component/ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/Vue部分-删.html":{"url":"frame6/Vue部分-删.html","title":"4.6 Vue部分--删","keywords":"","body":"4.5 Vue部分--删 Step1：components中创建RemoveUser.vue Step2：index.js中添加路由 Step3:App.vue添加链接 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/Vue部分-改.html":{"url":"frame6/Vue部分-改.html","title":"4.7 Vue部分--改","keywords":"","body":"4.6 Vue部分--改 Step1：components中创建UpdateUser.vue Step2：index.js添加路由 Step4：App.vue中添加链接 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame6/Vue部分-查.html":{"url":"frame6/Vue部分-查.html","title":"4.8 Vue部分--查","keywords":"","body":"4.7 Vue部分--查 查询这里我做了分页查询，样式使用的element-ui的分页组件，后端sql通过limit分页查询，又额外添加了一个返回数据库总条目数的查询方法。 前端的分页组件： 在components中创建QueryUserAll.vue 先上代码，之后再详细说明分页的实现： 这个是element-ui的分页组件： @current-change：当前页发生改变时，调用handleCurrentChange方法： handleCurrentChange(val) { //当前页发生改变时，将当前页码赋值给this.currentPage属性 this.currentPage=val //并调用查询方法，查询改变后当前页码的数据 this.queryUserAll() } background：分页样式有背景 layout：上一页、页码、下一页 :pager-count=\"5\"：页码超过指定值时自动折叠 :page-size=\"pageSize\"：每页显示数据的条目数 :total=\"total\"：总条目数 :current-page=\"currentPage\"：当前页码 最后三个参数是比较重要的，涉及到后端查询的， MySql中，limit查询需要提供两个参数(index,size)，查询的起始位置，查询的条目数 起始位置对应：this.currentPage - 1 将当前页码-1传递给后端即可（limit查询起始位置从0开始，而分页的页码是从1开始） 查询的条目数对应：this.pageSize （即每页显示的条目数，前端需要每页显示多少条数据，直接将条目数传递给后端即可） 还有一个就是后端需要返回给当前数据库中总的条目数，只需要查询count，返回总数目即可，这个对应分页组件的:total=\"total\"总条目数 有了这三个关键的参数，就可以实现分页查询。 分页查询的作用： 当查询数据，要返回的数据量比较大时，会对前端造成比较大的压力，可能会影响用户体验。如果同时访问人数比较多，对数据库服务器的性能以及带宽都会有影响。 分页查询的主要目的就是能够缓解对前端的压力以及对数据库查询的压力，一次性返回过多的数据对内存，对带宽都是不小的冲击。 Step2：index.js添加路由 Step3：App.vue添加链接 分页查询的效果： 下面的页码也会随着数据的增加而增加、减少而减少，通过后端返回的数据表总条目数以及每页显示的条数，动态的分页。 至此，SSM整合，从零搭建就结束了 刚刚跟着视频学完Spring的时候，对控制反转以及依赖注入不是很理解。写代码的方式上，也不习惯。之前一直都是敲Java代码，现在变成了写配置文件。 紧接着学完Mybatis，通过Spring整合Mybatis，由Spring去管理Mybatis，整合的时候更懵了。 但是，随着不断的向后学习，学完SpringMVC，跟着视频整合SSM之后，真正完成了一个简单的项目，简单的增删改查功能之后，我对这几个框架之间的关系，每个框架的作用有了新的认识。 从第一遍第二遍照着笔记搭建，到后来慢慢理解每一步的作用，能独立搭建SSM，这是对于一个初学者来说，最兴奋的事儿了。 更兴奋的是，理解了之后，对于注解的使用更加上手，虽然就那么几个注解，但是不理解Spring的话，用注解总是有种懵懂的感觉--。 学习编程的体会： 学习新技术的时候，跟着视频敲代码，一定要记笔记，这个是把知识转化的一个过程。光看视频是看不会的，要是看就能看会，那他肯定是个天才。 记笔记可以让思路更清晰，笔记是出自自己之手，而不是像在网上看别人写的文章一样，看得一脸懵逼。当之后遇到不理解的问题时翻看自己的笔记，更容易吸收。 学习的时候，遇到实在不理解的地方不要花时间去纠结，继续往下看，等把一个技术拿下之后就会发现之前不理解的地方现在已经想通了。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/springboot.html":{"url":"frame4/springboot.html","title":"5. SpringBoot","keywords":"","body":"SpringBoot 什么是Spring？ Spring是一个开源框架，2003年兴起的一个轻量级的Java开发框架，作者：Rod Johnson（音乐学博士） Spring市为了解决企业级开发应用的复杂性而创建的，为了简化开发 Spring是如何简化Java开发的？ 为了降低Java开发的复杂性，Spring才用了以下4种关键策略： 基于Pojo的轻量级和最小侵入性编程 通过IoC，依赖入住(DI)和面向接口实现松耦合 基于切面(AOP)和惯例进行声明式编程 通过切面和模板减少样式代码 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/第一个SpringBoot程序.html":{"url":"frame4/第一个SpringBoot程序.html","title":"5.1 第一个SpringBoot程序","keywords":"","body":"第一个SpringBoot程序 通过Spring官网快速构建项目：https://start.spring.io/： 点击生成之后，会自动下载生成的项目，以zip压缩包的形式，然后解压到本地，再通过IDEA导入项目： 写一个Controller测试一下： 通过Maven打一个Jar包跑一下： 如果打包失败，检查一下Maven的环境配置 在终端通过java -jar xxx.jar命令运行刚刚打包好的jar包： 在浏览器访问一下： jar包就是一个可执行程序，由于默认内嵌了Tomcat，运行jar包，浏览器可以访问 测试结束后要ctrl+c结束程序，否则8080会一直被占用 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/IDEA创建SpringBoot程序.html":{"url":"frame4/IDEA创建SpringBoot程序.html","title":"5.2 IDEA创建SpringBoot程序","keywords":"","body":"IDEA创建SpringBoot程序 通过IDEA快速构建项目：（IDEA也是通过Spring官网构建的项目） 下一步： 下一步，可以添加依赖，然后选择项目路径，创建完毕。 如果创建时没有添加Web依赖，创建完毕后，可以在pom文件种添加： 写一个Controller： 浏览器访问： 访问正常 如何修改Tomcat端口号？ 在application.properties中设置端口号： # 修改Tomcat端口号 server.port=8081 通过IDEA设置： 彩蛋：如何修改banner？ 什么是banner？答：SpringBoot运行起来时的横幅： Google搜索“Spring Boot banner生成”，有很多这样的网站，例如：https://www.bootschool.net/ascii 在resources下新建一个banner.txt文件，注意名字不要错，把生成好的banner文本粘贴到txt文件中保存 重启Spring Boot： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/SpringBoot自动装配原理.html":{"url":"frame4/SpringBoot自动装配原理.html","title":"5.3 SpringBoot自动装配原理","keywords":"","body":"SpringBoot自动装配原理 pom.xml： 父项目： org.springframework.boot spring-boot-starter-parent 2.3.1.RELEASE 进入父项目可以看到父项目的父项目： org.springframework.boot spring-boot-dependencies 2.3.1.RELEASE 它来真正管理Spring Boot所有依赖的版本，我们正常导入依赖是不需要指定版本的，但是没有在这个爷爷项目中管理的依赖，导入则需要指定版本。 pom中的启动器： org.springframework.boot spring-boot-starter 启动器：就是SpringBoot的启动场景，如spring-boot-starter-web，它会帮我们导入web环境的所有依赖 SpringBoot中将所有的功能场景，都变成一个个启动器 如果我们要使用什么功能，只需要找到对应的启动器就可以了，所有官方启动器都遵循类似的命名方式。spring-boot-starter-*，其中*是特定类型的应用程序。 主程序： import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; //标注这个类是一个SpringBoot应用：启动类下的所有资源被导入 @SpringBootApplication public class Springboot01HelloworldApplication { //将SpringBoot应用启动 public static void main(String[] args) { SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 注解：标注这个类是一个SpringBoot的应用，这个注解又被其它注解修饰，其中有两个核心的注解： @SpringBootConfiguration ：SpringBoot的配置 - @Configuration ：Spring配置类 - @Component ：说明这也是一个Spring组件 @EnableAutoConfiguration：自动配置 - @AutoConfigurationPackage：自动配置包 -@Import(AutoConfigurationPackages.Registrar.class)：自动配置包 - @Import(AutoConfigurationImportSelector.class)：自动配置导入选择器 //获取所有配置 List configurations = getCandidateConfigurations(annotationMetadata, attributes); 获取候选的配置： protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } META-INF/spring.factories：自动配置的核心文件 流程分析： 结论：SpringBoot所有自动配置都是在启动的时候扫描并加载spring.factories，所有的自动配置类都在这里面，但是不一定生肖，要判断条件是否成立。只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后配置成功。 SpringBoot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值 将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置 以前我们需要配置的东西，现在SpringBoot都帮我们做了 整合JavaEE，解决方案和自动配置的东西都在spring-boot-autoconfigure-2.3.1.RELEASE.jar包下 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器中 容器中也会存在非常多的XxxAutoConfiguration的文件(@Bean)，就是这些类给容器中导入了这个场景需要的所有组件并自动配置，@Configuration，JavaConfig 有了自动配置类，免去了我们手动编写配置文件的工作。 主启动类 package com.neu; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { SpringApplication.run(Springboot01HelloworldApplication.class, args); } } class SpringApplication 这个类主要做了以下四件事清： 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用的初始化器，设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/yaml配置文件.html":{"url":"frame4/yaml配置文件.html","title":"5.4 yaml配置文件","keywords":"","body":"yaml配置文件 SpringBoot的核心配置文件： application.properties： 语法格式：key=value application.yaml或者application.yml： 语法格式：key: value (:冒号后面有一个空格+value) YAML 维基百科，自由的百科全书 YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列化的格式。YAML参考了其他多种语言，包括：C语言、Python、Perl，并从XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans在2001年首次发表了这种语言[1]，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者[2]。目前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。 YAML是\"YAML Ain't a Markup Language\"（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）[3]，但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。 # 普通的键值对 name: liyan # 对象 student: name: liyan age: 27 # 行内写法 student1: {name: liyan,age: 27} # 数组 fruits: - apple - banana pets: [cat,dog] Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/给属性赋值的几种方式.html":{"url":"frame4/给属性赋值的几种方式.html","title":"5.5 给属性赋值的几种方式","keywords":"","body":"5.5 给属性赋值的几种方式 之前学过一种方式：通过@Value注解分别给属性赋值 yaml可以直接给实体类赋值： 实体类： @Component @ConfigurationProperties(prefix = \"person\") @Data @AllArgsConstructor @NoArgsConstructor public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map maps; private List lists; private Dog dog; } yaml配置文件： Person: name: 张三 age: 25 happy: false birth: 1996/2/3 maps: {id: zhangsan,pass: 123abc} lists: - java - kotlin dog: name: 花花 age: 1 实体类使用@ConfigurationProperties(prefix = \"person\")注解，引入配置文件中的person对象，通过属性名匹配赋值 yaml给属性赋值，还支持松散绑定： 把yaml中的name改成name-: 张三： name-: 张三 实体类中的属性依旧： private String name; 这种依然可以赋值成功，我们可以实体类使用驼峰命名，yaml使用-命名，这种都可以赋值成功。 通过自定义properties文件赋值： 创建一个test.properties： name=zhangsan 实体类： @Component @PropertySource(value = {\"classpath:test.properties\"}) @Data @AllArgsConstructor @NoArgsConstructor public class Person { @Value(\"${name}\") private String name; private Integer age; private Boolean happy; private Date birth; private Map maps; private List lists; private Dog dog; } 通过@PropertySource(value = {\"classpath:test.properties\"})注解引入配置文件 通过@Value(\"${name}\")注解引入配置文件中的值 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/JSR303校验.html":{"url":"frame4/JSR303校验.html","title":"5.6 JSR303校验","keywords":"","body":"5.6 JSR303校验 JSR303 是一套JavaBean参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们JavaBean的属性上面，就可以在需要校验的时候进行校验了。 Maven依赖： org.hibernate.validator hibernate-validator 6.0.17.Final javax.validation validation-api 2.0.1.Final Bean Validation中内置的constraint 以下图片来自互联网 Hibernate Validator 附加的 constraint 使用方法： 使用约束注解约束属性，用于做参数校验 参数添加完约束之后还要开启校验，使用@Valid或@Validated注解开启校验，可以作用在要校验的参数上 @Valid是Javax的注解 @Validated是Spring的注解 public String login(@Validated User user, BindingResult bindingResult, Model model, HttpSession session) { User实体类中的属性添加了一些参数校验的注解，然后在要接收的User参数上使用@Validated注解开启校验。 参数校验开启后，如果接收到不符合约束的参数，会报异常。使用BindingResult bindingResult可以接收到这些异常信息，而Java不会报异常。 //获取参数校验错误信息 if (bindingResult.hasErrors()) { model.addAttribute(\"errors\", bindingResult.getAllErrors()); return \"/login\"; } 通过bindingResult参数获取到所有异常，将异常信息返回到前端 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/多环境配置及配置文件位置.html":{"url":"frame4/多环境配置及配置文件位置.html","title":"5.7 多环境配置及配置文件位置","keywords":"","body":"5.7 多环境配置及配置文件位置 配置文件位置： 可以配置配置文件的地方： file:./config/ file:./ classpath:/config/ classpath:/ 优先级也是从高到低。 多环境配置： 我们在开发中，可能需要配置多套环境，例如：测试环境、开发环境等等。这时就需要配置多个配置文件，例如properties： 创建了3个配置 文件，一个默认的，一个用于开发环境的，一个用于测试环境的， 默认的没有指定端口 dev：server.port=8081 test：server.port=8082 这种情况下，SpringBoot会使用默认的8080端口，而不会引用dev或者test下的配置，通过在默认的配置文件中指定激活哪个配置文件来使其它配置文件生效： spring.profiles.active=test 直接激活配置文件-后面的字段即可，SpringBoot启用了8082端口 这种是通过properties文件配置，使用yaml配置更加灵活、方便，只需要在通过yaml文件下就可以配置多套环境： server: port: 8080 --- spring: profiles: dev server: port: 8081 --- spring: profiles: test server: port: 8082 通过---分隔，来配置多套环境，在不指定激活哪套配置的时候，默认使用8080，通过激活不同配置来使用不同的环境： spring: profiles: active: test --- spring: profiles: dev server: port: 8081 --- spring: profiles: test server: port: 8082 激活test，SpringBoot启用了8082端口。 使用yaml在一个配置文件下，就可以实现多套配置 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/自动配置原理再理解.html":{"url":"frame4/自动配置原理再理解.html","title":"5.8 自动配置原理再理解","keywords":"","body":"5.8 自动配置原理再理解 spring-boot-autoconfigure-2.3.1.RELEASE.jar/META-INF/spring.factories 了解一下这里面的配置和application.yaml的关系： spring.factories中有很多自动配置的类，点开ServletWebServerFactoryAutoConfiguration， @Configuration(proxyBeanMethods = false) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @ConditionalOnClass(ServletRequest.class) @ConditionalOnWebApplication(type = Type.SERVLET) @EnableConfigurationProperties(ServerProperties.class) @Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class }) public class ServletWebServerFactoryAutoConfiguration { @Configuration(proxyBeanMethods = false)：该类是一个Spring配置类 @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)：SpringBoot中的自动配置排序的注解 @ConditionalOnClass(ServletRequest.class)：表示在指定条件成立的情况下，才会将组件添加到容器，使组件配置生效 @ConditionalOnWebApplication(type = Type.SERVLET) @EnableConfigurationProperties(ServerProperties.class)：配置类中的属性配置将自动配置到容器中 @Import()：引入其它配置类 @EnableConfigurationProperties(ServerProperties.class)点开ServerProperties.class类： @ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true) public class ServerProperties { /** * Server HTTP port. */ private Integer port; /** * Network address to which the server should bind. */ private InetAddress address; 可以看到我们在yaml配置文件中配置的端口号，port属性。 所以，我们在配置文件中配置的属性都是关联到META-INF/spring.factories这里的。 了解@Conditional注解： 要使用@Conditional注解，必须先了解一下Conditiona接口，它与@Conditional注解配合使用，通过源码我们也可以看出，使用@Conditional注解必须要指定实现Conditiona接口的class。 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Conditional { /** * All {@link Condition Conditions} that must {@linkplain Condition#matches match} * in order for the component to be registered. */ Class[] value(); } 在Conditiona接口中，只定义了一个方法matches，spring在注册组件时，也正是根据此方法的返回值TRUE/FALSE来决定是否将组件注册到spring容器中： @FunctionalInterface public interface Condition { /** * Determine if the condition matches. * @param context the condition context * @param metadata the metadata of the {@link org.springframework.core.type.AnnotationMetadata class} * or {@link org.springframework.core.type.MethodMetadata method} being checked * @return {@code true} if the condition matches and the component can be registered, * or {@code false} to veto the annotated component's registration */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } 在matches中我们可以获取到ConditionContext接口，根据此接口对象可以获取BeanDefinitionRegistry，ConfigurableListableBeanFactory等重要对象信息，根据这些对象就可以获取和检查spring容器初始化时所包含的所有信息，再结合业务需求，就可以实现组件注册时的自定义条件判断。 @Conditional派生注解： 作用： 必须是@Conditional指定的条件成立 才给容器中添加组件，配置文件里面的所有内容才生效 自动配置类 必须在一定的条件下才能生效 配置文件中配置debug: true，可以在控制台看哪些配置是生效的。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/摘要书籍理解自动配置原理.html":{"url":"frame4/摘要书籍理解自动配置原理.html","title":"5.8.1 摘要书籍理解自动配置原理","keywords":"","body":"5.8.1 摘要书籍理解自动配置原理 读《SpringBoot揭秘 快速构建微服务体系》理解自动配置原理。 【第三章 SpringBoot的工作机制】 SpringBoot启动类： @SpringBootApplication public class Springboot01WebApplication { public static void main(String[] args) { SpringApplication.run(Springboot01WebApplication.class, args); } } 无论SpringBoot应用如何定制，启动SpringBoot应用都是从这个启动类开始的。 这里面有两个地方是SpringBoot的启动关键： @SpringBootApplication注解 SpringApplication.run(Springboot01WebApplication.class, args); 我们从这两个地方开始分析： 解读@SpringBootApplication 这个注解是一个复合注解，点开这个注解后，可以看到，它被多个注解修饰： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { 这里面比较重要的注解只有三个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 也就是说，启动类被这三个注解修饰，SpringBoot应用就可以启动。（可以动手尝试一下） 解读@SpringBootConfiguration @SpringBootConfiguration注解打开一看，本质就是@Configuration注解。 这个注解在学习Spring的时候就了解到，被它注解的类实际上就是一个Spring容器的配置类。 Spring中经常使用XML来配置IoC容器，而SpringBoot中推荐使用的方式是通过JavaConfig（配置类）的形式配置。 所以，使用@SpringBootConfiguration注解，说明这个启动类本身就是一个Spring容器的配置类。 这是解读SpringBoot启动类得到的第一个结论。 第二个结论是，这个类本身还是一个标准的Standalone类型的Java程序的main函数启动类，又回归到学习JavaSE时的概念。 这本书的作者在告诉我们，初看SpringBoot启动类的第一眼没有什么可新奇或者说恐惧的，都是之前学习过的概念，不要惧怕，继续往下看吧。 解读@EnableAutoConfiguration @EnableAutoConfiguration注解概括来说，是借助@Import的支持，收集和注册特定场景相关的Bean定义，这是什么意思呢？ 点开这个注解可以看到@Import(AutoConfigurationImportSelector.class)，导入了一个自动配置导入选择器的类。 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { 我个人理解，就是通过pom中添加的启动器场景(spring-boot-XXX)来选择要自动配置的组件，将Bean添加到IoC容器中，这一步又是如何完成的呢？ 原因在于Spring框架原有的一个工具类：SpringFactoriesLoader类的支持，@EnableAutoConfiguration可以“智能”地实现自动配置。 AutoConfigurationImportSelector.class中的方法，获取候选配置： protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } 可以得到一个信息：所有的Spring自动配置类都在META-INF/spring.factories里 打开这个文件，会看到里面有非常多非常多的配置类，但是这些配置类不会全部生效，它们会通过判断POM文件中添加的启动器场景，来决定哪些配置类生效，然后被加载。 自动配置的幕后英雄：SpringFactoriesLoader SpringFactoriesLoader类属于Spring框架私有的一种扩展方案，其主要的功能就是从指定的配置文件META-INF/spring.factories加载配置，spring.factories是一个典型的Java properties文件，配置的格式为key=value形式，只不过key和value都是Java类型的完整类名（如图）： 然后框架就可以根据某个类型作为Key来查找对应的类型名称列表了。 对于@EnableAutoConfiguration来说，SpringFactoriesLoader的用途稍微不同一些，其本意是为了提供SPI扩展的场景，而在@EnableAutoConfiguration的场景中，它更多是提供了一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名作为查找的Key，获取对应的一组@Configuration类。 说明：SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制。 所以，@EnableAutoConfiguration自动配置的魔法本质其实就变成了：从classpath中搜寻所有META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射实例化为对应的标注了@Configuration的JavaConfig形式的Ioc容器的配置类，然后汇总为一个加载到IoC容器中。 个人理解： 首先，这些配置类是根据我们配置的场景来决定哪些是生效的，EnableAutoConfiguration对应的配置类有很多（大概128个），但是哪些生效哪些不生效是由我们来决定的。 例如在POM中配置了spring-boot-starter-web启动器，那么自动配置类org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration就会生效，点开这个自动配置类： 如果注释掉POM中的spring-boot-starter-web启动器，那么这个配置类打开就是这个样子： 原因在于这些配置类会去验证当前SpringBoot应用是否有相关的类（依赖），如果SpringBoot中没有添加这些依赖，那么相关的自动配置类就不会生效。 然后，SpringBoot启动类由于被@EnableAutoConfiguration修饰，在启动SpringBoot应用时，通过SpringFactoriesLoader把这些有效的自动配置类加载到候选配置中，最后添加到IoC容器。 自动配置原理大概就是如此，个人理解。 有关SpringBoot自动配置的包：spring-boot-autoconfigure-2.3.1.RELEASE.jar 解读：可有可无的@ComponentScan @ComponentScan注解，是Spring中的注解，作用是自动扫描并注册符合条件的组件（类）到IoC容器。 如果当前没有任何Bean需要注册到IoC容器中的话，即使没有@ComponentScan注解，SpringBoot依然可以运行。 而且，即使有需要注册的Bean，也可以手动注册。当然，SpringBoot讲究的还是自动配置、开箱即用。 学习SpringBoot，我记住了这么一句话，SpringBoot构建一切，SpringCloud协调一切。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/导入静态资源.html":{"url":"frame4/导入静态资源.html","title":"5.9 导入静态资源","keywords":"","body":"5.9 导入静态资源 添加静态资源的方式，首先需要了解一下SpringBoot中的源码： 在WebMvcAutoConfiguration配置类中的 WebMvcAutoConfigurationAdapter类中的 /addResourceHandlers()方法： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); return; } Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } 方式一：通过webjars引入静态资源 什么是webjars？ webjars就是将web中的库打包成jar，根据一定的目录格式。 https://www.webjars.org/ 例如，引入jquery通过webjars： org.webjars jquery 3.5.1 引入之后，可以看到是这样的一个层级目录： 通过上面addResourceHandlers()方法源码可以看到，url-pattern是\"/webjars/**\"，启动SpringBoot，直接访问http://localhost:8081/webjars/jquery/3.5.1/jquery.js就可以访问到jquery的资源。 方式二：几个默认的路径 在ResourceProperties类中定义了4个资源路径，这是SpringBoot定义的默认的资源存放路径，这4个路径下的静态资源都会被加载： private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" }; 这4个默认路径下的静态资源都可以被加载： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 读取的优先级resources>static>public 这个是设置url-pattern的，SpringBoot源码中默认的是/**，访问的时候，直接是域名:端口号/XXX String staticPathPattern = this.mvcProperties.getStaticPathPattern(); getStaticPathPattern()方法返回当前对象的静态路径： /** * Path pattern used for static resources. */ private String staticPathPattern = \"/**\"; 可以通过配置文件修改。 方式三：通过配置文件自定义路径 spring: resources: static-locations: classpath:/static/ 这个是修改静态资源路径的，修改就是上面那4个，如果配置文件中定义了静态资源路径，则上面的4个默认路径将失效。 spring: mvc: static-path-pattern: /yyy/** 这个是修改url-pattern的，如果设置成/yyy/**，则资源的访问地址变为：http://localhost:8081/yyy/3.html。 这个不是修改静态资源的存储目录，只是修改访问资源的路径模板。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/thymeleaf模板引擎.html":{"url":"frame4/thymeleaf模板引擎.html","title":"5.10 thymeleaf模板引擎","keywords":"","body":"5.10 thymeleaf模板引擎 引入Maven依赖： org.thymeleaf thymeleaf-spring5 org.thymeleaf.extras thymeleaf-extras-java8time Thymeleaf 的属性配置类： @ConfigurationProperties(prefix = \"spring.thymeleaf\") public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; Thymeleaf模板引擎默认的前缀是classpath:/templates/，默认的后缀是：.html 所以，写一个控制类： @Controller public class IndexController { @RequestMapping(\"/test\") public String index(){ return \"test\"; } } 直接访问http://localhost:8081/test，就可以访问到resources/templates/test.html。 配置类prefix = \"spring.thymeleaf\"，我们可以通过配置文件来修改Thymeleaf模板引擎的前缀和后缀。 表达式： 简单表达： 变量表达式：${...} 选择变量表达式：*{...} 消息表达式：#{...} 链接网址表达式：@{...} 片段表达式：~{...} Literals 文字 literals：'one text'，'Another one!'，... 数字 literals：0，34，3.0，12.3，... Boolean literals：true，false 空文字：null 文字代币：one，sometext，main，...... 文字操作： String 连接：+ 字面替换：|The name is ${name}| 算术运算： 二进制 operators：+，-，*，/，% 减号(一元运算符)：- Boolean 操作： 二进制操作符：and，or Boolean negation(一元 operator)：!，not 比较和平等： 比较器：>，，>=，(gt，lt，ge，le) Equality operators：==，!=(eq，ne) 有条件的 operators： If-then：(if) ? (then) If-then-else：(if) ? (then) : (else) 默认值：(value) ?: (defaultvalue) 特殊代币： No-Operation：_ 订购 特征 属性 1 片段包含 th:insert th:replace 2 片段迭代 th:each 3 有条件的 evaluation th:if th:unless th:switch th:case 4 局部变量定义 th:object th:with 5 一般属性修改 th:attr th:attrprepend th:attrappend 6 具体属性修改 th:value th:href th:src ... 7 文字(标签正文修改) th:text th:utext 8 片段规范 th:fragment 9 片段删除 th:remove Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/MVC配置原理.html":{"url":"frame4/MVC配置原理.html","title":"5.11 MVC配置原理","keywords":"","body":"5.11 MVC配置原理 Spring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。 自动配置在Spring的默认值之上添加了以下功能： 包含ContentNegotiatingViewResolver和BeanNameViewResolver。 支持提供静态资源，包括对WebJars的支持。 自动注册Converter，GenericConverter和Formatter豆类。 支持HttpMessageConverters。 自动注册MessageCodesResolver。 静态index.html支持。 定制Favicon支持。 自动使用ConfigurableWebBindingInitializerbean。 如果您想保留Spring Boot MVC功能并想添加其他MVC配置（拦截器，格式化程序，视图控制器和其他功能），则可以添加自己@Configuration的type类， WebMvcConfigurer但不添加 @EnableWebMvc。如果您希望提供，或的 自定义实例RequestMappingHandlerMapping，则可以声明一个 实例来提供此类组件。RequestMappingHandlerAdapter ExceptionHandlerExceptionResolver WebMvcRegistrationsAdapter 如果您想完全控制Spring MVC，可以使用添加自己的@Configuration 注释@EnableWebMvc。 了解：扩展视图解析器 官方文档说了：如果您想保留Spring Boot MVC功能并想添加其他MVC配置（拦截器，格式化程序，视图控制器和其他功能），则可以添加自己@Configuration的type类。 //定义一个Spring配置类，实现WebMvcConfigurer接口，来扩展MVC配置 @Configuration public class MyMvcConfig implements WebMvcConfigurer { //2.将自定义的视图解析器MyViewResolver注册到Spring @Bean public ViewResolver myViewResolver(){ return new MyViewResolver(); } //1.自定义一个视图解析器（这里定义了一个静态内部类） public static class MyViewResolver implements ViewResolver{ @Override public View resolveViewName(String viewName, Locale locale) throws Exception { return null; } } } 自定义的视图解析器定义完之后，来测试一下： 所有的request和response都要经过DispatcherServlet，在doDispatch()方法这里打一个断点： 当请求过来之后，可以看到，当前DispatcherServlet对象的viewResolvers属性（List），包含了我们刚刚定义的视图解析器，说明自定义的视图解析器已经被SpringBoot自动配置了。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-准备工作.html":{"url":"frame4/员工管理系统-准备工作.html","title":"5.12 员工管理系统：准备工作","keywords":"","body":"5.12 员工管理系统：准备工作 需要用到的前端页面素材（代码已上传至码云）：https://gitee.com/ENNRIAAA/springboot-learning 创建一个干净的SpringBoot项目： POM中添加启动器： org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 将下载好的素材资源分别放在resources中的templates和static中： static中的资源默认被加载的，而templates中的资源不会默认被加载，需要我们额外配置 准备数据： 定义实体类pojo： 部门： /** * 部门表 */ @Data @AllArgsConstructor @NoArgsConstructor public class Department { private Integer id; private String departmentName; } 员工： /** * 员工表 */ @Data @AllArgsConstructor @NoArgsConstructor public class Employee { private Integer id; private String lastName; private String email; private Integer gender;//0：女 1：男 private Department department; private Date birth; } 定义Dao层：Dao层不连接数据库，自定义一些数据做演示 部门： @Repository public class DepartmentDao { private static Map departments; /** * 初始化数据，模拟数据库数据 */ static { departments = new HashMap<>(); departments.put(101, new Department(101, \"教学部\")); departments.put(102, new Department(102, \"市场部\")); departments.put(103, new Department(103, \"教研部\")); departments.put(104, new Department(104, \"运营部\")); departments.put(105, new Department(105, \"后勤部\")); } /** * 获得所有部门 * @return */ public Collection getDepartments(){ return departments.values(); } /** * 通过ID获取部门信息 * @param id * @return */ public Department getDepartmentById(Integer id){ return departments.get(id); } } 员工： @Repository public class EmployeeDao { private static Map employees; @Autowired private DepartmentDao departmentDao; /** * 初始化数据，模拟数据库数据 */ static { employees = new HashMap<>(); employees.put(1001, new Employee(1001, \"AAA\", \"aaa@qq.com\", 1, new Department(101, \"后勤部\"))); employees.put(1002, new Employee(1002, \"BBB\", \"bbb@qq.com\", 1, new Department(102, \"市场部\"))); employees.put(1003, new Employee(1003, \"CCC\", \"ccc@qq.com\", 0, new Department(101, \"后勤部\"))); employees.put(1004, new Employee(1004, \"DDD\", \"ddd@qq.com\", 0, new Department(104, \"运营部\"))); employees.put(1005, new Employee(1005, \"EEE\", \"eee@qq.com\", 1, new Department(101, \"后勤部\"))); } //主键自增 private static Integer initId = 1006; /** * 添加员工 * * @param employee */ public void addEmployee(Employee employee) { //员工id为null时，使用默认主键 if (employee.getId() == null) { employee.setId(initId++); } //传入部门id，自动设置所在部门名称（因为你在前端页面时，只需要设置你所在的部门id即可，而不是id和部门名称都需要手动填入） employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId())); employees.put(employee.getId(), employee); } /** * 获得所有员工信息 * @return */ public Collection getEmployees() { return employees.values(); } /** * 通过ID查询员工 * @param id * @return */ public Employee getEmployee(Integer id){ return employees.get(id); } /** * 通过ID删除员工 * @param id */ public void removeEmployee(Integer id){ employees.remove(id); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-首页实现.html":{"url":"frame4/员工管理系统-首页实现.html","title":"5.13 员工管理系统：首页实现","keywords":"","body":"5.13 员工管理系统：首页实现 之前说过，/resources/templates下的资源默认是不能直接访问的，可以通过以下两种方式配置： Controller中配置 自定义WebMvcConfigurer配置类 配置WebMvcConfigurer： 创建一个config包，定义MvcConfig类，实现WebMvcConfigurer接口，用来配置视图控制： 通过实现WebMvcConfigurer接口来扩展视图配置 @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); } } 这一步做了什么？ @Configuration：这个注解修饰的类，说明该类是一个Spring配置类 implements WebMvcConfigurer：实现该接口，可以用来扩展WebMvcConfigurer的配置 public void addViewControllers(ViewControllerRegistry registry) {}：重写addViewControllers()方法，添加一个视图控制器 registry.addViewController(\"/\").setViewName(\"index\");：添加视图控制，设置url-pattern，指向视图index。（前缀和后缀在Thymeleaf视图解析器中默认设置） 这和在Controller中使用ModelAndView添加视图操作类似，自定义一个路径映射到一个页面 配置视图之后，使用浏览器访问首页测试下： 发现首页已经可以访问，但是页面样式没有加载进来。原因在于需要使用Thymeleaf的形式引入资源。 Thymeleaf方式引入静态资源： index.html页面添加thymeleaf命名空间： 引入外部静态资源的地方替换成·thymeleaf的形式： th:href：绑定href属性，@{}：表达式引用资源路径 注意：thymeleaf形式的引用只需要修改本地资源的部分，如果引用的是网络上的资源，不需要使用这种形式。 将所有的引用都替换完之后，访问主页的效果： 页面样式正常了，接着把其它几个HTML页面也做同样的修改。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-国际化.html":{"url":"frame4/员工管理系统-国际化.html","title":"5.14 员工管理系统：国际化","keywords":"","body":"5.14 员工管理系统：国际化 国际化指的是页面可以实现多语言展示，既可以显示中文，又可以显示英文页面或者其它语言。 注意：实现国际化之前，要保证项目编码使用的是UTF-8，否则可能会出现中文乱码问题。 第一步： 首先，在resources下新建目录i18n目录，i18n即internationalization的缩写。 在i18n目录下新建login.properties、login_zh_CN.properties、login_en_US.properties三个配置文件，IDEA会自动把这几个配置文件放到一个资源包下： 这几个配置文件是用来配置国际化的。 然后，选中配置文件，添加属性键： 设置key-value：添加属性键，通过一个属性键对应多个不用语言的值 根据index.html页面，配置如下几个中英文的键值对： login.btn=登录 login.password=密码 login.remember=记住我 login.tip=请登录 login.username=用户名 这一步做了什么？ 首先，在配置文件中自定义属性键(key)，一个key对应不同语言的值。 然后，用创建好的属性键替换掉index.html页面中需要国际化的文本 接下来，再配置一个LocaleResolver区域解析器，区域解析器通过请求参数来判断页面要显示的语言 第二步： 在application.yml中设置消息的basename来引用刚刚的配置文件，basename指向国际化文件的真实位置 spring: messages: basename: i18n/login 修改HTML中的文本引用： 使用创建好的属性键替换掉页面中的文本 thymeleaf中使用#{}表达式引用国际化文本 修改HTML中的这五个文本 第三步： 做完上面的工作之后，国际化还不能正常使用，因为我们的请求默认请求的是中文页面。 关于SpringBoot中的区域解析器： 解读：WebMvcAutoConfiguration类中的localeResolver()方法： @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() { if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; 如果我们在配置文件中配置了mvcProperties的属性，则会根据配置文件来配置LocaleResolver对象 如果配置文件没有配置，则返回一个默认的LocaleResolver 因为我们没有在application.yaml中配置关于区域的属性，所以SpringBoot会使用默认的LocaleResolver。 看一下默认的区域解析器是怎么生成的： AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); 是通过实例化AcceptHeaderLocaleResolver对象，设置默认的区域配置来生成的区域解析器。 打开AcceptHeaderLocaleResolver类看一下： public class AcceptHeaderLocaleResolver implements LocaleResolver { 这个类实现了LocaleResolver接口，并实现了resolveLocale()方法： @Override public Locale resolveLocale(HttpServletRequest request) { Locale defaultLocale = getDefaultLocale(); if (defaultLocale != null && request.getHeader(\"Accept-Language\") == null) { return defaultLocale; } Locale requestLocale = request.getLocale(); List supportedLocales = getSupportedLocales(); if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) { return requestLocale; } Locale supportedLocale = findSupportedLocale(request, supportedLocales); if (supportedLocale != null) { return supportedLocale; } return (defaultLocale != null ? defaultLocale : requestLocale); } 所以，我们也可以自定义一个类来实现LocaleResolver这个接口，并重现接口中的方法，这就是我们自定义的区域解析器： public class MyLocaleResolver implements LocaleResolver { /** * 通过请求参数中的lang获取对应的区域 * * @param request * @return */ @Override public Locale resolveLocale(HttpServletRequest request) { String lang = request.getParameter(\"lang\"); Locale locale = Locale.getDefault(); if (!StringUtils.isEmpty(lang)) { //如果lang不为空，根据下划线分割zh_CN或者en_US，得到语言和国家 String[] split = lang.split(\"_\"); //实例化Locale并传入当前的语言和国家，生成并返回该对象 locale = new Locale(split[0], split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } } 当我们定义完视图解析器后，需要到MyMvcConfig配置类中将区域解析器注册到IoC容器中，让解析器生效。 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); } //通过Java代码注册Bean @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } 测试： 启动SpringBoot，测试： 在页面点击英文，地址栏中的会变成响应的请求，通过自定义的区域解析器获取请求参数lang的值，得到对应的区域信息，调用国际化配置。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-登录功能实现.html":{"url":"frame4/员工管理系统-登录功能实现.html","title":"5.15 员工管理系统：登录功能实现","keywords":"","body":"5.15 员工管理系统：登录功能实现 Step1 定义登录控制器 @Controller public class LoginController { @RequestMapping(\"/user/login\") public String login(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password, Model model){ if(\"admin\".equals(username)&&\"123\".equals(password)){ return \"dashboard\"; }else{ model.addAttribute(\"msg\",\"用户名或密码错误\"); return \"index\"; } } } 这里用户名密码的判断逻辑就ssu随意了，因为没有连接数据库，只是做一个演示而已。 如果登录成功，页面将跳转到dashboard； 登录不成功，设置一个msg提示消息，并跳转到index页面。 Step2 修改index.html表单提交地址 前端页面请求是通过form表单提交的，所以action属性要使用thymeleaf形式，属性名前加th:，并指向刚刚创建的控制器 th:action=\"@{/user/login}\"是固定格式。 重启SpringBoot，测试可以正常登录。 Step3 登录失败时页面显示提示消息 当用户名或密码错误时，页面应该显示一个友好的提示信息。所以在页面适当的位置加上一个p标签： th:text=\"${msg}\"：显示控制器在model中传来的msg消息 th:if=\"${not #strings.isEmpty(msg)}\"：判断msg不为空时才显示该标签 Step4 为后台页面添视图控制 登录成功后，会跳转到后台页面dashboard.html。但是这里有一个问题： http://localhost:8081/user/login?username=111&password=222 就是，登录成功后，在后台页面的地址栏中显示的仍然是带有请求参数的URL，这样看着就很不和谐。 所以，在MyMvcConfig控制类中，为dashboard页面添加一个视图控制： registry.addViewController(\"/main\").setViewName(\"dashboard\"); 并修改LoginController中的方法，登录成功后使用重定向到/main这里： if(\"admin\".equals(username)&&\"123\".equals(password)){ //修改这里 return \"redirect:/main\"; } 修改完之后，登录后台页面的地址栏URL发生了变化： http://localhost:8081/main 这种形式更符合实际网站的效果。 登录功能完成 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-登录拦截器.html":{"url":"frame4/员工管理系统-登录拦截器.html","title":"5.16 员工管理系统：登录拦截器","keywords":"","body":"5.16 员工管理系统：登录拦截器 拦截器在学习SpringMVC时就已经接触过，可以通过拦截器实现对登录的拦截，只有登录成功才可以访问后台页面，否则不能直接访问后台页面。 Step1. 修改LoginController 登录成功后，在session域中存储一个属性loginUser，用于拦截器判断拦截的依据： if (\"admin\".equals(username) && \"123\".equals(password)) { //登录成功，存储\"loginUser\"属性 session.setAttribute(\"loginUser\",username); return \"redirect:/main\"; } Step2. 在config包下新建拦截器 自定义类实现HandlerInterceptor接口，实现preHandle方法： public class LoginHandlerInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取session中的\"loginUser\" String loginUser = (String)request.getSession().getAttribute(\"loginUser\"); //如果没有获取到\"loginUser\"，说明没有登录 if(loginUser==null){ request.setAttribute(\"msg\",\"没有权限，请先登录\"); request.getRequestDispatcher(\"/\").forward(request,response); return false; } //true表示放行 return true; } } 解析拦截器： 获取到session中的loginUser属性 如果没有获取到，则说明用户没有登录 添加msg提示消息，并转发到index.html页面 return flase表示拦截 Step3. 将拦截器添加到IoC容器中 实现接口中的addInterceptors()方法，添加要拦截的url-pattern和要放行的url-pattern @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(\"/*\") .excludePathPatterns(\"/\", \"/index.html\",\"/login\",\"/css/*\",\"/img/*\",\"/js/*\"); } 把要放行的资源路径都添加进来，包括静态资源，否则样式等等都会被拦截 这一步相当于Spring在xml中配置拦截器。 拦截器配置完毕，登录成功后，可以访问后台页面，没有登录无法直接访问后台页面 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-展示员工列表.html":{"url":"frame4/员工管理系统-展示员工列表.html","title":"5.17 员工管理系统：展示员工列表","keywords":"","body":"5.17 员工管理系统：展示员工列表 Step1 提取公共页面 打开dashboard.html和list.html页面会发现，头部导航栏和侧边栏的代码是重复的，所以我们可以把重复部分的代码抽取出来放到一个公共的页面里 在templates下新建一个commons目录，并创建一个commons.html页面，将头部导航栏和侧边栏的代码剪切到这个页面下，并添加fragment属性（如上图）： th:fragment=\"XXX\" Thymeleaf 中使用fragment属性声明代码片段，再通过insert或者replace将代码片段插入或替换过来。 在dashboard.html和list.html页面中，将代码片段再替换过来 th:replace=\"~{commons/commons::sidebar(active='main')}\" 通过replace属性把代码片段替换过来 commons/commons表示公共页面所在的位置， sidebar表示要提取的名称 (active='main')可以通过()往公共页面传参数 Step2 修改页面高亮问题 这个是dashboard.html后台页面 左侧侧边栏应该点击哪个，哪个高亮。而现在无论点击哪个一直都是首页高亮，现在需要解决这个问题。 修改dasnboard.html页面的replace属性，通过()像commons页面传递属性： 修改list.html页面，同样传递属性： 再修改commons.html 高亮的实现逻辑： 当我们点击侧边栏的首页时，active='main'；当我们点击员工时，active='list'，将active的值传入到commons页面中 在首页标签和员工标签上使用三元表达式进行判断，如果active（这个值是通过前两个页面传过来的）=='main'，则class=\"nav-link active\",标签样式高亮。 额外说的一点：这里的href='XXX'既可以使用thymeleaf形式，也可以不使用。因为这里访问的是控制器。 Step3 员工列表展示 在controller包下新建一个控制器EmployeeController，用来获取员工数据并跳转到list.html页面： @Controller public class EmployeeController { @Autowired private EmployeeService employeeService; @RequestMapping(\"/emps\") public String list(Model model) { //获取员工集合 Collection employees = employeeService.getEmployees(); //添加到model中 model.addAttribute(\"emps\", employees); //返回list页面（把功能页面都放到templates/emp目录下） return \"emp/list\"; } } 修改list.html，展示数据： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-增加员工实现.html":{"url":"frame4/员工管理系统-增加员工实现.html","title":"5.18 员工管理系统：增加员工实现","keywords":"","body":"5.18 员工管理系统：增加员工实现 Step1 页面添加“新增员工”按钮 添加员工 在list.html页面适当位置处添加a标签，添加完后看一下页面的效果： Step2 添加“添加员工”页面 list.html页面添加员工按钮指向一个控制器 添加员工 在EmployeeController控制器中添加【获取“添加员工”页面】的方法： /** * 获取\"添加员工\"页面 * @return */ @GetMapping(\"/add\") public String getAddPage(){ return \"emp/add\"; } Step3 创建“添加员工”页面 在emp包下直接复制list.html页面并改名为add.html 删除内的所有标签后，添加form表单，代码如下： 姓名 邮箱 性别 男 女 部门 生日 添加 将form表单放到标签内 Step4 创建执行添加员工的方法 EmployeeController中添加执行添加操作的方法 /** * 执行添加员工操作 * @param employee * @return */ @PostMapping(\"/add\") public String addMethod(Employee employee){ employeeService.addEmployee(employee); return \"redirect:/emps\"; } 添加成功后重定向到/emps方法中，查询员工数据，跳转到list.html页面 Application.yml中添加日期格式配置： 因为前端表单提交的是yyyy-MM-dd格式的，而SpringBoot默认的日期格式是dd/MM/yyyy mvc: format: date: yyyy-MM-dd Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-修改员工信息.html":{"url":"frame4/员工管理系统-修改员工信息.html","title":"5.19 员工管理系统：修改员工信息","keywords":"","body":"5.19 员工管理系统：修改员工信息 Step1 编辑按钮指向控制器 编辑 th:href=\"@{/update/}+${emp.getId()}\"这个是指向的后端控制器的路径，使用Restful风格的路径，而不是update?id=xxx这种。 点击编辑按钮（改用a标签），像后端发出请求，并携带对应的员工id。 Step2 编写控制器方法 //这里也需要使用Restful风格接收请求参数 @GetMapping(\"/update/{id}\") public String getUpdatePage(@PathVariable(\"id\") Integer id, Model model) { //通过id查询到员工信息并返回到前端 Employee employee = employeeService.getEmployee(id); model.addAttribute(\"emp\", employee); //获取到所有部门信息 Collection departments = departmentService.getDepartments(); model.addAttribute(\"departments\",departments); return \"emp/update\"; } 通过前端页面传过来的员工id，调用Dao获取到对应的员工信息，并返回。 获取所有的部门数据返回给前端页面，为了显示员工部门。 最终跳转到更新页面。 Step3 编写更新页面 直接复制一份儿add.html页面，命名update.html 修改和添加的逻辑差不多，首先先把后端传过来的要修改的对应的员工数据都展示到输入框中： 姓名 th:value=\"${emp.lastName}\"让输入框value默认为员工的数据 其余的数据也都这样修改，性别和部门有点儿区别，需要加上一些逻辑： 男 checked属性通过是否等于1，等于1则默认选中。 部门信息展示通过遍历后端传过来的部门数据(departments)遍历显示，再通过判断员工对应的部门id(emp.department.id)和遍历的部门id(dept.id)做比较，相等则默认选中，这样就可以显示员工对应的部门了。 部门 出生日期value值要做格式化，否则不会显示默认的日期（部分浏览器可以显示）： 生日 使用Thymeleaf提供的工具进行格式化日期格式。 最后要在表单中加一个隐藏域： 要把员工id带出来，否则后端接收不到id的值，我们后端是通过id来修改员工数据。 Step4 提交表单编写控制器方法 表单提交方式使用POST 接收到前端页面传来的员工数据(employee)，调用Dao中的方法，执行更新。 @PostMapping(\"/update\") public String updateMethod(Employee employee){ employeeService.updateEmployee(employee); return \"redirect:/emps\"; } 前端传进来的员工数据(employee)中，部门属性(department)中只有id的值，没传(departmentName)的值，所以部门名称为null。这里在Dao层的修改方法中处理下这个问题： public void updateEmployee(Employee employee){ //前端传进来的部门只有部门id，没有部门名称，所以要通过部门id设置部门名称 employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId())); //通过ID替换员工 employees.replace(employee.getId(),employee); } 最终，控制器执行完修改操作后，重定向到/emps的方法中，获取更新后的员工数据，返回到list.html页面。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/员工管理系统-删除及404.html":{"url":"frame4/员工管理系统-删除及404.html","title":"5.20 员工管理系统：删除及404","keywords":"","body":"5.20 员工管理系统：删除及404 Step1 删除按钮指向控制器 删除 Step2 编写控制器删除方法 @GetMapping(\"/delete/{id}\") public String deleteMethod(@PathVariable(\"id\")Integer id){ employeeService.removeEmployee(id); return \"redirect:/emps\"; } 接收前端页面传过来的员工id，调用Dao中通过id删除员工的方法，最后重定向到/emps获取删除后的所有员工数据，返回到list.html页面。 404页面 添加404页面非常简单，只需要在templates目录下新建error文件夹，在里面添加404.html即可，当前端访问出现404时，会跳转到这个页面。 注销登录 在LoginController中添加注销方法： @GetMapping(\"/logout\") public String logout(HttpSession session,Model model) { session.invalidate(); model.addAttribute(\"msg\",\"注销成功\"); return \"index\"; } 拦截器拦截访问是通过session中存储的loginUser属性，注销操作可以通过移除该属性，或者使用invalidate()销毁此次会话。 修改commons.html页面的Sign out连接指向： Sign out 案例源码已上传至码云https://gitee.com/ENNRIAAA/springboot-learning-idea Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/整合JDBC.html":{"url":"frame4/整合JDBC.html","title":"5.21 整合JDBC","keywords":"","body":"5.21 整合JDBC 对于数据访问层，无论是SQL还是NOSQL，SpringBoot底层都是采用Spring Data的方式进行统一处理。 SpringBoot底层都是采用Spring Data的方式进行统一处理各种数据库，Spring Data也是Spring中与SpringBoot、Spring Cloud等齐名的项目。 SpringBoot使用jdbc操作数据库 创建SpringBoot项目，并添加启动器： org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-web 在application.yml中配置数据源： # mysql数据源 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/neu_javaweb username: root password: 12345678 获取连接对象： 打印输出数据源DataSource对象和Connection对象： @Autowired private DataSource dataSource; @Test void contextLoads() throws SQLException { System.out.println(dataSource.getClass()); //获取连接对象 Connection conn = dataSource.getConnection(); System.out.println(conn); } class com.zaxxer.hikari.HikariDataSource HikariProxyConnection@1412752396 wrapping com.mysql.cj.jdbc.ConnectionImpl@3b48e183 SpringBoot默认的连接池HikariDataSource 使用JdbcTemplate JdbcTemplate是Spring的一个操作数据库的工具类，在学习JDBC的时候使用过。https://javabook.shiguangping.com/mysql3/SpringJDBC.html 创建一个包controller，创建JdbcController类： @Controller public class JdbcController { @Autowired private JdbcTemplate jdbcTemplate; /** * 查询数据库的所有数据 */ @RequestMapping(\"/queryUsers\") @ResponseBody public List> userList() { String sql = \"select * from user1\"; return jdbcTemplate.queryForList(sql); } } JdbcTemplate查询数据库非常方便，可以直接将查询数据封装到List集合中，也可以直接封装成实体类对象。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/整合Druid数据源.html":{"url":"frame4/整合Druid数据源.html","title":"5.22 整合Druid数据源","keywords":"","body":"5.22 整合Druid数据源 添加Druid数据源： 添加依赖坐标： com.alibaba druid 1.1.22 ymal中设置type属性： # mysql数据源 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/neu_javaweb username: root password: 12345678 type: com.alibaba.druid.pool.DruidDataSource # 初始化大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间(毫秒) maxWait: 3000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置有一个连接在连接池中的最小生存时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql将无法统计，'wall'用于防火墙 filters: stat, wall ,log4j # 通过connectProperties属性来打开mergeSql功能，慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 设置type属性为DruidDataSource，可以配置Druid相关参数，打开监控 此时，Druid数据源已经生效了 配置statViewServlet监控Servlet： 创建一个配置类起名DruidConfig（类名随意）： package com.example.config; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.util.HashMap; import java.util.Map; @Configuration public class DruidConfig { /** * 加载数据源到容器，引入配置文件中的配置 * @return */ @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druidDataSource(){ return new DruidDataSource(); } /** * 配置StatViewServlet * @return */ @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean<>(new StatViewServlet(), \"/druid/*\"); //配置配置StatViewServlet的初始化参数 HashMap initParameters = new HashMap<>(10); //登陆的用户名密码 initParameters.put(\"loginUsername\",\"admin\"); initParameters.put(\"loginPassword\",\"123\"); //允许谁可以访问(白名单) initParameters.put(\"allow\",\"127.0.0.1\"); //禁止谁访问(黑名单) initParameters.put(\"liyan\",\"192.168.1.123\"); //将存储初始化参数的map添加进来 bean.setInitParameters(initParameters); return bean; } @Bean public FilterRegistrationBean webStatFilter(){ //WebStatFilter过滤器（可以通过带参构造传入WebStatFilter实例，也可以通过set方法） FilterRegistrationBean bean = new FilterRegistrationBean(new WebStatFilter()); //设置初始化参数 Map initParameters = new HashMap<>(10); initParameters.put(\"exclusions\",\"*.js,/druid/*\"); bean.setInitParameters(initParameters); return bean; } } 这里要了解两个类： ServletRegistrationBean FilterRegistrationBean 在SpringBoot中，Servlet被内部集成，不需要配置web.xml，所以配置Servlet和Filter需要通过这两个类。 访问监控页面： 访问路径在配置Servlet时设置的 localhost:8080/druid Druid Spring Boot Starter Druid Spring Boot Starter 用于帮助你在Spring Boot项目中轻松集成Druid数据库连接池和监控。 Github地址 Maven坐标： com.alibaba druid-spring-boot-starter 1.1.23 配置文件： spring: profiles: dev datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/GATS_DB username: root password: 12345678 # 初始化大小，最小，最大 initial-size: 5 min-idle: 5 max-active: 20 # 配置获取连接等待超时的时间(毫秒) max-wait: 3000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 60000 # 配置有一个连接在连接池中的最小生存时间，单位是毫秒 min-evictable-idle-time-millis: 30000 validation-query: SELECT 1 FROM DUAL test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，指定每个连接上PSCache的大小 pool-prepared-statements: true max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters，去掉后监控界面sql将无法统计，'wall'用于防火墙 filters: stat,wall # 通过connectProperties属性来打开mergeSql功能，慢SQL记录 connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 type: com.alibaba.druid.pool.DruidDataSource Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/整合Mybatis框架.html":{"url":"frame4/整合Mybatis框架.html","title":"5.23 整合Mybatis框架","keywords":"","body":"5.23 整合Mybatis框架 引入依赖： org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.3 编写UserMapper接口： @Mapper @Repository public interface UserMapper { List queryUsersList(); User queryUserById(Integer id); int addUser(User user); int updateUser(User user); int deleteUser(Integer id); } @Mapper注解：说明这个接口是一个Mybatis映射器，也可以在Spring配置类中使用@MapperScan(\"com.example.mapper\")注解来扫描映射器 @Repository：将映射器添加到容器，可以不加这个注解 编写UserMapper.xml： select * from user1 配置SpringBoot配置文件： #mybatis配置 mybatis: type-aliases-package: com.example.pojo mapper-locations: classpath:mybatis/mapper/*.xml 设置实体类别名，将mybatis映射文件添加进来。 编写控制类方法，进行测试： @Controller @RequestMapping(\"/user\") public class UserController { @Autowired private UserMapper userMapper; @GetMapping(\"queryUsers\") @ResponseBody public List queryUser(){ return userMapper.queryUsersList(); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/SpringSecurity环境搭建.html":{"url":"frame4/SpringSecurity环境搭建.html","title":"5.24 SpringSecurity环境搭建","keywords":"","body":"5.24 SpringSecurity环境搭建 用到的页面素材已上传至码云：https://gitee.com/ENNRIAAA/spring-security-material 创建SpringBoot项目，添加依赖： org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 将页面素材中static/qinjiang目录赋值到项目的static中，将素材中templates/index.html和views目录复制到项目的templates下： 创建controller包，并创建RouterController： resources/template下的资源是不能直接被访问的，通过控制器路由各个页面。 @Controller public class RouterController { /** * 首页 * @return */ @RequestMapping({\"/\",\"/index\"}) public String index(){ return \"index\"; } /** * 登录页 * @return */ @RequestMapping(\"/toLogin\") public String toLogin(){ return \"views/login\"; } /** * level1下的页面 * @param id * @return */ @RequestMapping(\"/level1/{id}\") public String level1(@PathVariable(\"id\") int id){ return \"views/level1/\"+id; } /** * level2下的页面 * @param id * @return */ @RequestMapping(\"/level2/{id}\") public String level2(@PathVariable(\"id\") int id){ return \"views/level2/\"+id; } /** * level3下的页面 * @param id * @return */ @RequestMapping(\"/level3/{id}\") public String level3(@PathVariable(\"id\") int id){ return \"views/level3/\"+id; } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/用户认证和授权.html":{"url":"frame4/用户认证和授权.html","title":"5.25 用户认证和授权","keywords":"","body":"5.25 用户认证和授权 Spring Security是针对Spring项目的安全框架，也是SpringBoot底层安全模块默认的技术选型，它可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标是“认证”和“授权”（访问控制）。 认证(Authentication) 授权(Authorization) 配置流程： 添加Spring Security依赖 org.springframework.boot spring-boot-starter-security 新建config包，创建类SecurityConfig并继承WebSecurityConfigurerAdapter： 使用@EnableWebSecurity注解启用WebSecurity @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter {} 编写方法，添加授权规则： //授权 @Override protected void configure(HttpSecurity http) throws Exception { //首页所有人可以访问，功能页面只有对应权限的用户可以访问 //请求授权的规则，有对应角色的用户才可以访问对应的页面 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); //没有权限会跳转到登录页面 http.formLogin(); } 启动SpringBoot测试，访问首页的功能页面(如：http://localhost:8080/level2/2)由于没有登陆是无权访问的，所以自动跳转到登陆页面。 编写方法，添加认证规则： /** * 认证 * PasswordEncoder 密码需要编码 * Spring Security5.0+ 新增了很多加密方式 */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //认证内存中的用户 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip2\",\"vip3\") .and().withUser(\"liyan\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\") .and().withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\",\"vip2\",\"vip3\"); } 这种是认证内存中的用户名和密码，已经角色的权限。还可以认证jdbc中的用户名和密码。 重启SpringBoot，再次访问首页的功能页面，会提示登陆，登陆上面设置好的用户名密码，SpringBoot会认证账号权限，然后再访问对应功能页面时，就会授权对应的页面访问权限。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/注销及权限控制.html":{"url":"frame4/注销及权限控制.html","title":"5.26 注销及权限控制","keywords":"","body":"5.26 注销及权限控制 开启注销： 在SecurityConfig中的configure(HttpSecurity http)方法中添加注销： //注销 http.logout().logoutSuccessUrl(\"/\"); 注销成功回到主页 在index.html页面登陆按钮旁边添加注销按钮： 注销 权限控制： 引入thymeleaf-Security整合包： org.thymeleaf.extras thymeleaf-extras-springsecurity5 3.0.4.RELEASE 根据Spring Security版本选择整合包 根据是否登录的状态显示右上角的按钮： 如果未登录，右上角只显示登陆按钮 如果已登陆，右上角显示登陆的用户名和注销按钮 这里就需要使用到thymeleaf-Security的整合包，在thymeleaf中使用Security的特性 登录 &nbsp; 注销 这一步做完就能达到如上说的效果，之后还需要做一步，每个账号的角色权限不一样，登陆之后应该显示自己可以访问的功能页面，无权访问的功能页面不显示，同上面的登录注销按钮效果类似。 修改index.html页面： 每个功能块添加sec:authorize=\"hasRole('vip1')\"，有该访问权限的账号登陆，才会在首页显示对应的功能块 Level 1 Level-1-1 Level-1-2 Level-1-3 Level 2 Level-2-1 Level-2-2 Level-2-3 Level 3 Level-3-1 Level-3-2 Level-3-3 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/记住我及首页定制.html":{"url":"frame4/记住我及首页定制.html","title":"5.27 记住我及首页定制","keywords":"","body":"5.27 记住我及首页定制 记住我： SecurityConfig方法中添加： //开启记住我功能 http.rememberMe(); 默认的登录页出现记住我按钮： 记住我功能，实际会在本地存储一个cookie，关闭浏览器下次在访问首页的时候，登陆的信息依旧存在。 设置登陆页面 上面使用的登录页面是SpringSecurity默认的登陆页面，我们要将登录页面设置成自己写的页面： 方式一：前端form表单提交的地址和SpringSecurity登录页面都设置成我们自己的登录控制： 在SecurityConfig中的configure方法中设置loginPage属性 http.formLogin().loginPage(\"/toLogin\"); /toLogin指向我们自己的登陆控制类方法： @RequestMapping(\"/toLogin\") public String toLogin(){ return \"views/login\"; } login.html的表单提交地址也要设置成/toLogin： 表单提交的用户名和密码name属性要是username和password，这是SpringBoot默认能接收到的，如果前端提交的请求参数名不是这个，需要通过.usernameParameter(\"user\").passwordParameter(\"pwd\")设置请求参数名。 方式二：表单递交给SpringSecurity默认的登录路径， 前端把请求参数提交给SpringSecurity默认的登录路径： 在SecurityConfig中的configure方法中设置loginPage属性： http.formLogin().loginPage(\"/toLogin\").usernameParameter(\"user\").passwordParameter(\"pwd\").loginProcessingUrl(\"/login\"); usernameParameter和passwordParameter设置前端提交的请求参数名 在我们的登录页面添加记住我 login.html页面添加记住我： 记住我 name属性设置自定义，后端SecurityConfig设置记住我的参数： http.rememberMe().rememberMeParameter(\"remember\"); 前端的name属性是什么，后端就要设置要接受的请求参数的名字，否则接收不到。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/思维导图梳理.html":{"url":"frame4/思维导图梳理.html","title":"5.27.3 思维导图梳理","keywords":"","body":"5.27.3 思维导图梳理 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro快速使用.html":{"url":"frame4/Shiro快速使用.html","title":"5.28 Shiro快速使用","keywords":"","body":"5.28 Shiro快速使用 什么是Shiro？ Apache Shiro是一个Java的安全（权限）框架 Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境 Shiro可以完成认证、授权、加密、会话管理、Web集成、缓存等 下载地址：https://shiro.apache.org/ 官方的十分钟快速开始： 导入依赖： org.apache.shiro shiro-core 1.5.3 org.slf4j jcl-over-slf4j 1.7.30 org.slf4j slf4j-log4j12 1.7.30 log4j log4j 1.2.17 配置文件： shiro.ini [users] # user 'root' with password 'secret' and the 'admin' role root = secret, admin # user 'guest' with the password 'guest' and the 'guest' role guest = guest, guest # user 'presidentskroob' with password '12345' (\"That's the same combination on # my luggage!!!\" ;)), and role 'president' presidentskroob = 12345, president # user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz' darkhelmet = ludicrousspeed, darklord, schwartz # user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz' lonestarr = vespa, goodguy, schwartz # ----------------------------------------------------------------------------- # Roles with assigned permissions # # Each line conforms to the format defined in the # org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc # ----------------------------------------------------------------------------- [roles] # 'admin' role has all permissions, indicated by the wildcard '*' admin = * # The 'schwartz' role can do anything (*) with any lightsaber: schwartz = lightsaber:* # The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with # license plate 'eagle5' (instance specific id) goodguy = winnebago:drive:eagle5 log4j.properites log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n # General Apache libraries log4j.logger.org.apache=WARN # Spring log4j.logger.org.springframework=WARN # Default Shiro logging log4j.logger.org.apache.shiro=INFO # Disable verbose logging log4j.logger.org.apache.shiro.util.ThreadContext=WARN log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN 快速开始 QuickStart.java import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.session.Session; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Quickstart { private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) { // 通过shiro.ini配置获取工厂，然后获取到SecurityManager实例，通过该实例获取到Subject得到当前用户 Factory factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); // get the currently executing user: Subject currentUser = SecurityUtils.getSubject(); // 通过Subject对象获取Session，使用session可以存值取值 Session session = currentUser.getSession(); session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) { log.info(\"Retrieved the correct value! [\" + value + \"]\"); } // 判断当前用户是否认证 if (!currentUser.isAuthenticated()) { // 没认证使用用户名密码获取令牌 UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); // 记住我 token.setRememberMe(true); try { // 使用令牌登陆，如果登陆不成功会catch相应异常 currentUser.login(token); } catch (UnknownAccountException uae) { log.info(\"There is no user with username of \" + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\"); } catch (LockedAccountException lae) { log.info(\"The account for username \" + token.getPrincipal() + \" is locked. \" + \"Please contact your administrator to unlock it.\"); } // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) { //unexpected condition? error? } } // 获取当前用户用户名 log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\"); // 判断当前用户是否有\"schwartz\"角色 if (currentUser.hasRole(\"schwartz\")) { log.info(\"May the Schwartz be with you!\"); } else { log.info(\"Hello, mere mortal.\"); } // 判断当前用户是否有\"lightsaber:wield\"许可 if (currentUser.isPermitted(\"lightsaber:wield\")) { log.info(\"You may use a lightsaber ring. Use it wisely.\"); } else { log.info(\"Sorry, lightsaber rings are for schwartz masters only.\"); } //a (very powerful) Instance Level permission: if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) { log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\"); } else { log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\"); } // 注销当前用户 currentUser.logout(); // 停止虚拟机 System.exit(0); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro的Subject分析.html":{"url":"frame4/Shiro的Subject分析.html","title":"5.29 Shiro的Subject分析","keywords":"","body":"5.29 Shiro的Subject分析 解读官方的十分钟快速开始： 通过SecurityUtils获取Subject对象，得到当前User Subject currentUser = SecurityUtils.getSubject(); 通过当前User获取Session对象 Session session = currentUser.getSession(); session存值取值： session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); 判断当前User是否被认证： // 被认证返回true currentUser.isAuthenticated() 通过用户名密码生成令牌token： UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); token.setRememberMe(true);// 还可以设置记住我 通过令牌登陆： currentUser.login(token); 得到当事人（登陆用户名）： 如果当前User没有被认证（没登录），则返回null currentUser.getPrincipal() 判断当前用户是否有XXX角色： // 认证（角色） currentUser.hasRole(\"schwartz\") 判断当前用户是否有XXX许可： // 授权（许可） currentUser.isPermitted(\"lightsaber:wield\") 注销： currentUser.logout(); 了解了Shiro的基础对象之后，接下来要完成SpringBoot整合Shiro Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/SpringBoot整合Shiro环境搭建.html":{"url":"frame4/SpringBoot整合Shiro环境搭建.html","title":"5.30 SpringBoot整合Shiro环境搭建","keywords":"","body":"5.30 SpringBoot整合Shiro环境搭建 导入Shiro-SpringBoot整合依赖： org.apache.shiro shiro-spring-boot-starter 1.5.3 创建config包，自定义UserRealm类，继承AuthorizingRealm： 重写下面这两个方法，一个是用于授权的，一个是用于认证的 public class UserRealm extends AuthorizingRealm { // 授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { return null; } // 认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { return null; } } 在config下创建ShiroConfig配置类： 依次注册：UserRealm->DefaultWebSecurityManager->ShiroFilterFactoryBean到容器： @Configuration public class ShiroConfig { // ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Autowired DefaultWebSecurityManager securityManager){ // 设置安全管理器 ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); bean.setSecurityManager(securityManager); return bean; } // DefaultWebSecurityManager @Bean public DefaultWebSecurityManager securityManager(@Autowired UserRealm userRealm){ DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联UserRealm securityManager.setRealm(userRealm); return securityManager; } // realms @Bean public UserRealm userRealm(){ return new UserRealm(); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro实现登录拦截.html":{"url":"frame4/Shiro实现登录拦截.html","title":"5.31 Shiro实现登录拦截","keywords":"","body":"5.31 Shiro实现登录拦截 设置Shiro的过滤器： Shiro常用过滤器： anon：无需认证即可访问 authc：必须认证才能访问 user：必须拥有【记住我】功能才能使用 perms：拥有对某个资源的权限才能访问 role：拥有有个角色权限才能访问 通过Shiro过滤器进行拦截请求，设置登陆Url，如果无访问权限，则跳到登录页面： /** * ShiroFilterFactoryBean * @return */ @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Autowired DefaultWebSecurityManager securityManager){ ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); // 设置安全管理器 bean.setSecurityManager(securityManager); // 添加Shiro的内置过滤器 Map filterMap = new LinkedHashMap<>(); filterMap.put(\"/user/**\",\"authc\"); bean.setFilterChainDefinitionMap(filterMap); // 设置登陆页面 bean.setLoginUrl(\"/toLogin\"); return bean; } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro实现用户认证.html":{"url":"frame4/Shiro实现用户认证.html","title":"5.32 Shiro实现用户认证","keywords":"","body":"5.32 Shiro实现用户认证 首先，在控制类中定义登陆的处理方法： @PostMapping(\"/login\") public String login(String username,String password,Model model){ Subject currentUser = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); try{ currentUser.login(token); return \"index\"; }catch (UnknownAccountException une){ model.addAttribute(\"msg\",\"用户名不存在\"); }catch (IncorrectCredentialsException ice){ model.addAttribute(\"msg\",\"密码错误\"); } return \"login\"; } 通过SecurityUtils.getSubject();获取Subject对象，当前用户(currentUser) 通过用户名密码生成令牌(token) currentUser.login(token);，通过令牌登陆，执行这行代码时，就会调用UserRealm类中的doGetAuthenticationInfo方法，这个方法具体内容在下面。 如果UserRealm类中的认证方法认证通过，return \"index\";返回首页 如果认证没有通过，UserRealm类认证方法会抛出异常，控制类这里接收相应异常，返回错误消息(msg)到前端页面 然后，编写UserRealm中的认证方法： /** * 认证 * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { System.out.println(\"执行了认证 doGetAuthenticationInfo()\"); //做一个临时的用户名和密码（正常要从数据库获取） String user = \"admin\"; String pass = \"123\"; //如果登陆的用户名和内存中的用户名不一致，返回null抛出异常 if(!token.getPrincipal().equals(user)){ return null; } //返回SimpleAuthenticationInfo，校验密码 return new SimpleAuthenticationInfo(\"\",pass,\"\"); } 完成这一步可以实现的效果：点击添加或者修改会自动跳转到登陆页面，登陆的用户名或密码错误会提示相应信息，登陆正确会跳转到首页，点击添加或修改可以正常访问。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro整合Mybatis.html":{"url":"frame4/Shiro整合Mybatis.html","title":"5.33 Shiro整合Mybatis","keywords":"","body":"5.33 Shiro整合Mybatis 添加依赖： mysql mysql-connector-java com.alibaba druid 1.1.22 org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.3 log4j log4j 1.2.17 配置application.yml # 配置数据源 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource username: root password: 12345678 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/neu_javaweb # 配置mybatis mybatis: type-aliases-package: com.example.pojo mapper-locations: classpath:mybatis/mapper/*.xml 定义实体类： @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer id; private String username; private String password; } UserMapper接口： @Mapper @Repository public interface UserMapper { /** * 通过用户名获取User数据 * @param username * @return */ User queryUserByName(String username); } UserMapper.xml select * from user1 where username = #{username} 到这为止，mybatis环境搭建完成 UserRealm类中通过表单提交的用户名从数据库获取User数据，再认证： 如果获取的User为null，说明登陆的用户名不存在，return null，抛出UnknownAccountException异常； 如果获取的User不为null，继续验证密码 @Autowired private UserService userService; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 通过前端提交的用户名从数据库获取User数据 User user = userService.queryUserByName((String) token.getPrincipal()); // 如果user为null，说明用户名不存在，返回null抛出异常UnknownAccountException if (user == null) { return null; } // 反之，返回SimpleAuthenticationInfo，校验密码 return new SimpleAuthenticationInfo(\"\", user.getPassword(), \"\"); } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro请求授权实现.html":{"url":"frame4/Shiro请求授权实现.html","title":"5.34 Shiro请求授权实现","keywords":"","body":"5.34 Shiro请求授权实现 Shiro过滤器添加访问过滤： // 拥有perms[user]权限可以访问 filterMap.put(\"/user/add\",\"perms[user:add]\"); filterMap.put(\"/user/update\",\"perms[user:update]\"); // 设置未经授权url bean.setUnauthorizedUrl(\"/unauthorized\"); 有指定许可的用户才可以访问指定功能 数据库表添加perms字段： 在UserRealm中设置许可： 到此处，登陆admin1，可以访问add页面，不能访问update；登陆admin2可以访问update，不能访问add Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Shiro整合Thymeleaf.html":{"url":"frame4/Shiro整合Thymeleaf.html","title":"5.35 Shiro整合Thymeleaf","keywords":"","body":"5.35 Shiro整合Thymeleaf 导入thymeleaf-shiro整合包： com.github.theborakompanioni thymeleaf-extras-shiro 2.0.0 index.html添加shiro命名空间： 在thymeleaf页面添加shiro属性： 到此为止，整合Shiro结束，案例源码已上传至码云https://gitee.com/ENNRIAAA/springboot-shiro-learning Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/Swagger快速入门.html":{"url":"frame4/Swagger快速入门.html","title":"5.36 Swagger快速入门","keywords":"","body":"5.36 Swagger快速入门 Quick Start 搭建SpringBoot项目，创建HelloController： @RestController public class HelloController { @RequestMapping(\"/hello\") public String hello(){ return \"Hello SpringBoot\"; } } 导入Swagger依赖： io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 配置Swagger，创建SwaggerConfig： @Configuration @EnableSwagger2 public class SwaggerConfig { } 访问Swagger的ui： http://localhost:8080/swagger-ui.html 自定义ui页面的信息： @Configuration @EnableSwagger2 public class SwaggerConfig { /** * 加载Swagger Bean * Docket是Swagger的实例 * * @return */ @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()); } /** * 自定义Swagger ApiInfo * @return */ private ApiInfo apiInfo() { // 联系方式 Contact contact = new Contact(\"liyan\",\"http://www.shiguangping.com\",\"18525589998@163.com\"); return new ApiInfo(\"Api Documentation\", \"李炎学习Swagger\", \"1.0\", \"urn:tos\", contact, \"Apache 2.0\", \"http://www.apache.org/licenses/LICENSE-2.0\", new ArrayList()); } } 配置扫描接口： @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).select() // RequestHandlerSelectors 配置请求处理选择器，用来配置选择哪些api .apis(RequestHandlerSelectors // basePackage() 指定包下的接口都会被选择 // any() 所有接口都选择 // none() 所有接口都不选择 // withMethodAnnotation() 选择方法上的注解作用的接口，参数是注解的类对象 // withClassAnnotation() 选择类上的注解作用的接口，参数是注解的类对象 .basePackage(\"com.example.controller\")) // PathSelectors 路径选择器，指定选择的接口路径 .paths(PathSelectors.ant(\"/user/**\")) .build(); } 配置哪些接口会被Swagger扫描到： RequestHandlerSelectors 配置请求处理器选择器（就是控制类中的方法），用来配置选择哪些api： basePackage() 指定包下的接口都会被选择 any() 所有接口都选择 none() 所有接口都不选择 withClassAnnotation() 选择类上的注解作用的接口，参数是注解的类对象 withMethodAnnotation() 选择方法上的注解作用的接口，参数是注解的类对象 PathSelectors可以指定接口路径选择接口： ant() 指定路径 开启或关闭Swagger： @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) // 关闭Swagger，浏览器无法访问Swagger-UI .enable(false) .select() enable(false) 关闭Swagger 如何在开发环境中启用Swagger，在上线时停用Swagger？ 方式一： @Bean public Docket docket(Environment env) { // 匹配div配置文件创建Profiles实例 Profiles profiles = Profiles.of(\"dev\"); // 判断当前激活的配置文件是否是指定配置文件，如果当前激活的是dev，则返回true boolean flag = env.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) // 关闭Swagger，浏览器无法访问Swagger-UI .enable(flag) 方式二：注解 在application-dev.yml（开发环境）中添加swagger.show=true的属性： swagger: show: true 然后，在Swagger配置类中自定义一个布尔类型参数并读取配置文件注入值： @Value(\"${swagger.show}\") private boolean swaggerShow; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(swaggerShow) 把值传给enable()来停用或者启用Swagger。 Swagger分组： // 定义组名称 .groupName(\"liyan\") 一个Docket实例是一个分组，定义多个Docket实例可以定义多个分组 Swagger注释相关的注解： @ApiModel(\"User实体类\")：给实体类添加注释，作用在类上 @ApiModelProperty(\"用户id\")：给实体类参数添加注释 @ApiOperation(\"hello接口\")：给RequestHandler添加注释，控制类方法 @ApiParam(\"用户名\")：给RequestHandler参数添加注释 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/异步任务.html":{"url":"frame4/异步任务.html","title":"5.37 异步任务","keywords":"","body":"5.37 异步任务 实现异步任务就两步： 在异步任务的方法上添加注解： @Async 在启动类上开启异步任务： @EnableAsync Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/邮件任务.html":{"url":"frame4/邮件任务.html","title":"5.38 邮件任务","keywords":"","body":"5.38 邮件任务 添加mail启动器： org.springframework.boot spring-boot-starter-mail 代码： @SpringBootTest class SpringbootTestApplicationTests { /** * 获取JavaMailSenderImpl对象 */ @Autowired private JavaMailSenderImpl sender; @Test void contextLoads() { // 发送简单的邮件 SimpleMailMessage mailMessage = new SimpleMailMessage(); // 设置主题 mailMessage.setSubject(\"Java测试发送邮件\"); // 设置正文 mailMessage.setText(\"早上好啊~\"); mailMessage.setTo(\"721748889@qq.com\"); mailMessage.setFrom(\"18525589998@163.com\"); sender.send(mailMessage); } @Test void contextLoads1() throws MessagingException { // 发送复杂的邮件 MimeMessage mimeMessage = sender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true,\"UTF-8\"); helper.setSubject(\"Java测试邮件\"); helper.setText(\"早上好啊~\",true); // 附件 helper.addAttachment(\"IMG_52d80c.jpg\",new File(\"/Users/liyan/Downloads/IMG_52d80c.jpg\")); helper.setTo(\"721748889@qq.com\"); helper.setFrom(\"18525589998@163.com\"); sender.send(mimeMessage); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/定时执行任务.html":{"url":"frame4/定时执行任务.html","title":"5.39 定时执行任务","keywords":"","body":"5.39 定时执行任务 在要定时执行的任务（方法）上添加注解： @Scheduled(cron = \"0/30 52,53 12 * * ?\")，使用cron表达式设置执行时间 在启动类中开启任务调度： @EnableScheduling 代码示例： @Service public class ScheduledService { /** * 使用cron表达式设置调度任务的时间 * cron 秒 分 时 日 月 星期 * cron = \"30 49 12 * * ?\" 表示每天的12点49分30秒时调度执行任务 * cron = \"0/30 52,53 12 * * ?\" 表示每天的12点52分和53分，每隔30秒执行一次 */ @Scheduled(cron = \"0/30 52,53 12 * * ?\") public void hello(){ System.out.println(\"Hello 被执行了\"); } } Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/SpringBoot集成Redis.html":{"url":"frame4/SpringBoot集成Redis.html","title":"5.40 SpringBoot集成Redis","keywords":"","body":"5.40 SpringBoot集成Redis Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame4/自定义RedisTemplate.html":{"url":"frame4/自定义RedisTemplate.html","title":"5.41 自定义RedisTemplate","keywords":"","body":"5.41 自定义RedisTemplate Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame5/springcloud.html":{"url":"frame5/springcloud.html","title":"SpringCloud","keywords":"","body":"SpringCloud 今天迎来了我转行上班的第一天，但是也受到了足够的打击。公司项目完全看不懂，后端项目使用了Spring Cloud微服务架构，前端是Vue，实现前后端分离。 因此，我要快速提升自己，虽然说代码水平不是一下子就能提高的，但是概念性的东西脑子里必须要有。 从今天开始，我正式进入了微服务的学习阶段。 学习的课程来自慕课网大目老师的Spring Cloud实战课程。 话不多说，开始学习！ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame5/回顾SpringBoot.html":{"url":"frame5/回顾SpringBoot.html","title":"回顾Spring Boot","keywords":"","body":"回顾Spring Boot Spring Boot是什么？能做什么？ 是一个快速开发的脚手架，类似Vue-Cli一样 作用：快速创建独立的、生产级的基于Spring的应用程序 特性： 无需部署war文件 提供Starter简化配置，开箱即用 尽可能自动配置Spring以及第三方库 提供“生产就绪”功能，例如指标、健康检查、外部配置等 无代码生成、无XML 创建Spring Boot应用 Spring提供了Initializr快速创建SpringBoot应用程序，https://start.spring.io/。大多数IDEA也集成了该功能。 每一个SpringBoot应用都有一个启动类，启动类中提供了一个Main方法，这是SpringBoot应用启动的入口。 创建完项目，添加依赖之后，可以使用Maven命令构建项目，确保构建成功后再启动： maven clean install 项目构建成功之后，会在target目录下生成编译好的jar包，通过java -jar执行jar包： java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar Spring Boot应用的组成 pom.xml文件，用来配置Maven依赖 启动类，启动类的注解@SpringBootApplication 配置文件：application.properties或者application.yaml，后者是Spring官方推荐的。 static目录，用来存放静态文件 templates目录，用来存放模板文件，Spring Boot支持的模板引擎： FreeMarker Groovy Thymeleaf Mustache Spring Boot开发三板斧 加依赖 写注解 写配置 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-29 14:56:37 "},"frame5/SpringBootActuator.html":{"url":"frame5/SpringBootActuator.html","title":"Spring Boot Actuator","keywords":"","body":"Spring Boot Actuator Actuator 监控 Spring Boot 使用“习惯优于配置的理念”，采用包扫描和自动化配置的机制来加载依赖 Jar 中的 Spring bean，不需要任何 Xml 配置，就可以实现 Spring 的所有配置。虽然这样做能让我们的代码变得非常简洁，但是整个应用的实例创建和依赖关系等信息都被离散到了各个配置类的注解上，这使得我们分析整个应用中资源和实例的各种关系变得非常的困难。 Actuator 是 Spring Boot 提供的对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息，例如自动化配置信息、创建的 Spring beans 以及一些环境属性等。 为了保证 actuator 暴露的监控接口的安全性，需要添加安全控制的依赖spring-boot-start-security依赖，访问应用监控端点时，都需要输入验证信息。Security 依赖，可以选择不加，不进行安全管理，但不建议这么做。 1、添加依赖 org.springframework.boot spring-boot-starter-actuator 2、启动应用 依赖添加好之后，启动应用： 浏览器访问：http://localhost:8080/actuator，会看到Actuator暴露的端点： 健康状态检查 浏览器访问：http://localhost:8080/actuator/health查看健康状态，在配置文件中配置显示健康详情： # 显示健康详情 management: endpoint: health: show-details: always status取值： UP：正常 DOWN：遇到了问题，不正常 OUT_OF_SERVICE：资源未在使用，或者不该去使用 UNKNOW：不知道 设置应用描述 # 用来描述应用 info: app-name: spring-boot-demo author: liyan mail: xxx@qq.com info下key: value字段都是自定义的、 Actuator 提供了 13 个端点，具体如下表所示： HTTP 方法 路径 描述 GET /auditevents 显示应用暴露的审计事件 (比如认证进入、订单失败) GET /beans 描述应用程序上下文里全部的 Bean，以及它们的关系 GET /conditions 就是 1.0 的 /autoconfig ，提供一份自动配置生效的条件情况，记录哪些自动配置条件通过了，哪些没通过 GET /configprops 描述配置属性(包含默认值)如何注入Bean GET /env 获取全部环境属性 GET /env/{name} 根据名称获取特定的环境属性值 GET /flyway 提供一份 Flyway 数据库迁移信息 GET /liquidbase 显示Liquibase 数据库迁移的纤细信息 GET /health 报告应用程序的健康指标，这些值由 HealthIndicator 的实现类提供 GET /heapdump dump 一份应用的 JVM 堆信息 GET /httptrace 显示HTTP足迹，最近100个HTTP request/repsponse GET /info 获取应用程序的定制信息，这些信息由info打头的属性提供 GET /logfile 返回log file中的内容(如果 logging.file 或者 logging.path 被设置) GET /loggers 显示和修改配置的loggers GET /metrics 报告各种应用程序度量信息，比如内存用量和HTTP请求计数 GET /metrics/{name} 报告指定名称的应用程序度量值 GET /scheduledtasks 展示应用中的定时任务信息 GET /sessions 如果我们使用了 Spring Session 展示应用中的 HTTP sessions 信息 POST /shutdown 关闭应用程序，要求endpoints.shutdown.enabled设置为true GET /mappings 描述全部的 URI路径，以及它们和控制器(包含Actuator端点)的映射关系 GET /threaddump 获取线程活动的快照 默认只暴露/actuator/health和/actuator/info 打开所有端点： management: endpoint: health: show-details: always endpoints: web: exposure: include: '*' 或者选择打开指定端点： endpoints: web: exposure: include: ['beans','env','health'] Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame5/SpringBoot配置管理.html":{"url":"frame5/SpringBoot配置管理.html","title":"Spring Boot配置管理","keywords":"","body":"Spring Boot配置管理 支持的配置格式 Spring Boot除了application.properties之外， 还支持application.yaml或者applicaiton.yml yaml：Yet Anther Markup Language（还有另一种标记语言） ==> Json的子集 Spring Boot配置管理的17种姿势 Devtools global settings properties on your home directory (~/.spring-boot-devtools.properties when devtools is active). @TestPropertySource annotations on your tests. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application. Command line arguments. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). ServletConfig init parameters. ServletContext init parameters. JNDI attributes from java:comp/env. Java System properties (System.getProperties()). OS environment variables. A RandomValuePropertySource that has properties only in random.*. Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants). Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants). Application properties outside of your packaged jar (application.properties and YAML variants). Application properties packaged inside your jar (application.properties and YAML variants). @PropertySource annotations on your @Configuration classes. Default properties (specified by setting SpringApplication.setDefaultProperties). 配置管理常用方式 配置文件 --- yaml、properties 环境变量 management: endpoint: health: show-details: ${SOME_ENV} show-details读取环境变量，并在运行配置中设置环境变量： 可执行Jar： 使用mvn clean install重新构建项目，此时会报错，因为运行这个命令会执行单元测试，单元测试中的启动类会读取配置文件，配置文件中涉及环境变量。由于环境变量是配置在IDEA中，所以在命令行中读取不到。 这是可以把测试类干掉，或者跳过单元测试： mvn clean install -DskipTests 构建好Jar包之后，执行Jar包：(同样也需要声明环境变量) java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --SOME_ENV=always 外部配置文件 将可执行Jar包和yml配置文件放到同一个文件夹，并将always改为never,再执行Jar包： 说明Jar包运行时可以读取同一目录中配置文件，说明Jar包外面的配置文件比Jar内置的配置文件优先级更高。 命令行参数 在运行/调试配置中，设置程序参数： 如果是执行可执行Jar包： java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --server.port=8082 最佳实践 简单即是美，尽量规避优先级问题 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame5/SpringBoot多环境配置.html":{"url":"frame5/SpringBoot多环境配置.html","title":"Spring Boot多环境配置","keywords":"","body":"Profile 如何实现不同环境不同配置？ 在yaml文件中，通过连字符(\"---\")三个中划线来分割不同环境的配置： # 公共配置 # 监控 management: endpoint: health: show-details: ${SOME_ENV} endpoints: web: exposure: include: beans,env,health,configprops # 用来描述应用 info: app-name: spring-boot-demo author: liyan mail: xxx@qq.com # 激活 spring: profiles: active: prod --- # 开发环境 spring: profiles: dev server: port: 8081 --- # 生产环境 spring: profiles: prod server: port: 8082 tomcat: threads: max: 300 max-connections: 1000 使用properties配置文件配置多套开发环境，需要创建多个配置文件。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-29 15:02:21 "},"frame5/单体应用与微服务.html":{"url":"frame5/单体应用与微服务.html","title":"单体应用与微服务","keywords":"","body":"单体应用与微服务 单体应用 从单体架构说起 一个归档包（例如war包）包含所有功能的应用程序，我们通常称为单体应用。而架构单体应用的方法论，就是单体应用架构 单体架构的优点： 架构简单 开发、测试、部署方便 单体架构的缺点： 复杂性高 部署慢、频率低 扩展能力受限 阻碍技术创新 单体架构适合开发小型的，功能不那么复杂的应用。 微服务 微服务“定义” 一词最早来自于Martin Fowler的一篇微服务文章 微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制（通常用HTTP资源API）。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。 微服务特性（1） 每个微服务可独立运行在自己的进程里；（也就是说每个微服务都运行在自己的Tomcat中） 一系列独立运行的微服务共同构建起整个系统； 每个服务为独立的业务开发，一个微服务只关注某个特定的功能，例如订单管理、用户管理等； 微服务特性（2） 可使用不同的语言与存储技术（契合项目情况和团队实力）； 微服务之间通过清凉的通信机制进行通信，例如通过REST API进行调用； 全自动部署机制。 微服务全景架构图 微服务的优点： 单个服务更易于开发、维护 单个微服务启动较快 局部修改，容易部署 技术栈不受限（如果某个微服务需要更换技术栈，重构成本是有限的） 按需伸缩（如果某个服务是CPU密集的，只需将该微服务迁移到CPU性能更好的服务器即可） 微服务的缺点： 运维要求高 分布式固有的复杂性 重复劳动 微服务的使用场景： 大型、复杂的项目 有快速迭代的需求 访问压力大 不适用微服务的场景： 业务稳定 迭代周期长 微服务拆分-方法论： 领域驱动设计(Domain Driven Design)，简称：DDD 面向对象(by name. / by verb.) 微服务拆分-最佳实践： 职责划分 通用性划分 微服务拆分-合理的粒度： 良好地满足业务 幸福感 增量迭代 持续进化 微服务的拆分粒度是一个动态的、持续且变化的，随着项目的更新迭代，微服务的拆分粒度应该合理地改变。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-30 00:08:03 "},"frame5/Lombok.html":{"url":"frame5/Lombok.html","title":"Lombok","keywords":"","body":"Lombok 使用Lombok需要安装插件，并引入依赖，这里不做介绍。 主要介绍几个注解的使用，更多注解使用 package com.itmuch.usercenter; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import lombok.extern.slf4j.Slf4j; @Slf4j public class LombokTest { public static void main(String[] args) { UserRegisterDTO dto = UserRegisterDTO.builder() .email(\"xxx\") .password(\"123\") .confirmPassword(\"123\") .build(); log.info(\"构造出来的UserRegisterDTO={}\", dto); } } @Data @NoArgsConstructor @AllArgsConstructor @Builder class UserRegisterDTO { private String email; private String password; private String confirmPassword; } @Slf4j 自动生成private static final org.slf4j.Logger log对象，打印日志 @Builder 构造者模式，链式创建对象 @RequiredArgsConstructor 为final修饰和@NonNull修饰的成员属性生成构造器 @RequiredArgsConstructor public class NacosSameClusterWeightedRule extends AbstractLoadBalancerRule { // 通过带参构造器实现自动注入，无需@Autowired private final NacosDiscoveryProperties nacosDiscoveryProperties; Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-30 00:12:50 "},"frame5/解决IDEA的红色警告.html":{"url":"frame5/解决IDEA的红色警告.html","title":"解决IDEA的红色警告","keywords":"","body":"Intellij IDEA中Mybatis Mapper自动注入警告的6种解决方案 相信使用Mybaits的小伙伴们一定会经常编写类似如下的代码： 可以看到 userMapper 下有个红色警告。虽然代码本身并没有问题，能正常运行，但有个警告总归有点恶心。本文分析原因，并列出解决该警告的几种方案。 原因 众所周知，IDEA是非常智能的，它可以理解Spring的上下文。然而 UserMapper 这个接口是Mybatis的，IDEA理解不了。 而 @Autowired 注解，默认情况下要求依赖对象（也就是 userMapper ）必须存在。而IDEA认为这个对象的实例/代理是个null，所以就友好地给个提示。 解决方案 方法1：为 @Autowired 注解设置required = false 使用 @Autowired 注解时，若希望允许null值，可设置required = false，像这样： @Autowired(required = false) private UserMapper userMapper; 这样就不会有警告了。原因很好理解：IDEA认为userMapper是个null，给了警告；加上required = false后，使用 @Autowired 注解不再去校验userMapper是否存在了。也就不会有警告了。 总结：这种方式有点蛋疼。一个庞大的既有项目，可能到处都在引用Mapper，总不能到处都补上 required = false 吧……而且对于新手/新员工，很难一眼看懂加required = false属性只是为了解决IDEA的警告。 方法2：用 @Resource 替换 @Autowired 像这样： @Resource private UserMapper userMapper; 这样也不会再有讨厌的警告。如果你对原因感兴趣，不妨了解一下《@Autowired 与@Resource的区别》 总结：这种方式挺赞，但如果一个项目已经大量使用@Autowired，然后为了个警告到处改成@Resource，也有点蛋疼。 方法3：在Mapper接口上加上@Repository注解 像这样： @Repository public interface UserMapper extends Mapper { } 这样也能让你的 @Autowired private UserMapper userMapper; 不再报错。 当然，如果你用@Component替换@Repository也是可以的。原理大致：IDEA不是认为 userMapper 是个null嘛…加个@Repository注解骗一下IDEA就OK了…… 总结：这种方式比较赞，改动小，也简单，我比较喜欢。 方法4：用Lombok 像这样： @Service @RequiredArgsConstructor(onConstructor = @__(@Autowired)) public class TestService { private final UserMapper userMapper; ... } Lombok生成的代码是这样的： @Service public class TestService { private final UserMapper userMapper; @Autowired public TestService(final UserMapper userMapper) { this.userMapper = userMapper; } ... } 但如果自己手写成Lombok生成的代码，IDEA依然会给你报警告 。我猜，应该是IDEA的Lombok插件把IDEA搞懵逼了…所以不提示了… 总结 ：这是我目前最喜欢的方式。原因有2： Spring官方并不建议直接在类的field上使用@Autowired注解，原因详见：《Why field injection is evil》 ，用本方法可将field注入编程构造方法注入，Spring是比较推荐的。 体现了Lombok的优势，简化了你的代码。而且你也不用在每个field上都加上@Autowired注解了。 不过这种方式也有缺点：那就是如果你类之间的依赖关系比较复杂，特别是存在循环依赖(A引用B，B引用A，或者间接的循环引用)时，应用将会启动不起来……这其实是构造方法注入方式的缺点。 方法5：把IDEA的警告关闭掉 个人没试过，也没有动力去试。没有提示的IDEA是没有灵魂的，我从来不去修改IDEA的任何警告设置。 方法6：安装mybatis plugin 安装mybatis plugin即可解决该问题。 总结 以上是解决问题的6种方法。问题本身其实比较简单，但其实隐藏的知识点其实挺多的，例如： @Autowired和@Resource有什么区别 为什么Spring不建议使用field方式注入 @Repository、@Componnt、@Controller、@Service有什么区别 总之，硬货有时候就隐藏在很low的问题之下，哈哈哈。 参考文档 剔除Intellij中Mybatis的Mapper自动注入警告 idea mybatis 注入 mapper 提示错误 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"frame5/Spring-Cloud-Alibaba.html":{"url":"frame5/Spring-Cloud-Alibaba.html","title":"Spring Cloud Alibaba","keywords":"","body":"Spring Cloud Alibaba 什么是Spring Cloud 快速构建分布式系统的工具集 功能 翻译 选择 Distributed/versioneddiscovery 分布式/版本化的配置管理 Spring Cloud Config、Consul、Nacos、Zookeeper Service registration and discovery 服务注册与发现 Eureka、Consul、Nacos、Zookeeper Routing 路由 Zuul、Spring Cloud Gateway Service-to-service calls 端到端的调用 RestTeamplateFeign Load balancing 负载均衡 Ribbon Circuit Breakers 断路由 Hystrix、Sentinel、Resilience4j Global locks 全局锁 Spring Cloud Cluster（以迁移到Spring Integration） Leadership election and cluster state 选举与集群状态管理 Spring Cloud Cluster（已迁移到Spring Integration） Distributed messaging 分布式消息 Spring Cloud Stream + kafka/RabbitMQ/RocketMQ Spring Cloud常用子项目 什么是Spring Cloud Alibaba Spring Cloud Alibaba是Spring Cloud的子项目 致力于提供微服务开发的一站式解决方案。 包含微服务开发的必备组件 基于Spring Cloud，符合Spring Cloud标准 阿里的微服务解决方案 功能 产品 备注 服务限流降级 Sentinel 开源组件 服务注册与发现 NacosANS 开源组件商业组件 分布式配置管理 NacosACM 开源组件商业组件 消息驱动能力 Spring Cloud StreamRocketMQ 开源组件 分布式事务 Seata 开源组件，不能用于生产(目前0.6.1)，1.0.0之后才可用于生产 阿里云对象存储 OSS 商业组件 分布式任务调度 SchedulerX 商业组件 阿里云短信服务 SMS 商业组件 版本与兼容性 Spring Cloud版本问题 由于Spring Cloud有众多子项目，每个子项目又有自己的版本控制，所有Spring Cloud搞了一个发布列车Release Trains，每一代的Spring Cloud版本只有名称，而没有具体的版本号。 Spring Cloud每一代版本使用伦敦地铁站命名，按字母顺序往后排。 历代版本： Angel Brixton Camden Dalston Edgware Finchley Greenwich Hoxton 每一代版本又有Service Release（SR）版本，主要是修复各种bug。Hoxton SR7就是Hoxton的第七个bug修复版本 每一代版本的顺序是这样子的：Hoxton RELEASE -> Hoxton SR1 -> Hoxton SR2 Spring Cloud生命周期 Spring Cloud版本发布规划https://github.com/spring-cloud/spring-cloud-release/milestones Spring Cloud版本发布记录https://github.com/spring-cloud/spring-cloud-release/releases Spring Cloud版本终止声明https://spring.io/projects/spring-cloud#overview Spring Boot、Spring Cloud、Spring Cloud Alibaba兼容性关系 https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明 Spring Cloud Version Spring Cloud Alibaba Version Spring Boot Version Spring Cloud Hoxton.SR3 2.2.1.RELEASE 2.2.5.RELEASE Spring Cloud Hoxton.RELEASE 2.2.0.RELEASE 2.2.X.RELEASE Spring Cloud Greenwich 2.1.2.RELEASE 2.1.X.RELEASE Spring Cloud Finchley 2.0.2.RELEASE 2.0.X.RELEASE Spring Cloud Edgware 1.5.1.RELEASE(停止维护，建议升级) 1.5.X.RELEASE 生产环境怎么选择版本 坚决不用非稳定版本/end-of-life版本 尽量用最新一代 XXX.RELEASE版本缓一缓 SR2之后一般可以大规模使用 为项目整合Spring Cloud Alibaba pom.xml中添加依赖： org.springframework.cloud spring-cloud-dependencies Hoxton.SR7 pom import com.alibaba.cloud spring-cloud-alibaba-dependencies 2.2.1.RELEASE pom import Spring Cloud Alibaba是基于Spring Cloud的，根据Spring Cloud版本不同，对应Spring Cloud Alibaba的版本也不同，具体的依赖关系，查看https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-30 13:12:16 "},"frame5/Nacos服务注册与发现.html":{"url":"frame5/Nacos服务注册与发现.html","title":"Nacos服务注册与发现","keywords":"","body":"Nacos 服务提供者与消费者 服务提供者：服务的被调用方（即：为其他微服务提供接口的微服务） 服务消费者：服务的调用方（即：调用其他微服务接口的微服务） 服务提供者将微服务注册到服务注册中心，服务消费者通过服务注册中心获取到服务接口并调用，如果服务提供者的信息发生改变，改变后的信息也会更新到注册中心，服务消费者依然可以正常调用该服务。 大话剖析服务发现原理 last-heartbeat心跳，微服务会定期向服务发现组件发送心跳，如果长时间没有发送心跳，则判定该服务当前状态不可用。 Nacos Nacos是Alibaba提供的服务注册与发现解决方案，官方文档：https://nacos.io/zh-cn/index.html Nacos是既是服务发现组件，也是微服务的配置中心，可以管理微服务的所有配置。 引进Nacos组件后： 下载并安装Nacos：https://github.com/alibaba/nacos/releases 在官方仓库下载nacos程序，根据官方文档快速开始安装运行Nacos。 注册应用到Nacos 添加依赖： com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 扩展：Spring Cloud Starter命名规律： com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 添加注解： 之前的版本需要在启动类中添加@EnableDiscoveryClient注解，现在可以不添加。 写配置文件： cloud: nacos: # 服务发现 discovery: server-addr: localhost:8848 application: # 服务名称，名称尽量使用'-'，不要用下划线或其他特殊字符 name: user-center server-addr是Nacos的服务器地址 application.name是服务名称 这些配置好之后启动应用，访问Nacos管理页面localhost:8848/nacos，在左侧服务列表中即可看到刚刚注册的服务。 Nacos服务发现的领域模型及元数据 首先要记住，无法跨Namespace访问，即服务提供者和服务消费者处于不同的Namespace，则两者之间无法访问。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-29 22:53:35 "},"frame5/Ribbon负载均衡.html":{"url":"frame5/Ribbon负载均衡.html","title":"Ribbon 负载均衡","keywords":"","body":"Ribbon 负载均衡 负载均衡的两种实现： 服务器端负载均衡 客户端负载均衡 public ShareDTO findById(Integer id) { Share share = this.shareMapper.selectByPrimaryKey(id); // 通过discoveryClient获取到服务提供者的所有实例 List instances = discoveryClient.getInstances(\"user-center\"); // 获得所有服务提供者实例的接口地址 List targetURLs = instances.stream() .map(instance -> instance.getUri().toString() + \"/users/{id}\") .collect(toList()); // 通过targetURLs大小获得一个随机索引，通过随机索引随机访问服务提供者实例，实现负载均衡 int index = ThreadLocalRandom.current().nextInt(targetURLs.size()); UserDto userDto = this.restTemplate.getForObject(targetURLs.get(index), UserDto.class, share.getUserId()); ShareDTO shareDTO = new ShareDTO(); BeanUtils.copyProperties(share, shareDTO); shareDTO.setWxNickname(userDto.getWxNickname()); return shareDTO; } } 通过在服务消费者获取到所有服务提供者实例，并随机调用（即客户端负载均衡）。 Ribbon实现负载均衡 Ribbon是Netflix开源的客户端侧负载均衡器 添加依赖： spring-cloud-starter-alibaba-nacos-discovery组件已经包含了Ribbon，所以无需添加依赖 写注解： RestTemplate整合Ribbon @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } 修改Service方法： public ShareDTO findById(Integer id) { Share share = this.shareMapper.selectByPrimaryKey(id); // restTemplate已经整合了Ribbon，Ribbon会根据要请求的服务名称自动从服务发现中心获取所有实例，再根据Ribbon内置的负载均衡算法进行请求 UserDto userDto = this.restTemplate.getForObject(\"http://user-center/users/{id}\", UserDto.class, share.getUserId()); ShareDTO shareDTO = new ShareDTO(); BeanUtils.copyProperties(share, shareDTO); shareDTO.setWxNickname(userDto.getWxNickname()); return shareDTO; } Ribbon的组成 接口 作用 默认值 IClientConfig 读取配置 DefaultClientConfigImpl IRule 负载均衡规则，选择实例 ZoneAvoidanceRule IPing 筛选掉ping不同的实例 Dummyping ServerList 交给Ribbon的实例列表 Ribbon：ConfigurationBasedServerListSpring Cloud Alibaba:NacosServerList ServerListFilter 过滤掉不符合条件的实例 ZonePreferenceServerListFilter ILoadBalancer Ribbon的入口 ZoneAwareLoadBalancer ServerListUpdater 更新交给Ribbon的List的策略 PollingServerListUpdater Ribbon内置的负载均衡规则 规则名称 特点 AvailabilityFilteringRule 过滤掉一直连接失败的被标记为circuit tripped的后端Server，并过滤掉哪些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就是检查status里记录的各个Server的运行状态 BestAvailableRule 选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过 RandomRule 随机选择一个Server ResponseTimeWeightedRule 已废弃，作用同WeightedResponseTimeRule RetryRule 对选择的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server RoundRobinRule 轮询选择，轮询index，选择index对应位置的Server WeightedResponseTimeRule 根据响应时间加权，适应时间越长，权重约小，被选中的可能性越低 ZoneAvoidanceRule 复合判断Server所Zone的性能和Server的可用性选择Server，在没有Zone的环境下，类似于轮询(RoundRobinRule) Ribbon默认使用的负载均衡策略是轮询(RoundRobinRule)。 自定义负载均衡策略的两种方式： Java Config 配置文件配置 第一种：Java Config 在启动类所在包的并列级别创建一个包->创建配置类，目录层级只要配置类不被Spring Boot启动类扫描到即可，这里涉及Spring的父子上下文问题： @Configuration public class RibbonConfiguration { @Bean public IRule ribbonRule() { // 返回不同的策略实现类即可 return new RandomRule(); } // 定义其他配置，如IPing @Bean public IPing ping() { return new PingUrl(); } 在启动类所在目录下创建包->创建配置类： @Configuration // name:要调用的服务名称 configuration:上面定义的配置类 @RibbonClient(name = \"user-center\",configuration = RibbonConfiguration.class) public class UserCenterRibbonConfiguration { } 重新应用后，会启用新的负载均衡规则。 第二种：配置文件配置策略 user-center: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 为要调用的user-center服务设置负载均衡策略，配置文件配置无需再写上面的两个Java配置类。 代码配置Vs属性配置 配置方法优点缺点 代码配置基于代码，更加灵活有小坑（Spring父子上下文），线上修改需要重新打包、发布 属性配置易上手，配置更加直观，线上修改无需重新打包、发布，优先级更高极端场景下没有代码配置方式灵活 细粒度配置最佳实践总结： 尽量使用属性配置，属性方式实现不了的情况下再考虑使用代码配置 在同一个微服务内尽量保持单一性，比如统一使用属性配置，不要两种方式混用，增加定位代码的复杂性 配置属性方式 .ribbon如下属性： NFLoadBalancerClassName:ILoadBalancer实现类 NFLoadBalancerRuleClassName:IRule实现类 NFLoadBalancerPingClassName:IPing实现类 NIWSServerListClassName:ServerList实现类 NIWSServerListClassName:ServerListFilter实现类 自定义负载均衡策略 基于权重的负载均衡策略： // 自定义类并继承AbstractLoadBalancerRule public class NacosWeightedRule extends AbstractLoadBalancerRule { @Autowired private NacosDiscoveryProperties nacosDiscoveryProperties; // AbstractLoadBalancerRule类中需实现两个抽象方法initWithNiwsConfig和choose // 读取配置文件，并初始化NacosWeightedRule @Override public void initWithNiwsConfig(IClientConfig iClientConfig) { } @Override public Server choose(Object o) { try { // 负载均衡器实例对象 BaseLoadBalancer loadBalancer = (BaseLoadBalancer) this.getLoadBalancer(); // 想要请求的微服务的名称 String name = loadBalancer.getName(); // 拿到服务发现的相关API NamingService namingService = nacosDiscoveryProperties.namingServiceInstance(); // 使用Nacos提供的基于权重的负载均衡算法，nacos client自动通过基于权重的负载均衡算法，给我们选择一个实例 Instance instance = namingService.selectOneHealthyInstance(name); return new NacosServer(instance); } catch (NacosException e) { return null; } } } 自定义负载均衡策略之后，需要配置该策略，以使配置生效。 同一集群下的负载均衡策略： public class NacosSameClusterWeightedRule extends AbstractLoadBalancerRule { @Autowired private NacosDiscoveryProperties nacosDiscoveryProperties; @Override public void initWithNiwsConfig(IClientConfig iClientConfig) { } @Override public Server choose(Object o) { try { // 获取配置文件中配置的集群名称 String clusterName = nacosDiscoveryProperties.getClusterName(); // 负载均衡器实例对象 BaseLoadBalancer loadBalancer = (BaseLoadBalancer) this.getLoadBalancer(); // 想要请求的微服务名称 String name = loadBalancer.getName(); // 拿到服务发现的相关API NamingService namingService = nacosDiscoveryProperties.namingServiceInstance(); // 1.找到指定服务的所有实例 true表示只获取健康实例 List instances = namingService.selectInstances(name, true); // 2.根据配置文件中的集群名称过滤出相同集群下的所有实例 List sameClusterInstances = instances.stream() .filter(instance -> Objects.equals(instance.getClusterName(), clusterName)) .collect(Collectors.toList()); // 将要调用的实例列表放到该集合中 List instanceToBeChosen = new ArrayList<>(); // 3.如果该集群下没有实例，则调用其它集群下的实例 if (CollectionUtils.isEmpty(sameClusterInstances)) { instanceToBeChosen = instances; } else { // 同一集群下有可用实例，则调用该集群下的实例 instanceToBeChosen = sameClusterInstances; } // 4.基于权重的负载均衡算法，返回一个实例 Instance instance = ExtendBalancer.getHostByRandomWeight1(instanceToBeChosen); return new NacosServer(instance); } catch (NacosException e) { return null; } } } // 调用Nacos的负载均衡方法：自定义类继承Balancer调用getHostByRandomWeight返回一个服务实例 class ExtendBalancer extends Balancer { public static Instance getHostByRandomWeight1(List hosts) { return getHostByRandomWeight(hosts); } } Nacos已经有了基于权重的负载均衡算法，为什么还要整合Ribbon呢？主要是为了满足符合Spring Cloud的标准。 Spring Cloud有一个子项目叫spring cloud commons-->定义了Spring Cloud的标准 它其中又有一个子项目叫spring cloud loadbalancer-->定义了各种负载均衡的规则，没有权重这一概念，所以Spring Cloud Alibaba整合Ribbon，因为Ribbon符合Spring Cloud的负载均衡标准。 饥饿加载 Ribbon默认是懒加载，即请求服务的时候，采去加载Ribbon，所以第一次请求会很慢。开启饥饿加载后无论是否请求都会加载Ribbon。 # ribbon饥饿加载 ribbon: eager-load: enabled: true clients: user-center 集群、元数据、命名空间待更新~ Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-29 23:54:35 "},"frame5/Feign.html":{"url":"frame5/Feign.html","title":"Feign","keywords":"","body":"Feign Feign是Netflix开源的声明式HTTP客户端 三板斧的第一步，添加Feign依赖： org.springframework.cloud spring-cloud-starter-openfeign Feign的组成 接口 作用 默认值 Feign.Builder Feign的入口 Feign.Builder Client Feign底层用什么去请求 和Ribbon配合时：LoadBalancerFeignClient不和Ribbon配合时：feign.Client.Default Contract 契约，注解支持 SpringMvcContract Encoder 编码器，用于将对象转换成HTTP请求消息体 SpringEncoder Decoder 解码器，将响应消息体转换成对象 ResponseEntityDecoder Logger 日志管理器 Slf4jLogger RequestInterceptor 用于为每个请求添加通用逻辑 无 注意： Feign不和Ribbon搭配使用时，底层使用的是`Client.Default`去请求，Default默认用的`HttpURLConnection`去请求，`HttpURLConnection`是没有连接池的。 Feign在和Ribbon使用时，底层使用`LoadBalancerFeignClient`请求，它应用了代理模式，在默认情况下，也是使用的Client.Default去请求的。 ## 自定义Feign日志级别 级别 打印内容 NONE（默认值） 不记录任何日志 BASIC 仅记录请求方法、URL、响应状态代码以及执行时间 HEADERS 几率BASIC级别的基础上，几率请求和响应的header FULL 记录请求和响应的header、body和元数据 细粒度配置自定义 Java Config方式： 在@FeignClient注解中添加configuration属性，指向Feign的自定义配置类。 @FeignClient(name = \"user-center\",configuration = UserCenterFeignConfiguration.class) public interface UserCenterFeignClient { @GetMapping(\"/users/{id}\") UserDto findById(@PathVariable(\"id\") Integer id); } 自定义配置类Feign配置类，定义日志界别。 Feign配置类不要加@Configutation注解，或者把这个类移到启动类扫描不到的位置。否则该配置类会被所有的FeignClient共享。 public class UserCenterFeignConfiguration { @Bean public Logger.Level level(){ return Logger.Level.FULL; } } 在配置文件中配置Feign接口的全路径，日志级别必须是debug logging: level: com.example.contentcenter.feignclient.UserCenterFeignClient: debug 配置文件方式： 使用配置文件方式配置Feign的日志级别，不需要在@FeignClient注解添加configuration属性。只需要在配置文件中直接定义Feign的日志级别即可： feign: client: config: # 要访问的服务名称 user-center: # Feign的日志级别 loggerLevel: full 全局配置 Java Config方法： 方式一：让父子上下文ComponentScan重叠（强烈不建议使用） 方式二：【唯一正确的途径】： 启动类中@EnableFeignClients(defaultConfiguration=xxx.class)注解添加defaultConfiguration属性，该属性定义全局配置类。 在全局配置类中定义日志级别： public class GlobalFeignConfiguration { @Bean public Logger.Level level(){ return Logger.Level.FULL; } } 配置文件方法： feign: client: config: # 服务名称改为default，则启用全局配置 default: # Feign的日志级别 loggerLevel: full 支持的配置项 支持的配置项-代码方式 配置项 作用 Logger.Level 指定日志级别 Retryer 指定重试策略 ErrorDecoder 指定错误解码器 Request.Options 超时时间 Collection 拦截器 SetterFactory 用于设置Hystrix的配置属性，Feign整合Hystrix才会用 支持的配置项-属性方式 feign: client: config: : connectTimeout: 5000 # 连接超时时间 readTimeout: 5000 # 读取超时时间 loggerLevel: full # 日志级别 errorDecoder: com.example.SimpleErrorDecoder # 错误解码器 retryer: com.example.SimpleRetryer # 重试策略 requestInterceptors: - com.example.FoorRequestInterceptor # 拦截器 # 是否对404错误码解码 # 处理逻辑相减feign.SynchronousMethodHandler#executeAndDecode decode404: false encoder: com.example.SimpleEncoder # 编码器 decoder: com.example.SimpleDecoder # 解码器 contract: com.example.SimpleContract # 契约 Ribbon配置 vs Feign配置： Ribbon代码方式： 局部：@RibbonClient(configuration=X.class)X必须加@Configuration注解，且必须放在父上下文无法扫描到的包中 全局@RibbonClients(defaultConfiguration) Ribbon属性方式： 局部：.ribbon.NFLoadBalancerClassName, ... 全局：- Feign代码方式： 局部：@FeignClient(configuration=Y.class)Y的@Configuration可选，如果有，必须放在父上下文无法扫描到的包 全局：@EnableFeignClients(defaultConfiguration) Feign属性方式： 局部：feign.client.config..loggerLevel, ... 全局：feign.client.config.default.loggerLevel, ... Feign代码方式 vs 属性方式： 配置方式 优点 缺点 代码配置 基于代码，更加灵活 如果Feign的配置类加了@Configuration注解，需要注意父子上下文线上修改得重新打包、发布 属性配置 易上手配置更加直观线上修改无需重新打包、发布优先级更高：全局代码>全局属性>细粒度代码>细粒度属性 极端场景下没有代码配置方式灵活 最佳实践： 尽量使用属性配置，属性方式实现不了的情况下再考虑用代码配置 在同一个微服务内尽量保持单一性，比如统一使用属性配置，不用两种方式混用，增加定位代码的复杂性 Feign脱离Ribbon的使用方式 Feign脱离Ribbon使用，可以使用Feign访问没有在Nacos注册的服务，例如访问百度，代码示例： @FeignClient(name = \"baidu\", url = \"https://www.baidu.com/\") public interface TestBaiduFeignClient { @GetMapping(\"\") String index(); } @FeignClient(name = \"baidu\", url = \"https://www.baidu.com/\")中name属性值可以任意，但是是必须定义的，url属性指向要请求的地址。 测试类： @Autowired private TestBaiduFeignClient testBaiduFeignClient; @GetMapping(\"baidu\") public String baiduIndex(){ return this.testBaiduFeignClient.index(); } RestTemplate vs Feign 角度 RestTemplate Feign 可读性、可维护性 一般 极佳 开发体验 欠佳 极佳 性能 很好 中等（RestTemplate的50%左右） 灵活性 极佳 中等（内置功能可满足绝大多数需求） 原则：尽量用Feign，杜绝使用RestTemplate 事无绝对，合理选择 Feign的性能优化 配置连接池【提升15%左右】，Feign默认使用URLConnection进行请求，URLConnection是没有连接池的。 合适的日志级别，不建议用full，打印日志比较多，消耗性能。 配置带有连接池的http客户端： apache的httpclient：添加依赖 io.github.openfeign feign-httpclient 写配置： feign: httpclient: # 让feign使用apache httpclient做请求；而不是默认的URLConnection enabled: true # feign的最大连接数 max-connections: 200 # feign单个路径的最大连接数 max-connections-per-route: 50 或者，使用okhttp：添加依赖 io.github.openfeign feign-okhttp 10.1.0 写配置： feign: okhttp: # 让feign使用apache httpclient做请求；而不是默认的URLConnection enabled: true # feign的最大连接数 max-connections: 200 # feign单个路径的最大连接数 max-connections-per-route: 50 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-07 22:08:31 "},"midd1/Junit单元测试.html":{"url":"midd1/Junit单元测试.html","title":"Junit单元测试","keywords":"","body":"23. Junit单元测试 使用main()方法测试的缺点： 只有一个main()方法,不能把测试代码分离 没有打印出测试结果和期望结果 单元测试的优点： 确保单个方法运行正常 如果修改了方法代码，只需确保其对应的单元测试通过 测试代码本身可以作为示例代码 可以自动化运行所有的测试并获得报告 测试分类： 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值 白盒测试：需要写代码，关注程序的具体执行流程 Junit使用：白盒测试 步骤： 定义一个测试类（测试用例） 建议： 1. 测试类名：被测试的类名Test（如：DemoTest） 2. 包名：XXX.XXX.XX.test 定义测试方法，可以独立运行 建议： 方法名：test测试的方法名（如：testAdd()） 返回值：void 参数列表：空参 给test方法添加注解@test 导入junit依赖 判定结果： 红色：失败 绿色：成功 一般我们会使用断言操作来处理结果 Assert.assertEquals(3,result); 3为期望值，result为真实值 @Before 每次测试方法时都会先调用before方法，可以把初始化的一些属性放到before方法里面 @After 测试方法执行结束，会执行after方法，可以用来释放资源 @Test 测试方法，里面可以通过Assert断言，通过期望值和实际的值，判断执行结果是否是期望的 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/Maven.html":{"url":"midd1/Maven.html","title":"Maven","keywords":"","body":"Maven 安装maven 官方下载地址：http://maven.apache.org/ 将压缩包解压到一个固定的位置 放到一个固定的位置，maven的路径不能轻易改动，这个涉及到下一步要配置的环境变量 添加环境变量 桌面右键“此电脑” -> 属性 -> 高级系统设置 -> 环境变量 ->系统变量： 编辑Path： 点击确定，把所有窗口关掉，关闭窗口都要点击确定来关闭，以免发生不测 打开CMD窗口，输入命令： mvn -v 显示Maven版本等信息，说明Maven安装成功，如果提示非内部或外部命令，则检查一下环境变量是否配置正确。 修改maven的配置文件：（路径：maven/conf/setting.xml） 使用文本编辑工具打开setting.xml，没有文本编辑工具的推荐下载使用sublime，它是一个轻量级的文本编辑工具，比较好用 这里主要设置两个地方： repo仓库的存储路径 这个本地仓库的作用是，我们在maven项目的pom.xml中添加依赖坐标之后，maven会先到这个本地仓库去找有没有这个依赖资源。如果有，就直接从本地仓库把依赖导入到项目中；如果没有就会到maven的中央仓库中下载，把依赖下载到本地仓库，然后再自动导入到项目中 修改下载源 步骤： 在maven根目录新建一个文件夹repo（文件夹名称和路径自定义，这个文件夹是用来存放maven下载的各种依赖的仓库） 在setting.xml中设置本地仓库的路径 添加阿里镜像仓库 在mirrors标签中添加 alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 以上Maven的安装和配置就结束了。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/Eclipse配置Maven.html":{"url":"midd1/Eclipse配置Maven.html","title":"Eclipse配置Maven","keywords":"","body":"Eclipse配置Maven 进入Eclipse -> Window -> Preferences： 添加maven路径： 选中刚刚添加进来的maven: 设置User Setting： 在Global Setting中添加maven的配置文件，添加进来之后，会看到Local Repository自动更新成了在setting.xml中配置的repo的路径。 User Setting也添加一下maven的配置文件，最后看到的设置页面就是这个样子： 到这里，Eclipse的maven就配置完成了，下面我们来创建一个普通的maven项目 使用Eclipse创建一个普通的Maven项目 打开Eclipse -> File -> New -> Maven Project： 下一步： 点击Finish，项目创建完成： 测试一下Jdbc： 总结： 安装maven前要安装好jdk环境 maven不要安装在系统目录下或者要求管理员权限访问的目录（会出现maven没有权限访问的问题） 本地仓库的路径设置不是必要的，这个因人而异 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/IDEA配置Maven.html":{"url":"midd1/IDEA配置Maven.html","title":"IDEA配置Maven","keywords":"","body":"IDEA配置Maven 小贴士：我用的IDEA安装了中文汉化插件（官方的），在首选项中 ->Plugin中搜索\"chinese\"进行安装： IDEA配置Maven： 在欢迎界面，右下角 配置 -> 首选项 （这里面配置的，是对新项目配置的都有效，通俗的说，就是全局的） 构建、执行、部署 -> 构建工具 -> Maven： 确定之后，IDEA的Maven已经配置结束了，每次我们在创建新项目的时候，都会引用我们配置好的Maven来构建新项目 IDEA构建普通Maven项目（不使用骨架）： 或者，在IDEA内通过 文件 -> 新建 ->项目创建项目。 创建新项目：选择Maven： 下一步： 然后，点击完成。 一个Maven项目构建完毕： 这只是一个普通的Maven项目，如果要添加Web支持： 项目名右键 -> 添加框架支持：勾选Web Application： 此时，项目已经变成了Web项目了： 注意观察web目录文件夹图标有一个小蓝点，这说明目录有效。如果因为某些原因，web目录图标没有小蓝点，那可能是项目构建的过程中出现了问题。 通过骨架直接构建Web项目： 只需要在新建项目这一步，选中通过原型创建，选择下面的红框中的原型即可： Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/常用坐标.html":{"url":"midd1/常用坐标.html","title":"Maven常用坐标","keywords":"","body":"Maven常用坐标 junit junit 4.11 test mysql mysql-connector-java 8.0.20 com.alibaba druid 1.1.22 org.springframework spring-jdbc 5.2.6.RELEASE javax.servlet javax.servlet-api 4.0.1 provided javax.servlet.jsp javax.servlet.jsp-api 2.3.3 provided javax.servlet jstl 1.2 org.mybatis mybatis 3.5.5 org.mybatis mybatis-spring 2.0.5 org.springframework spring-webmvc 5.2.6.RELEASE log4j log4j 1.2.17 commons-dbutils commons-dbutils 1.7 com.alibaba fastjson 1.2.71 commons-beanutils commons-beanutils 1.9.4 cn.hutool hutool-all 5.3.7 org.projectlombok lombok 1.18.12 provided src/main/resources **/*.properties **/*.xml true src/main/java **/*.properties **/*.xml true Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/Redis.html":{"url":"midd1/Redis.html","title":"Redis","keywords":"","body":"Redis Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/Nginx.html":{"url":"midd1/Nginx.html","title":"Nginx","keywords":"","body":"Nginx Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/WebSocket.html":{"url":"midd1/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/QRCode.html":{"url":"midd1/QRCode.html","title":"QRCode","keywords":"","body":"QRCode Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/quartz.html":{"url":"midd1/quartz.html","title":"quartz","keywords":"","body":"quartz Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"midd1/Lombok.html":{"url":"midd1/Lombok.html","title":"Lombok","keywords":"","body":"1.16 Lombok Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. 使用方法： IDEA中安装Lombok插件 引入Maven依赖 org.projectlombok lombok 1.18.12 provided 在实体类中添加注解 package com.neu.pojo; import lombok.*; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } @Data ：生成无参构造器、getter/setter方法、toString()、equals()、hashCode()方法 @AllArgsConstructor ：生成带所有参数的构造器 @NoArgsConstructor：生成无参构造器 Lombok的注解： @Getter and @Setter @FieldNameConstants @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog @Data @Builder @SuperBuilder @Singular @Delegate @Value @Accessors @Wither @With @SneakyThrows @val @var experimental @var @UtilityClass Lombok config system Code inspections Refactoring actions (lombok and delombok) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"linux1/Linux入门概述.html":{"url":"linux1/Linux入门概述.html","title":"Linux入门概述","keywords":"","body":"Linux入门概述 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/Git入门.html":{"url":"git/Git入门.html","title":"Git入门","keywords":"","body":"Git入门 什么是版本控制？ 版本控制(Revision control)是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和机载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪几率整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 简单地说就是用于管理多人协同开发项目的技术。 版本控制分类 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或者记录补丁文件，适合个人用。如RCS 集中版本控制 所有的版本数据保存在中心服务器上，协同开发者从服务器上同步更新或上传自己的修改。如SVN 但是，如果中央服务器挂掉了，那么所有开发者只能干瞪眼了。 分布式版本控制 在每个使用者电脑上就有一个完整的数据仓库，没有网络依然可以使用。如Git Git是目前世界上最先进的分布式版本控制系统 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/安装Git及环境配置.html":{"url":"git/安装Git及环境配置.html","title":"安装Git及环境配置","keywords":"","body":"安装Git及环境配置 官方网站：https://git-scm.com/，下载对应系统的版本 安装根据提示一直下一步即可。 Windows平台Git安装好后，在开始菜单下会有三个Git程序： Git Bash：Unix、Linux风格的命令行 Git CMD：Windows风格的命令行 Git GUI：图形界面的Git 在鼠标右键菜单中也会有Git选项。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/常用的Linux命令.html":{"url":"git/常用的Linux命令.html","title":"常用的Linux命令","keywords":"","body":"常用的Linux命令 # 改变目录 cd xxx # 回到上一级目录 cd .. # 显示当前所在目录 pwd # 清屏 clear # 列出当前目录下所有文件 ls # 新建文件 touch xxx.txt # 删除文件 rm xxx.txt # 新建目录 mkdir xxx # 删除目录 rm -r xxx # 移动文件（把xxx.txt移动到text目录下） mv xxx.txt text # 重新初始化终端/屏幕 reset # 查看命令历史 history # 帮助 help # 退出 exit # 注释 # Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/Git的必要配置.html":{"url":"git/Git的必要配置.html","title":"Git的必要配置","keywords":"","body":"Git的必要配置 Git配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 查看配置： git config -l git config --list 查看全局配置： git config --global --list 设置名字和邮箱 git config --global user.name = \"xxxx\" git config --global user.email \"xxxx@163.com\" Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/Git的工作原理.html":{"url":"git/Git的工作原理.html","title":"Git的工作原理","keywords":"","body":"Git的工作原理 Git中几个专用名词的译名： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/Git项目创建及克隆.html":{"url":"git/Git项目创建及克隆.html","title":"Git项目创建及克隆","keywords":"","body":"Git项目创建及克隆 本地创建仓库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] 克隆远程仓库 # 下载一个项目和它的整个代码历史 $ git clone [url] Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"git/Git的基本操作命令.html":{"url":"git/Git的基本操作命令.html","title":"Git的基本操作命令","keywords":"","body":"Git的基本操作命令 文件的4中状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前是在什么状态，不然可能会出现想提交的文件没提交上，或者不想提交的文件被提交的情况。 Untracked：未跟踪，此文件在文件夹中，但并未被加入到git库，不参与版本控制。通过git add命令，将文件加入到暂存区，文件状态变为Staged Unmodify：文件未修改，此时文件已经在库中，并且与版本库中的文件快照内容完全一致。这种状态的文件有两种去处： 如果他被修改，则文件状态变为Modified； 如果使用git rm移除版本库，则状态变为Untracked。 Modefied：文件已修改，仅仅是修改，但是并没有进行其它操作。这种文件有两个去处： 通过git add加入到暂存区，变为Staged状态； 或者使用git checkout命令丢弃修改，回到Unmodify状态。git checkout命令是从库中去处文件覆盖当前修改。 Staged：暂存状态， 如果执行git commit命令则将暂存状态的文件提交到库中，这时库中的文件和本地文件一致，文件变为Unmodify状态； 如果执行git reset HEAD filename则取消暂存，文件变为Modified状态。 查看文件状态 # 查看指定文件状态 git status [filename] # 查看所有文件状态 git status 增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ... # # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . git add --all # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 git add -p # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 扩展： · git add -A 提交所有变化 (git add --all的缩写) · git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) · git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 提交代码 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他 # 生成一个可供发布的压缩包 $ git archive Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"redis/redis入门.html":{"url":"redis/redis入门.html","title":"Redis入门","keywords":"","body":"Redis入门 什么是NoSql？ NoSql = Not Only Sql 泛指非关系型数据库，随着互联网web2.0网站的兴起，传统的关系型数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经力不从心，出现了很多难以克服的问题，而费关系型数据库则由于其本身的特点得到了非常迅速的发展。NoSql数据库的产生就是为了解决大规模数据集合多重数据种类带来的调站，尤其是大数据应用难题。 很多数据类型，例如个人信息、社交网络、地理位置等，这些数据类型的存储不需要一个固定的格式，不需要多余的操作就可以横向扩展的。 NoSql特点： 解耦！ 方便扩展（数据之间没有关系，易扩展） 大数据量高性能（Redis一秒可写8W次，读取11W次） 数据类型是多样型的（不需要事先设计数据库） 传统的RDBMS和NoSql区别： 传统RDBMS： - 结构化组织 - SQL - 数据和关系都存在单独的表中 - 严格的一致性 - 基础的实务操作 NoSql： - 不仅仅是数据 - 没有固定的查询语言 - 键值对、列存储、文档型存储、图形数据库 - 最终一致性 - CAP定理和BASE（异地多活） - 高性能、高可用、易扩展 3V+3高： 3V---海量Velume ​ 多样Variety ​ 实时Velocity 3高-----高并发 ​ 高可扩 ​ 高性能 NoSql的四大分类： KV键值对： 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + memcache 文档型数据库（BSON格式）： MongoDB（基于分布式文件存储的数据库，使用C++编写，主要用来处理大量的文档。MongoDB是一个介于关系型数据库和非关系型数据库的中间产品。它是非关系型数据库中功能最丰富的，最像关系型数据库的） ConthDB 列存储 HBase 分布式文件系统 图形关系数据库 Neo4j 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值（key-value） Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra， HBase， Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB， MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J， InfoGrid， Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。 Redis概述： Redis(Remote Dictionary Server) ，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 Redis能干什么？ 内存存储、持久化，内存中是断电即失，所以说持久化很重要(rdb、aof) 效率高，可用于高速缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量！） 特性： 多样化数据类型 持久化 集群 事务 ... 官方地址： 官网 中文官网 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"redis/windows安装Redis.html":{"url":"redis/windows安装Redis.html","title":"windows下安装Redis","keywords":"","body":"windows下安装Redis Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"redis/Linux安装Redis.html":{"url":"redis/Linux安装Redis.html","title":"Linux下安装Redis","keywords":"","body":"Linux下安装Redis 在官网下载最新的安装包：redis-6.0.6.tar.gz 通过ftp工具将安装包上传到Linux服务器，之后将安装包放到/opt目录下并解压： 进入/redis-6.0.6目录 基本的环境安装： yum install gcc-c++ gcc安装完毕之后，使用make命令： make 等待make完毕 redis的默认安装目录： /usr/local/bin 将redis配置文件 可以在当前/usr/local/bin目录下创建目录rconfig，目录名自定义。接着将/opt目录下redis中的配置文件拷贝过来： cp /opt/redis-6.0.6/redis.conf rconfig/ Redis默认不是后台启动的，修改配置文件： 启动Redis服务： 通过指定的配置文件启动服务： 使用redis-cli进行连接测试： 查看redis的进程是否开启： ps -ef|grep redis 关闭Redis服务：(进入到redis-cli中，shutdown) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"redis/redis-benchmark性能测试.html":{"url":"redis/redis-benchmark性能测试.html","title":"redis-benchmark性能测试","keywords":"","body":"redis-benchmark性能测试 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/Docker学习.html":{"url":"docker/Docker学习.html","title":"Docker学习","keywords":"","body":"Docker学习 Docker是基于Go语言开发的 官方文档：https://docs.docker.com/ Docker Hub：https://hub.docker.com/ Docker 是一个开源工具，它可以让创建和管理 Linux 容器变得简单。容器就像是轻量级的虚拟机，并且可以以毫秒级的速度来启动或停止。Docker 帮助系统管理员和程序员在容器中开发应用程序，并且可以扩展到成千上万的节点。 这是一只鲸鱼，它托着许多集装箱。我们可以把宿主机可当做这只鲸鱼，把相互隔离的容器可看成集装箱，每个集装箱中都包含自己的应用程序。 Docker与传统虚拟区别 传统虚拟化技术的体系架构： Docker技术的体系架构： 容器和 VM（虚拟机）的主要区别是: 容器提供了基于进程的隔离，而虚拟机提供了资源的完全隔离。 虚拟机可能需要一分钟来启动，而容器只需要一秒钟或更短。 容器使用宿主操作系统的内核，而虚拟机使用独立的内核。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/Docker中需要知道的概念.html":{"url":"docker/Docker中需要知道的概念.html","title":"1. Docker中需要知道的概念","keywords":"","body":"Docker中需要知道的概念 Docler的基本组成： Client：客户端 Docker_Host：主机，服务器 Registry：仓库 镜像（images）： docker镜像就好比一个模板，可以通过这个模板来创建容器服务。 就像图中的镜像一样，可以通过镜像创建多个容器，各自运行 容器（Containers）： Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的。 容器的基本命令：启动、停止、删除等 仓库（Repository）： 仓库是用来存放镜像的地方，仓库分公有仓库和私有仓库。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/安装Docker.html":{"url":"docker/安装Docker.html","title":"2. 安装Docker","keywords":"","body":"安装Docker 我当前的Linux环境是Cent OS8 安装步骤： 1 卸载旧的版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2 安装yum-utild包： sudo yum install -y yum-utils 3 添加镜像仓库： sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 或者添加阿里的镜像仓库 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新软件包索引： sudo yum makecache fast 5 安装Docker引擎 社区版： docker-cd 社区版 decker-ee 企业版 sudo yum install docker-ce docker-ce-cli containerd.io 6 启动Docker： sudo systemctl start docker 使用docker version命令查看版本： docker version 7 运行Hello World sudo docker run hello-world 查看拉取下来的hello-world镜像： docker images 查看所有镜像 卸载Docker： Uninstall the Docker Engine, CLI, and Containerd packages: sudo yum remove docker-ce docker-ce-cli containerd.io Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes: sudo rm -rf /var/lib/docker Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/配置阿里云镜像加速.html":{"url":"docker/配置阿里云镜像加速.html","title":"3. 配置阿里云镜像加速","keywords":"","body":"配置阿里云镜像加速 登录阿里云：https://www.aliyun.com/ 控制台 -> 服务 -> 容器镜像服务，点击开通，开通之后在左侧侧边栏找到镜像加速器： 阿里提供了不同环境下的操作文档： 安装／升级Docker客户端 推荐安装1.10.0以上版本的Docker客户端，参考文档 docker-ce 配置镜像加速器 针对Docker客户端版本大于 1.10.0 的用户 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/Run的流程和Docker原理.html":{"url":"docker/Run的流程和Docker原理.html","title":"4. Run的流程和Docker原理","keywords":"","body":"Run的流程和Docker原理 底层原理： Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，客户端通过Socket访问主机。 当DockerServer接收到Client发来的Docker指令时，就会执行这个命令。 Docker为什么比VM快？ 1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。 2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。 Docker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/镜像的基本命令.html":{"url":"docker/镜像的基本命令.html","title":"5. 镜像的基本命令","keywords":"","body":"5. 镜像的基本命令 帮助命令： docker version #查看docker版本信息 docker info #当前docker的详细信息 docker [命令] --help #帮助命令 列出镜像： docker images #查看所有的镜像，以及它们的仓库、标签、大小等信息 # 信息解释： # Repository：镜像的仓库源 # Tag：镜像的标签 # Image ID：镜像ID # Created：镜像创建时间 # Size：镜像大小 Options Name, shorthand Default Description --all , -a 显示所有镜像 (default hides intermediate images) --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs 搜索镜像： docker search [OPTIONS] TERM Options Name, shorthand Default Description --automated deprecated Only show automated builds --filter , -f Filter output based on conditions provided --format Pretty-print search using a Go template --limit 25 Max number of search results --no-trunc Don’t truncate output --stars , -s deprecated Only displays with at least x stars 拉取镜像： docker pull [OPTIONS] NAME[:TAG|@DIGEST] # 通过TAG指定要拉取的镜像版本，不指定默认下载最新的 Options Name, shorthand Default Description --all-tags , -a Download all tagged images in the repository --disable-content-trust true Skip image verification --platform experimental (daemon)API 1.32+ Set platform if server is multi-platform capable --quiet , -q Suppress verbose output 删除镜像： 删除一个或者多个镜像 docker rmi [OPTIONS] IMAGE [IMAGE...] Options Name, shorthand Default Description --force , -f Force removal of the image --no-prune Do not delete untagged parents 删除全部镜像： docker rmi -f $(docker images -aq) Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/容器的基本命令.html":{"url":"docker/容器的基本命令.html","title":"6. 容器的基本命令","keywords":"","body":"6. 容器的基本命令 有了镜像之后才可以创建容器，pull一个centos镜像来体验一下容器的命令： 创建容器并运行镜像： Run a command in a new container docker run [OPTIONS] IMAGE [COMMAND] [ARG...] # 参数说明 --name=\"xxx\" # 为容器指定一个名称 -d # 后台方式运行容器 -it # 使用交互方式运行，进入容器查看内容 -p # 指定容器的端口 -p 8080 #容器端口 -p 8080:8080 #主机端口:容器端口 -P # 随机指定端口 Option: Name Description --name 为容器指定一个名称 -d 后台方式运行容器 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 -P 为容器指定随机的公开端口 Docker Run的可选参数比较多，可参见官方文档：https://docs.docker.com/engine/reference/commandline/run/ 测试：以交互的方式运行CentOS镜像 [root@liyandeCentOS /]# docker run -it 831691599b88 /bin/bash [root@59a8779f71c0 /]# ls bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr 退出交互： exit #退出并停止容器 ctrl + p + q #退出不停止容器 列出容器： 列出所有运行中的容器（默认显示正在运行中的） docker ps [OPTIONS] Options: Name, shorthand Default Description --all , -a 显示所有容器 --filter , -f Filter output based on conditions provided --format Pretty-print containers using a Go template --last , -n -1 显示最后创建的n个容器(包括所有状态) --latest , -l Show the latest created container (includes all states) --no-trunc Don’t truncate output --quiet , -q 仅显示容器ID --size , -s Display total file sizes 启动容器： Start one or more stopped containers docker start [OPTIONS] CONTAINER [CONTAINER...] Options: Name, shorthand Default Description --attach , -a Attach STDOUT/STDERR and forward signals --checkpoint experimental (daemon) Restore from this checkpoint --checkpoint-dir experimental (daemon) Use a custom checkpoint storage directory --detach-keys Override the key sequence for detaching a container --interactive , -i Attach container’s STDIN 停止容器： Stop one or more running containers docker stop [OPTIONS] CONTAINER [CONTAINER...] Options Name, shorthand Default Description --time , -t 10 Seconds to wait for stop before killing it 重启容器： Restart one or more containers docker restart [OPTIONS] CONTAINER [CONTAINER...] Options: Name, shorthand Default Description --time , -t 10 Seconds to wait for stop before killing the container 杀死容器： Kill one or more running containers docker kill [OPTIONS] CONTAINER [CONTAINER...] Options Name, shorthand Default Description --signal , -s KILL Signal to send to the container 删除容器： Remove one or more containers docker rm [OPTIONS] CONTAINER [CONTAINER...] Options: Name, shorthand Default Description --force , -f 强制移除正在运行的容器(使用SIGKILL) --link , -l Remove the specified link --volumes , -v Remove anonymous volumes associated with the container Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/日志、元数据、进程的查看.html":{"url":"docker/日志、元数据、进程的查看.html","title":"7. 日志、元数据、进程的查看","keywords":"","body":"7. 日志、元数据、进程的查看 后台启动容器： docker run -d centos docker ps之后，发现刚刚启动的centos容器没有在运行 docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 查看日志： Fetch the logs of a container docker logs [OPTIONS] CONTAINER Options: Name, shorthand Default Description --details Show extra details provided to logs --follow , -f 跟踪日志输出 --since Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail all Number of lines to show from the end of the logs --timestamps , -t 显示时间戳 --until API 1.35+ Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) 查看进程： Display the running processes of a container docker top CONTAINER [ps OPTIONS] 查看镜像元数据： Return low-level information on Docker objects docker inspect [OPTIONS] NAME|ID [NAME|ID...] Options Name, shorthand Default Description --format , -f Format the output using the given Go template --size , -s Display total file sizes if the type is container --type Return JSON for specified type Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/进入容器命令和拷贝命令.html":{"url":"docker/进入容器命令和拷贝命令.html","title":"8. 进入容器命令和拷贝命令","keywords":"","body":"8. 进入容器命令和拷贝命令 进入容器： Run a command in a running container docker exec [OPTIONS] CONTAINER COMMAND [ARG...] Options: Name, shorthand Default Description --detach , -d Detached mode: run command in the background --detach-keys Override the key sequence for detaching a container --env , -e API 1.25+ Set environment variables --interactive , -i 保持STDIN打开，即使没有附加 --privileged Give extended privileges to the command --tty , -t Allocate a pseudo-TTY --user , -u Username or UID (format: uid>[: gid>]) --workdir , -w API 1.35+ Working directory inside the container Attach local standard input, output, and error streams to a running container docker attach [OPTIONS] CONTAINER Options: Name, shorthand Default Description --detach-keys Override the key sequence for detaching a container --no-stdin Do not attach STDIN --sig-proxy true Proxy all received signals to the process 拷贝命令： Copy files/folders between a container and the local filesystem docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"docker/Docker部署nacos单机版.html":{"url":"docker/Docker部署nacos单机版.html","title":"Docker部署nacos单机版","keywords":"","body":"Docker部署nacos单机版 创建nacos容器 搜索镜像 docker search nacos 拉取镜像到本地（未指定版本默认拉取远程仓库中的最新版） docker pull nacos/nacos-server 新建nacos容器 docker run --env MODE=standalone --name nacos -d -p 8848:8848 nacos/nacos-server env参数是指容器所处的环境，这里是指建立单机版的nacos 配置数据库 创建数据库（默认使用mysql数据库） create database nacos_config; 导入sql脚本，到官网复制 修改nacos配置文件 docker exec -it nacos /bin/sh; exit nacos为容器名称，进入交互模式，进入conf目录，可以使用vim编辑nacos配置文件application.properties。 # 修改端口号（默认是8848） server.port=8001 # 数据库的url/user/pass db.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true db.user=root db.password=123456 db.url.1用于配置从数据库，不需要先注释掉 以上都配置完之后重启容器，访问http://localhost:8001/nacos，显示登陆页面，用户名和密码默认都是nacos。 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-13 18:16:50 "},"GoF23/设计模式概述.html":{"url":"GoF23/设计模式概述.html","title":"设计模式概述","keywords":"","body":"设计模式概述 设计模式(Design Pattern)是前辈们对代码开发经验的总结，是解决特丁文提的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。 1995年，GoF(Gang of Four ,四人组/四人帮)合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式，从此树立了软件设计模式领域的里程碑，人称\"GoF设计模式\"。 学习设计模式的意义： 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 GoF23 创建型模式： 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式 结构型模式： 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式 行为型模式： 模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式 OOP七大原则： 开闭原则：对扩展开房，对修改关闭 里氏替换原则：继承必须确保超类所拥有的性质在子类仍然成立 依赖倒置原则：面向接口编程，不要面向实现编程 单一职责原则：控制类的粒度大小，将对象解耦、提高其内聚性 接口隔离原则：要为各个类建立他们需要的专用接口 迪米特法则：只与你的直接朋友交谈，不跟”陌生人“说话 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/单例模式.html":{"url":"GoF23/单例模式.html","title":"单例模式","keywords":"","body":"单例模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/工厂模式.html":{"url":"GoF23/工厂模式.html","title":"工厂模式","keywords":"","body":"工厂模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/抽象工厂模式.html":{"url":"GoF23/抽象工厂模式.html","title":"抽象工厂模式","keywords":"","body":"抽象工厂模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/建造者模式.html":{"url":"GoF23/建造者模式.html","title":"建造者模式","keywords":"","body":"建造者模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/原型模式.html":{"url":"GoF23/原型模式.html","title":"原型模式","keywords":"","body":"原型模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/适配器模式.html":{"url":"GoF23/适配器模式.html","title":"适配器模式","keywords":"","body":"适配器模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/桥接模式.html":{"url":"GoF23/桥接模式.html","title":"桥接模式","keywords":"","body":"桥接模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/静态代理模式.html":{"url":"GoF23/静态代理模式.html","title":"静态代理模式","keywords":"","body":"静态代理模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "},"GoF23/动态代理模式.html":{"url":"GoF23/动态代理模式.html","title":"动态代理模式","keywords":"","body":"动态代理模式 Copyright © liyan 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-27 12:31:40 "}}